///<author>dev@bassetti.fr</author>
///<summary>Unit loading / unloading the dll named "TxAPI". This file is generated by TXUtils. Do not modify.</summary>
unit U_Abstract;
interface

uses
  Generics.Collections, Windows, SysUtils, Classes, Contnrs, dbxJSON, Math, U_Small_Lib, MSXML2_TLB, U_Const, U_Query2, U_Class;

type
  {$REGION 'U_Errors'}
  ///<summary>Base class for all TxAPI errors.</summary>
  ETxAPI=class(ECoded_Error);

  ///<summary>Problem: a delete function was called with a wrong data type.</summary>
  ///<summary>Solution: correct the datatype or modify the delete function so that it handles this datatype.</summary>
  EDelete_Function=class(EDev);

  ///<summary>Problem: a list attribute was sent to a function that do not accept this kind of attribute.</summary>
  ///<summary>Solution: do not call that function with this attribute.</summary>
  EAttribute_List=class(EDev);

  ///<summary>Problem: a function was called with a wrong SPECIAL value. </summary>
  ///<summary>Solution: check the list of SPECIAL available values.</summary>
  EOT_Type_Not_Handled=class(EDev);

  ///<summary>Problem: a function was called with an unhandled TD.</summary>
  ///<summary>Solution: check the function description.</summary>
  ETD_Not_Handled=class(EDev);

  ///<summary>Error raising when trying to use  the TxAPI connection while it was initialized.</summary>
  ///<summary>Solution: initialize the various connections by reading the connection file. See Initialize_TxAPI or Initialize_TxAPI_For_External_Devs.</summary>
  ETxAPI_Connection_Not_Initialized=class(EDev);

  ECriterion_Not_Found=class(EDev);

  ECriterion_Not_Preselection=class(EDev);

  ECriterion_Not_Numerical=class(EDev);

  ECriterion_Not_Boolean=class(EDev);

  ECriterion_Not_Text=class(EDev);

  ///<summary>Error raising when the configuration file using by the Excel Exportation (standard or not) could not be found.</summary>
  EFile_Config_Not_Correctly_Defined=class(ECoded_Error);

  ///<summary>Base class for all the TData_Manager errors.</summary>
  EDM_Error=class(EDev);

  ///<summary>Error raising if the method Read was called twice without calling the clear function between the two calls.</summary>
  EDM_Already_Read=class(EDM_Error);

  ///<summary>Error raising if a non Link Attribute was sent to the Data Manager as a Link Attribute (for inheritage).</summary>
  EDM_Non_Link_Attribute=class(EDM_Error);

  ///<summary>Error raising if a couple (Link Attribute / Inherited Attribute) are not relevant: the Object Type destination of the link Attribute is not the same as the inherited Attribute Object Type.</summary>
  EDM_Inheritance_Not_Relevant=class(EDM_Error);

  ///<summary>Error raising if the preselection is not in accordance with the one predefined.</summary>
  EDMWrongPreselectionType=class(EDev);

  ///<summary>Error raising if no root Object Type was defined.</summary>
  EDM_No_OT_Defined=class(EDM_Error);

  ///<summary>Error raising if the preselection does not contain any Object.</summary>
  EDM_No_Object_Defined=class(EDM_Error);

  ///<summary>Error raising if a method not allowing inherited Attributes was called with an inherited Attribute as parameter.</summary>
  EDM_Function_Not_Callable_For_Inherited_Attribute=class(EDev);

  ///<summary>Error raising when a function requiring a PDF printer was called without any PDF printer installed on the client.</summary>
  ENo_PDF_Printer_Installed=class(EDev);

  ///<summary>Base error class for most of the Model applications errors.</summary>
  EMA=class(ETxAPI);

  ///<summary>Error raising when an error raises during a dll execution.</summary>
  ///<summary>It contains the error message and helpContext of the dll error.</summary>
  ///<summary>Since the dll may be then unloaded, the original error object is destroyed.</summary>
  ///<summary>Its infos are copied in this class before.</summary>
  EMA_Dll_Exception=class(EMA);

  ///<summary>Error raising if the connection with Excel was lost.</summary>
  EExcelNotAccessible=class(EMA);

  EMA_Object_Not_Selected=class(EHandled);

  ///<summary>Error raising if a Equivalence Set with the wrong type is tried to be used.</summary>
  EWrong_Equivalence_Set_Type=class(ETxAPI);

  ///<summary>Error raising if an equivalence could not be found.</summary>
  EEquivalence_Not_Found=class(EDev);

  ///<summary>Error raising when a Users Group with a given identifier could not be loaded.</summary>
  EUsers_Group_Not_Found=class(EDev);

  ///<summary>Error raising if the Administrator User was tried to be unbound from a Users Group.</summary>
  EAdmin_Not_Unbindable=class(EDev);

  EContext_Variable_Not_Found=class(ETxAPI);

  EInvalid_Context_Variable=class(ETxAPI);

  ///<summary>Error raising if an empty name was tried to be given to an Object.</summary>
  EObject_Empty_Name=class(ECoded_Error);

  ///<summary>Error raising if a problem occured in an Object creation function.</summary>
  EObject_Creation=class(ECoded_Error);

  ///<summary>Error raising if a given parent Object could not be found.</summary>
  EObject_Parent_Not_Found=class(ECoded_Error);

  ///<summary>Error raising if a given Object supposed to be the parent Object of a given Object is not.</summary>
  EObject_Parent_Modified=class(ECoded_Error);

  ///<summary>Error raising if a given Object supposed to be the sibbling Object of a given Object could not be found.</summary>
  EObject_Sibling_Not_Found=class(ECoded_Error);

  ///<summary>Error raising if a given Object could not be found.</summary>
  EObject_Not_Found=class(ECoded_Error);

  ///<summary>Error raising if a given Object used by a User object was tried to be deleted.</summary>
  EObject_User=class(ECoded_Error);

  ///<summary>Error raising if a given Object was tried to be deleted while it was previously used by a User object that made logged actions.</summary>
  EObject_With_Actions=class(ECoded_Error);

  ///<summary>Error raising if a given name is not a correct Object name.</summary>
  EObject_Name_Incorrect=class(ECoded_Error);

  ///<summary>Error raising if a given name for an Object is already used by another Object.</summary>
  EObject_Name_Already_Used=class(ECoded_Error);

  ///<summary>Error raising if method of a TS_Object_Data object was called before it was initialized.</summary>
  EObject_Data_Not_Initialized=class(EDev);

  ///<summary>Error raising if the procedure Delete_Objects was called with Objects belonging to different Object Types.</summary>
  EDelete_Objects_Many_OTs=class(EDev);

  ///<summary>Error raising if the procedure Delete_Objects was called with Objects with children not visible for the current User.</summary>
  EObjects_Not_Deletable=class(ECoded_Error);

  ///<summary>Error raising if a non numerical Attribute was tried to be used as a numerical Attribute.</summary>
  EAttribute_Not_Numerical=class(EDev);

  ///<summary>Error raising if a non boolean Attribute was tried to be used as a boolean Attribute.</summary>
  EAttribute_Not_Boolean=class(EDev);

  ///<summary>Error raising if a non string Attribute was tried to be used as a string Attribute.</summary>
  EAttribute_Not_String=class(EDev);

  ///<summary>Error raising if a non link Attribute was tried to be used as a link Attribute.</summary>
  EAttribute_Not_Link=class(EDev);

  ///<summary>Error raising if a non file Attribute was tried to be used as a link Attribute.</summary>
  EAttribute_Not_File=class(EDev);

  ///<summary>Error raising if an Attribute with a Data Type different from the one(s) expected was tried to be used.</summary>
  EAttribute_With_Wrong_TD=class(EDev);

  EAttribute_Not_Belonging_To_The_Expected_Object_Type=class(EDev);

  ///<summary>Error raising if no user is connected.</summary>
  ENo_User_Connected=class(EDev);

  ///<summary>Error raising if more than one User is tried to be connected to the TxAPI.</summary>
  EUser_Already_Connected=class(EDev);

  ///<summary>Error raising if the User trying to connect to the TxAPI is not existing (wrong ID, wrong login, etc.)</summary>
  EUser_Not_Existing=class(EDev);

  ///<summary>Error raising if the TxAPI revision does not match the executable revision.</summary>
  ERevision=class(ETxAPI);

  ///<summary>Base class for all connection errors.</summary>
  EConnection=class(ETxAPI);

  ///<summary>Error raising if no Object Type "Peoples" could be found.</summary>
  EOT_User_Not_Found=class(EConnection);

  ///<summary>Error raising when none of the LDAP connections succeeded.</summary>
  ENo_LDAP_Connected=class(EConnection);

  ///<summary>Error raising if a connection function is called with an empty login.</summary>
  EEmpty_Login=class(EConnection);

  ///<summary>Error raising if the login and password of the User trying to connect do not match.</summary>
  EBind_Not_Correct=class(EConnection);

  ///<summary>Error raising when no LDAP (or AD) connection is defined whereas it is awaited.</summary>
  ENo_LDAP_Connection_Defined=class(EConnection);

  ///<summary>Error raising when trying to connection with the current session login but no session opened.</summary>
  E_No_Session_Opened=class(EConnection);

  ///<summary>Error raising if an automatic connection is attempted but only manual connection is allowed.</summary>
  EManual_Connection_Only=class(EConnection);

  ///<summary>Error raising if a connection with a default connection is set but no default login is defined.</summary>
  ENo_Default_Login_Defined=class(EConnection);

  ///<summary>Error raising if an automatic connection failed and manual connection is forbidden.</summary>
  EManual_Connection_Prohibited=class(EConnection);

  ///<summary>Error raising if the user connected does not see any Object Type.</summary>
  EBlind_User=class(EConnection);

  ///<summary>Error raising if the User trying to connect has its account expired.</summary>
  EAccount_Expired=class(EConnection);

  ///<summary>Error raising if the User trying to connect has its password expired.</summary>
  EPassword_Expired=class(EConnection);

  ///<summary>Error raising if the password confirmation is different from the new password.</summary>
  EPassword_Not_Correctly_Confirmed=class(ETxAPI);

  ///<summary>Error raising if the new password is the same as the previous one.</summary>
  EPassword_Not_Changed=class(ETxAPI);

  ///<summary>Error raising if the password does not respect the policy.</summary>
  EPassword_Policy_Not_Respected=class(ETxAPI);

  ///<summary>Base class for all TEEXMA.exml errors.</summary>
  ETEEXMA_EXML=class(ETxAPI);

  ///<summary>Error raising if the TEEXMA.exml file could not be found.</summary>
  ///<summary>Check the Rights on the file or its folder, create the file with the Administration.</summary>
  ETEEXMA_EXML_Missing=class(ETEEXMA_EXML);

  ///<summary>Base class for all Licences.ini errors.</summary>
  ELicences_Ini=class(ETxAPI);

  ///<summary>Error raising if the Licences.ini file could not be found.</summary>
  ///<summary>Check the rights on the file or its folder.</summary>
  ELicence_Ini_Missing=class(ELicences_Ini);

  ///<summary>Error raising if no connection could be done to the TEEXMA database.</summary>
  ETEEXMA_DB=class(ETEEXMA_EXML);

  ///<summary>Error raising if no connection to the Workflow database could be done.</summary>
  ETEEXMA_Workflow_DB=class(ETEEXMA_EXML);

  ///<summary>Error raising if no connection could be done to the archived files database.</summary>
  ETEEXMA_DB_Archived_Files=class(ETEEXMA_EXML);

  ///<summary>Error raising if the folder containing the files could not be found.</summary>
  ETEEXMA_Dir_Archived_Files_Not_Found=class(ETEEXMA_EXML);

  ///<summary>Error raising if the folder containing the customer resources could not be found.</summary>
  ETEEXMA_Customer_Resources=class(ETEEXMA_EXML);

  ///<summary>Error raising if the revision of the database is different from the one expected by the TxAPI.</summary>
  EDB_Revision=class(ETxAPI);

  ///<summary>Error raising if the maximum numbers of loops "Model triggering / data writing" was reached.</summary>
  ENb_MA_Loops=class(ETxAPI);

  ///<summary>Error raising if the numbers of loops "Model reaches an negative values (theorically impossible).</summary>
  ENb_MA_Loops_Negative=class(EDev);

  ///<summary>Error raising if an attribute could not be found.</summary>
  EAttribute_Not_Found=class(ECoded_Error);

  ///<summary>Error raising if a function was called whereas it is not available into the given context (win / web) of use.</summary>
  EWrong_Context=class(EDev);

  ///<summary>Error raising if a given non Table Attribute was tried to be used as a Table Attribute.</summary>
  EAttribute_Is_Not_Table=class(ETxAPI);

  ///<summary>Base class for all the data table error.</summary>
  ETable=class(ETxAPI);

  ///<summary>Error raising if a given Series Type could not be found.</summary>
  ESeries_Type_Unknown=class(ETable);

  ///<summary>Error raising if a table data has it its series not ordered by Series Type ascending.</summary>
  ESeries_Types_Unordered=class(ETable);

  ///<summary>Error raising if a table data has more than one series of a Series Type allowing only one Series.</summary>
  EToo_Many_Series=class(ETable);

  ///<summary>Error raising if a table data has a Series with non numerical values while it Series Type only accepts numerical values.</summary>
  EAlpha_Value_Found=class(ETable);

  ///<summary>Error raising if file data tries to update its archived file using a file with a different extension than the one already stored into the database.</summary>
  EUpdated_File_With_Wrong_Ext=class(ECoded_Error);

  ///<summary>Error raising if a file data tries to use an unexisting archived file.</summary>
  EFile_Not_Archived=class(ECoded_Error);

  ///<summary>Error raising if a file data tries to publish a file "as new" but already stored into the file dabase.</summary>
  EArchived_File_Already_Existing=class(ECoded_Error);

  ///<summary>Error raising if the method "ToExcel" of the "TD_Data_Table" class was called for a Table Type not using an excel file.</summary>
  EMethod_To_Excel_Not_Callable=class(EDev);

  ELibrary_Model_Missing=class(EObject_Creation);

  ELibrary_Document_Not_Referenceable=class(ECoded_Error);

  EArchived_File_Not_Extractable=class(ECoded_Error);

  ELibrary_Document_Not_Versionable=class(ECoded_Error);

  ELibrary_New_Model_Initialize=class(ECoded_Error);

  ELibrary_New_Document_Initialize=class(ECoded_Error);

  ///<summary>Error raising when the connection to the database was lost and could be reinitialized.</summary>
  EConnection_Reinitialized=class(ECoded_Error);

  ///<summary>Error raising when the connection to the database was lost and could not be reinitialized.</summary>
  EConnection_Lost=class(ECoded_Error);

  ///<summary>Base error class for all XML classes.</summary>
  ///<summary>It returns a part of the XML if possible.</summary>
  ETxAPIXML=class(ETxAPI);

  ///<summary>Error occuring when the Data Type of an XML node is not handled.</summary>
  EXML_TD_Not_Handled=class(ETxAPIXML);

  ///<summary>Error occuring when the Data Type of an XML node is not handled.</summary>
  EXML_Wrong_TD=class(ETxAPIXML);

  EIncorrect_Extractions_Rights=class(ETxAPI);

  EModelApplicationCouldNotExecute=class(ETxAPI);

  EAppliedOutputTreatmentFailed=class(ETxAPI);

  EIncorrect_Filter=class(ETxAPI);

  ///<summary>Error raising when no link Attribute is defined for a given model application using a Visible/Invisible group model.</summary>
  EMA_Group_Visible_No_Link_Attribute_Defined=class(ECoded_Error);

  ///<summary>Error raising when the Attribute defined for a given model application using a Visible/Invisible group model is not a link Attribute.</summary>
  EMA_Group_Visible_Attribute_Not_Link=class(ECoded_Error);

  ETagged_Concept_Not_Found=class(ETxAPI);

  ///<summary>Error raising if a given File Type was tried to be deleted whereas it already has Archived Files.</summary>
  EFile_Type_Has_Archived_Files=class(ECoded_Error);

  ///<summary>Error raising in the active User tries to modify the data of a given Attribute with insufficient rights.</summary>
  EAttribute_Not_Writable=class(ECoded_Error);

  ///<summary>Error raising in the active User tries to modify the data or the Objects of a given Object Type with insufficient rights.</summary>
  EObject_Type_Not_Writable=class(ECoded_Error);

  ///<summary>Error raising in the active User tries to modify the data of a given Object with insufficient rights.</summary>
  EObject_Not_Writable=class(ECoded_Error);

  ///<summary>Error raising if a given method is called for a given question type while it is not allowed.</summary>
  EWrong_Question_Type=class(EDev);

  ///<summary>Error raising when a User's Group with a given name is tried to be created while the name is already taken by another group.</summary>
  EUsers_Group_Already_Existing=class(ETxAPI);

  ///<summary>Error raising when a non business Users Group is tried to be used as a business Users Group.</summary>
  EUsers_Group_Not_Business=class(EDev);

  ///<summary>Error raising when the Attribute Set of the business Users Group contains references to non link Attributes.</summary>
  EUsers_Group_Non_Link_Data_In_Business=class(EDev);
  {$ENDREGION}

  {$REGION 'U_Root_Classes'}
  ///<summary>Listing describing a database action to do on a given object.</summary>
  TDB_Action=(
    ///No action.
    dbaNone,
    ///Corresponds to an INSERT query.
    dbaAdd,
    ///Corresponds to an UPDATE query.
    dbaModif,
    ///Corresponds to a DELETE query.
    dbaDel);

  TDB_Actions=set of TDB_Action;

  ///<summary>Listing describing the right of the active user on a given object.</summary>
  TDB_Right=(
    ///The user has no access on the object
    dbrNone,
    ///The user is allowed to read the current object but cannot modify them.
    dbrRead,
    ///The user is allowed to add new object or modify the objects he created.
    dbrAdd,
    ///The user is allowed to view and modify the current object.
    dbrModif,
    ///The user is allowed to modify the structure of the current object.
    dbrStructure);

  TDB_Rights=set of TDB_Right;

  ///<summary>The various TObjectList of TID_Object clearing mode.</summary>
  TOL_Clearing_Mode=(
    ///This is equivalent to call the clear method (no real interest)
    olcmClear,
    ///The OwnsObject property is ignored and objects are not freed.
    olcmClear_Without_Freeing,
    ///the ownsObject property is ignored and object are freed.
    olcmClear_And_Free,
    ///the objects are removed if their action is equal to dbaAdd. Else, their action is set to dbaDel.
    olcmRemove_Or_Set_To_DbaDel);

  ///<summary>Enumeration describing the level of verbosity of the xml created by the current object or function.</summary>
  TVerbosity=(
    vDatabase,
    vAutoDescribed,
    vForDisplay);

  TStringType=(
    stXML,
    stJSON);

  EIDObjNotFound=class(EDev);

  ///<summary>Base class for all classes of the TxAPI.</summary>
  TID_Object=class(TObject)
  public
    procedure Initialize; virtual; stdcall; abstract;
    procedure Assign(const AObject: TID_Object); overload; virtual; stdcall; abstract;
    procedure Assign(const ANode: IInterface; const AFilesDir: string); overload; virtual; stdcall; abstract;
    procedure Assign(const AObject: TJSONObject); overload; virtual; stdcall; abstract;
    procedure Assign(const AQuery: TQQuery); overload; virtual; stdcall; abstract;
    function Fill_XMLDoc(const ADoc: IInterface; const ANode_Parent: IInterface; const AVerbosity: TVerbosity; const AFilesDir: string; const AUse_RPath: Boolean; const AName: string=''): IInterface; virtual; stdcall; abstract;
    function ToXML(const AVerbosity: TVerbosity=vDatabase; const AFilesDir: string=''; const AUse_RPath: Boolean=False; const AName: string=''): string; overload; virtual; stdcall; abstract;
    procedure SaveAs_XML(const APath_File: string; const AVerbosity: TVerbosity=vDatabase; const AFilesDir: string=''; const AUse_RPath: Boolean=False); virtual; stdcall; abstract;
    procedure Fill_JSONObject(const AObject: TJSONObject); virtual; stdcall; abstract;
    function Create_JSONObject: TJSONObject; virtual; stdcall; abstract;
    function ToJSON: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID".</summary>
    ///<summary>The identifier of the object.</summary>
    procedure Set_ID(const AID: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID".</summary>
    ///<summary>The identifier of the object.</summary>
    function Get_ID: Integer; virtual; stdcall; abstract;
    function Get_sID: string; virtual; stdcall; abstract;
    function Set_ID_Fictive: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "TD".</summary>
    ///<summary>The data type of the object. See the unit U_Const for a complete list of these types.</summary>
    procedure Set_TD(const ATD: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "TD".</summary>
    ///<summary>The data type of the object. See the unit U_Const for a complete list of these types.</summary>
    function Get_TD: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iRight".</summary>
    ///<summary>The right of the user on the object.</summary>
    procedure Set_Right(const ARight: TDB_Right); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iRight".</summary>
    ///<summary>The right of the user on the object.</summary>
    function Get_Right: TDB_Right; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iAction".</summary>
    ///<summary>The "write" action defined for the object.</summary>
    procedure Set_Action(const AAction: TDB_Action); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iAction".</summary>
    ///<summary>The "write" action defined for the object.</summary>
    function Get_Action: TDB_Action; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sTags".</summary>
    ///<summary>The identifier of a specific Object.</summary>
    procedure Set_Tags(const ATags: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sTags".</summary>
    ///<summary>The identifier of a specific Object.</summary>
    function Get_Tags: string; virtual; stdcall; abstract;
    procedure AddTag(const ATag: string); virtual; stdcall; abstract;
    procedure RemoveTag(const ATag: string); virtual; stdcall; abstract;
    function Get_FirstTag: string; virtual; stdcall; abstract;
    function IsTagged: Boolean; virtual; stdcall; abstract;
    function CheckIf_Tagged(const ATag: string): Boolean; virtual; stdcall; abstract;
    function CheckIf_SystemTagged: Boolean; virtual; stdcall; abstract;
    procedure Write; virtual; stdcall; abstract;
    ///<summary>This function compares two Objects, checking if all their attributes are equal.</summary>
    ///<param name="AObject">The second Object to compare.</param>
    ///<param name="ACompare_IDs">If true, the function will also compare the ID of those Objects.</param>
    function Compare(const AObject: TObject; const ACompare_IDs: Boolean): Boolean; virtual; stdcall; abstract;
    function Copy: TObject; virtual; stdcall; abstract;
  end;

  ///<summary>Base class for all named (and ordered) objects.</summary>
  TNamed_Object=class(TID_Object)
  public
    ///<summary>Setter for the variable "sName".</summary>
    ///<summary>The name of the object.</summary>
    procedure Set_Name(const AName: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sName".</summary>
    ///<summary>The name of the object.</summary>
    function Get_Name: string; virtual; stdcall; abstract;
    function Get_Raw_Name: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sDescription".</summary>
    ///<summary>A description of the object.</summary>
    procedure Set_Description(const ADescription: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sDescription".</summary>
    ///<summary>A description of the object.</summary>
    function Get_Description: string; virtual; stdcall; abstract;
    function Get_Raw_Description: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sExplaination".</summary>
    ///<summary>A description for administrator of the object: its reasons, its various uses, aso.</summary>
    procedure Set_Explaination(const AExplaination: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sExplaination".</summary>
    ///<summary>A description for administrator of the object: its reasons, its various uses, aso.</summary>
    function Get_Explaination: string; virtual; stdcall; abstract;
    function Get_Hint: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iOrder".</summary>
    ///<summary>The order of the object.</summary>
    procedure Set_Order(const AOrder: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iOrder".</summary>
    ///<summary>The order of the object.</summary>
    function Get_Order: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Base class for all "treed" objets.</summary>
  TTree_Object=class(TNamed_Object)
  public
    ///<summary>Setter for the variable "ID_Parent".</summary>
    ///<summary>The identifier of the parent object.</summary>
    procedure Set_ID_Parent(const AID_Parent: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Parent".</summary>
    ///<summary>The identifier of the parent object.</summary>
    function Get_ID_Parent: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bParent".</summary>
    ///<summary>If true, the object has children object.</summary>
    procedure Set_Parent(const AParent: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bParent".</summary>
    ///<summary>If true, the object has children object.</summary>
    function Get_Parent: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bFolder".</summary>
    ///<summary>If true, the object is a folder.</summary>
    procedure Set_Folder(const AFolder: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bFolder".</summary>
    ///<summary>If true, the object is a folder.</summary>
    function Get_Folder: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iIcon".</summary>
    ///<summary>Icon index of the object.</summary>
    procedure Set_Icon(const AIcon: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iIcon".</summary>
    ///<summary>Icon index of the object.</summary>
    function Get_Icon: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Class handling an object and it "visual" associated object.</summary>
  TCoupled_Object=class(TTree_Object)
  public
    ///<summary>Getter for the variable "rObject_Viewed".</summary>
    ///<summary>The object to display.</summary>
    function Get_Object_Viewed: TTree_Object; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "rObject".</summary>
    ///<summary>The associated object.</summary>
    procedure Set_Object(const AObject: TObject); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "rObject".</summary>
    ///<summary>The associated object.</summary>
    function Get_Object: TObject; virtual; stdcall; abstract;
  end;

  ///<summary>An extension of the TTree_Object class. The object owns its children object.</summary>
  TBranch=class(TTree_Object)
  public
    function Add_Child(const AChild: TTree_Object; const AID_Next_Sibling: Integer=0; const AHandle_Kinship: Boolean=True): TTree_Object; virtual; stdcall; abstract;
    function Remove_Child(const AChild: TTree_Object; const AUpdate_Orders: Boolean=True; const ARecursive: Boolean=False; const AForce_Removal: Boolean=False): Boolean; virtual; stdcall; abstract;
    function Get_Child(const AID_Child: Integer; const ARecursive: Boolean=True): TTree_Object; virtual; stdcall; abstract;
    procedure Fill_OL(const AOL_Branch: TObjectList; const ARecursive: Boolean=True; const AExtract: Boolean=False); virtual; stdcall; abstract;
    procedure Update_Orders(const ARecursive: Boolean=False); virtual; stdcall; abstract;
    procedure Sort_Per_Order; virtual; stdcall; abstract;
    procedure Reorganize; virtual; stdcall; abstract;
    function Get_Parent_Branch: TBranch; virtual; stdcall; abstract;
    function Get_OL_Branch: TObjectList; virtual; stdcall; abstract;
  end;

  ///<summary>Procedure enabling to activate/desactivate the expert mode.</summary>
  ///<values>The expert mode allows you to see the identifiers of all TEEXMA named objects: they are displayed beyond their name</values>
  ///<param name="AExpert_Mode">if true, it activates the expert mode.</param>
  TSet_Expert_Mode=procedure(const AExpert_Mode: Boolean); stdcall;

  ///<summary>Function indicating if the expert mode is activated or not.</summary>
  ///<values>The expert mode allows you to see the identifiers of all TEEXMA named objects: they are displayed beyond their name</values>
  TGet_Expert_Mode=function: Boolean; stdcall;

  TCreate_IDObjFromQuery=function(const ATD: Integer; const AQuery: TQQuery): TID_Object; stdcall;

  ///<summary>Function creating a TBranch object.</summary>
  ///<summary>Function creating a TTree_Object object.</summary>
  TCreate_TreeObj=function: TTree_Object; stdcall;

  ///<summary>Function creating a TNamed_Object object.</summary>
  TCreate_NamedObj=function: TNamed_Object; stdcall;

  TIndexOfIDObj=function(const AOL: TObjectList; const AID: Integer; const ASorted: Boolean=False): Integer; stdcall;

  TIndexOfIDObjExt=function(const AOL: TObjectList; const AID: Integer; const ASorted: Boolean; const ARaiseException: Boolean; const ATD: Integer): Integer; stdcall;

  TGet_IDObj=function(const AOL: TObjectList; const AID: Integer; const ASorted: Boolean=False): TID_Object; stdcall;

  TGet_IDObjExt=function(const AOL: TObjectList; const AID: Integer; const ASorted: Boolean; const ARaiseException: Boolean; const ATD: Integer): TID_Object; stdcall;

  ///<summary>Function returning the index of a given ordered object into a given list.</summary>
  ///<param name="AOL">The list to search into.</param>
  ///<param name="AOrder">The order of the object to search.</param>
  ///<param name="AIgnore_Deleted">If true, object with a state "dbaDel" are ignored.</param>
  ///<param name="ASorted">If true, the list is order ascending sorted.</param>
  TIndexOf_Ordered_Object=function(const AOL: TObjectList; const AOrder: Integer; const AIgnore_Deleted: Boolean=True; const ASorted: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the object with a given order into a given list.</summary>
  ///<param name="AOL">The list to search into.</param>
  ///<param name="AOrder">The order of the object to search.</param>
  ///<param name="AIgnore_Deleted">If true, object with a state "dbaDel" are ignored.</param>
  ///<param name="ASorted">If true, the list is order ascending sorted.</param>
  TGet_Ordered_Object=function(const AOL: TObjectList; const AOrder: Integer; const AIgnore_Deleted: Boolean=True; const ASorted: Boolean=False): TNamed_Object; stdcall;

  ///<summary>Function returning the index of a given named object into a given list.</summary>
  ///<param name="AOL">The list to search into.</param>
  ///<param name="AName">The name of the object to search.</param>
  ///<param name="AIgnoreDeleted">If true, object with a state "dbaDel" are ignored.</param>
  ///<param name="ASorted">If true, the list is name ascending sorted.</param>
  ///<param name="ACaseSensitive">If true, the search is case sensitive.</param>
  TIndexOf_Named_Object=function(const AOL: TObjectList; const AName: string; const AIgnoreDeleted: Boolean=True; const ASorted: Boolean=False; const ACaseSensitive: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the index of the first child object of a given object into a given list.</summary>
  ///<param name="AOL">The list to search into.</param>
  ///<param name="AID_Parent">The identifier of the parent object.</param>
  TIndexOf_Child=function(const AOL: TObjectList; const AID_Parent: Integer): Integer; stdcall;

  ///<summary>Function returning the first child object of a given object into a given list.</summary>
  ///<param name="AOL">The list to search into.</param>
  ///<param name="AID_Parent">The identifier of the parent object.</param>
  TGet_Obj_Child=function(const AOL: TObjectList; const AID_Parent: Integer): TTree_Object; stdcall;

  ///<summary>Function searching recursively the parent objects and returning the root object of a given object.</summary>
  ///<param name="AOL">The list to search into.</param>
  ///<param name="AID">The identifier of the "child" object.</param>
  TGet_Object_Parent=function(const AOL: TObjectList; const AID: Integer): TTree_Object; stdcall;

  ///<summary>Function returning the object with a given name into a given list.</summary>
  ///<param name="AOL">The list to search into.</param>
  ///<param name="AName">The name of the object to search.</param>
  ///<param name="AIgnore_Deleted">If true, object with a state "dbaDel" are ignored.</param>
  ///<param name="ASorted">If true, the list is name ascending sorted.</param>
  ///<param name="ACase_Sensitive">If true, the search is case sensitive.</param>
  TGet_Named_Object=function(const AOL: TObjectList; const AName: string; const AIgnore_Deleted: Boolean=True; const ASorted: Boolean=False; const ACase_Sensitive: Boolean=True): TNamed_Object; stdcall;

  ///<summary>Function returning the index of a given "ID" object into a given list. If a given item has no object, its text value is compared to the desired identifier.</summary>
  ///<param name="ASL">The list to search into.</param>
  ///<param name="AID_Object">The identifier of the object searched.</param>
  ///<param name="AType">The class of the object searched (do not use).</param>
  ///<param name="AIgnore_Deleted">If true, deleted object are ignored.</param>
  TIndexOfIDObj_In_SL=function(const ASL: TStrings; const AID_Object: Integer; const AType: TClass=nil; const AIgnore_Deleted: Boolean=True): Integer; stdcall;

  ///<summary>Function creating a TStringList containing the identifiers of a list of TID_Object objects.</summary>
  ///<param name="AOL">The list of TID_Object object.</param>
  ///<param name="AInclude_Folders">If false, Object in the list are assumed to inherit from TTree_Object and folder Objects are ignored.</param>
  TCreate_SL_From_OL=function(const AOL: TObjectList; const AInclude_Folders: Boolean=True): TStringList; stdcall;

  ///<summary>Function returning a concatened string of identifiers contained into a given list of "ID" objects.</summary>
  ///<param name="AOL">The list of objects.</param>
  ///<param name="ASeparator">The separator to use between the identifiers.</param>
  TOLIDObjToIDs=function(const AOL: TObjectList; const ASeparator: string=','): string; stdcall;

  ///<summary>Function creating a TCoupled_Object object.</summary>
  TCreate_CoupledObj=function(const AObjectViewed: TTree_Object; const AObject: TObject): TCoupled_Object; stdcall;

  ///<summary>Function creating a filtered list thanks to a parent identifier. Objects class is supposed to inherit from TTree_Object.</summary>
  ///<param name="AOl">list of TTree_Object objects.</param>
  ///<param name="AIdParent">identifier of the parent object.</param>
  ///<param name="ASorted">if true, the list is supposed to be sorted by ID_Parent.</param>
  ///<param name="AExtractObjects">if true; objects found will be extracted from the main list and the result list will own its objects.</param>
  ///<param name="ARecursive">if true, children Objects are added as well.</param>
  TCreate_OL_Filtered_From_Parent=function(const AOl: TObjectList; const AIdParent: Integer; const ASorted: Boolean=False; const AExtractObjects: Boolean=False; const ARecursive: Boolean=False): TObjectList; stdcall;

  ///<summary>Procedure removing the objects with an action equals to dbaAdd or setting their action to dbaDel in the opposite case.</summary>
  ///<param name="AOL">The list to clear.</param>
  ///<param name="AMode">The clearing mode.</param>
  TClear_OLIDObj=procedure(const AOL: TObjectList; const AMode: TOL_Clearing_Mode); stdcall;

  ///<summary>Function removing or setting to dbaDel a given object from a given list.</summary>
  ///<param name="AOL">The list to remove the object from.</param>
  ///<param name="AObject">The object to remove or to set its action to dbaDel.</param>
  ///<param name="AForceRemoval">If true, the object is removed whatever its action value.</param>
  TRemove_IDObj=function(const AOL: TObjectList; const AObject: TID_Object; const AForceRemoval: Boolean=False): Boolean; stdcall;

  ///<summary>Function returning true if some of the objects in the list returned a result different from dbaNone when calling their Get_Action method.</summary>
  ///<param name="AOL">The list of TID_Object objects.</param>
  TIsOLIDObjModified=function(const AOL: TObjectList): Boolean; stdcall;

  ///<summary>Procedure adding TID_Object object from a source list to a destination list.</summary>
  ///<summary>The procedure handles the copy of the objects if required.</summary>
  ///<param name="AOL_Source">The source list.</param>
  ///<param name="AOL_Dest">The destination list.</param>
  ///<param name="ADuplicate_Objects">If true, objects of the source list will be duplicated (via the "Copy" method).</param>
  ///<param name="AMerge_Lists">If true and if objects are not duplicated, the method Assign(AOL_Source,laOr) is called. If false, the objects are added to the list, already present or not.</param>
  ///<param name="AClear_Dest">if true, the destination list is emptied before adding the new objects.</param>
  TAdd_IDObjs=procedure(const AOL_Source: TObjectList; const AOL_Dest: TObjectList; const ADuplicate_Objects: Boolean; const AMerge_Lists: Boolean; const AClear_Dest: Boolean=False); stdcall;

  TCreate_IDObjFromClassName=function(const AClassName: string): TID_Object; stdcall;

  ///<summary>Function creating an object thanks to its "Data Type" identifier.</summary>
  ///<param name="ATD">The data type of the class.</param>
  TCreate_IDObj=function(const ATD: Integer): TID_Object; stdcall;

  TCreate_IDObjFromXMLNode=function(const ANode: IXMLDOMNode; const ADirForFiles: string): TID_Object; stdcall;

  TTDToClassName=function(const ATD: Integer): string; stdcall;

  ///<summary>Function returning a short description of a given TEEXMA data type.</summary>
  ///<param name="ATD">the Data Type.</param>
  TTDToStr=function(const ATD: Integer): string; stdcall;

  TGet_IDObjName=function(const AOL: TObjectList; const AID: Integer; const ASorted: Boolean=False): string; stdcall;

  TGet_IDObjNameExt=function(const AOL: TObjectList; const AID: Integer; const ASorted: Boolean; const ARaiseException: Boolean; const ATD: Integer): string; stdcall;

  TOlToJSONArray=function(const AOl: TObjectList): TJSONArray; stdcall;

  TOlToJSON=function(const AOl: TObjectList): string; stdcall;

  TFillJSONArray=procedure(const AJSONObject: TJSONArray; const AOl: TObjectList); stdcall;
  {$ENDREGION}

  {$REGION 'U_Misc'}
  ///<summary>Listing defining the various sorting type of a TObjectList.</summary>
  TObject_Ordering_Type=(
    ///No ordering defined.
    ootNone,
    ///Ordering by identifier ascending
    ootID_Ascending,
    ///Ordering by identifier descending
    ootID_Descending,
    ///Ordering by order ascending
    ootOrder_Ascending,
    ///Ordering by order descending
    ootOrder_Descending,
    ///Ordering by name ascending
    ootName_Ascending,
    ///Ordering by name descending
    ootName_Descending,
    ///Ordering by type and name descending
    ootObject_Type,
    ///Ordering by tree (parent + order)
    ootTree,
    ootData_by_Object,
    ootData_by_Attribute,
    ootParent_Ascending,
    ootParent_Descending,
    ootEq_sID_Right_Ascending,
    ootEq_ID_Right_Ascending,
    ootEq_ID_Left_Ascending,
    ootData_String_Ascending,
    ootData_Numerical_Ascending,
    ootData_Link_Ascending,
    ootData_Date_Ascending,
    ootApplied_IO_Ascending,
    ootVACBOA_by_Object,
    ootVACBOA_by_Attribute,
    ootLevel_Col,
    ootObj_ID_OT_Ascending,
    ootSeries_Ascending);

  TClassNameToTable=function(const AClassName: string): string; stdcall;

  ///<summary>Procedure sorting a given list of objects thanks to a given Sorting Type.</summary>
  ///<param name="AOL_Object">The list to sort.</param>
  ///<param name="ASorting_Type">The sorting type.</param>
  TSort_OL=procedure(const AOL_Object: TObjectList; const ASorting_Type: TObject_Ordering_Type); stdcall;
  {$ENDREGION}

  {$REGION 'U_Action'}
  ///<summary>Enumeration of action type that can be stored into the log table.</summary>
  TLog_Action_Type=(
    ///Adding of an object.
    latAdd,
    ///Modification of an object.
    latModif,
    ///Deletion of an object.
    latDel,
    ///Opening action (of a window or an executable for example).
    latOpening,
    ///Closing action (of a window or an executable for example).
    latClosing,
    ///Browsing action of an object.
    latBrowsing,
    ///Execution of a multicriteria selection.
    latMCS,
    ///Execution of an exportation.
    latExportation,
    ///Execution of an extraction.
    latExtraction,
    ///Execution of a Data Mining calculation.
    latDM,
    ///Execution of a Curve superposition calculation.
    latCurve_Superposition,
    ///Execution of a Text Search.
    latTextSearch);

  ///<summary>Enumeration of the action's context.</summary>
  TLog_Action_Context=(
    ///No particular context.
    lacNone,
    ///The action was executed from an object tree view.
    lacTree_Object,
    ///The action was executed from a business view.
    lacBV,
    ///The action was executed from the table view.
    lacTV,
    ///The action was executed from the read form.
    lacRead_Form,
    ///The action was executed from the write form.
    lacWrite_Form,
    ///The action was executed from the portal (more precise than the read form).
    lacPortal,
    ///The action was executed from the detailed results window of the multicriteria selection.
    lacMCS_Detailed_Results,
    ///The saction was executed from the Text Search results panel.
    lacTextSearch_Panel,
    ///The action was executed from TEEXMA Win.
    lacTEEXMA_Win,
    ///The object is considered as "modified" because of a data modification.
    lacData_Modification,
    ///The object is considered as "modified" because of a name modification.
    lacRenaming,
    ///The object is considered as "modified" because of a folder status modification.
    lacTransformed_Into_Folder,
    ///The object is considered as "modified" because it was moved.
    lacMoved,
    ///The action was executed from the Multicriteria selection panel.
    lacMCS_Panel,
    ///The action was executed from the Choice Guide form.
    lacCG_Window,
    ///The action was executed because of a Model Application query.
    lacMA,
    ///The action was executed because of a next / prev browsing action
    lacBrowsing_History,
    ///The action was executed from a specific developpement.
    lacDev,
    ///The action was executed from the Administration module.
    lacAdministration,
    ///The action was executed from TEEXMA Web.
    lacTEEXMA_Web,
    ///The action was executed from the Exportation window.
    lacExportation,
    ///The action was executed from the Extraction window.
    lacExtraction);

  ///<summary>Class handling the informations of an TxAPI log action.</summary>
  TMD_Action=class(TID_Object)
  public
    ///<summary>Function returning a string containing the informations of the object, formated to be added to a csv stream.</summary>
    ///<param name="ASeparator">The separator to use between the various informations (TAB, ;, aso.).</param>
    function ToRow(const ASeparator: string): string; virtual; stdcall; abstract;
    procedure Treat_Comments(const AOL_Object: TObjectList); virtual; stdcall; abstract;
    function Get_Text(const AColumn: Integer): string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iType".</summary>
    ///<summary>The type of action.</summary>
    function Get_Type: TLog_Action_Type; virtual; stdcall; abstract;
    function Get_ID_Object_Owner: Integer; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sSystem".</summary>
    ///<summary>The system.</summary>
    function Get_System: string; virtual; stdcall; abstract;
    function Get_TD_Object: Integer; virtual; stdcall; abstract;
    function Get_ID_Object: Integer; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iContext".</summary>
    ///<summary>The context of the action.</summary>
    function Get_Context: TLog_Action_Context; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fDate".</summary>
    ///<summary>The date of the action.</summary>
    function Get_Date: Double; virtual; stdcall; abstract;
    function Get_Value: Double; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sComments".</summary>
    ///<summary>A comment.</summary>
    function Get_Comments: string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sIP".</summary>
    ///<summary>The IP of the client computer.</summary>
    function Get_IP: string; virtual; stdcall; abstract;
  end;

  TCreate_MD_Action=function: TMD_Action; stdcall;

  ///<summary>Function returning a description of a log action type.</summary>
  ///<param name="ALAT">The log action type.</param>
  TLATToStr=function(const ALAT: TLog_Action_Type): string; stdcall;

  ///<summary>Function returning a description of a log action context.</summary>
  ///<param name="ALAC">The log action context.</param>
  TLACToStr=function(const ALAC: TLog_Action_Context): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_DB_Log'}
  ///<summary>Class handling the informations of an TxAPI log.</summary>
  TMD_Log=class(TNamed_Object)
  public
    ///<summary>Setter for the variable "bLog_Data_Modif".</summary>
    ///<summary>If true, modifications on Data and Objects are saved for this log.</summary>
    procedure Set_Log_Data_Modif(const ALog_Data_Modif: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bLog_Data_Modif".</summary>
    ///<summary>If true, modifications on Data and Objects are saved for this log.</summary>
    function Get_Log_Data_Modif: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bLog_Connections".</summary>
    ///<summary>If true, Connections and deconnections are saved for this log.</summary>
    procedure Set_Log_Connections(const ALog_Connections: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bLog_Connections".</summary>
    ///<summary>If true, Connections and deconnections are saved for this log.</summary>
    function Get_Log_Connections: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bLog_Structure_Modif".</summary>
    ///<summary>If true, modifications on Structure are saved for this log.</summary>
    procedure Set_Log_Structure_Modif(const ALog_Structure_Modif: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bLog_Structure_Modif".</summary>
    ///<summary>If true, modifications on Structure are saved for this log.</summary>
    function Get_Log_Structure_Modif: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bLog_Usage_Actions".</summary>
    ///<summary>If true, use actions are saved for this log.</summary>
    procedure Set_Log_Usage_Actions(const ALog_Usage_Actions: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bLog_Usage_Actions".</summary>
    ///<summary>If true, use actions are saved for this log.</summary>
    function Get_Log_Usage_Actions: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bActive".</summary>
    ///<summary>If true, this log is active.</summary>
    procedure Set_Active(const AActive: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bActive".</summary>
    ///<summary>If true, this log is active.</summary>
    function Get_Active: Boolean; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating and returning a TMD_Log object using the default constructor.</summary>
  TCreate_Log=function: TMD_Log; stdcall;
  {$ENDREGION}

  {$REGION 'U_OT_Object'}
  ///<summary>Class storing the information of an Object Type.</summary>
  TOTObject=class(TTree_Object)
  public
    procedure Set_ID_OT(const AID_OT: Integer); virtual; stdcall; abstract;
    function Get_ID_OT: Integer; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Locking'}
  TLocking_Type=(
    ltUndefined,
    ltNone,
    ltAuto,
    ltManual);

  TMD_Locking=class(TID_Object)
  public
    ///<summary>Setter for the variable "ID_Object_Owner".</summary>
    ///<summary>The identifer of the user.</summary>
    procedure Set_ID_Object_Owner(const AID_Object_Owner: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Owner".</summary>
    ///<summary>The identifer of the user.</summary>
    function Get_ID_Object_Owner: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Locked Object.</summary>
    procedure Set_ID_Object(const AID_Object: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Locked Object.</summary>
    function Get_ID_Object: Integer; virtual; stdcall; abstract;
    procedure Set_Date(const ADate: Double); virtual; stdcall; abstract;
    function Get_Date: Double; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iType".</summary>
    ///<summary>The Lock Mode (auto or manuel).</summary>
    function Get_Type: TLocking_Type; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_OT".</summary>
    ///<summary>The identifier of the object, the objects belongs to. It is needed to calculate the expiracy date.</summary>
    function Get_ID_OT: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPath_File".</summary>
    ///<summary>The path of the work file on the locking owner computer.</summary>
    procedure Set_Path_File(const APath_File: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath_File".</summary>
    ///<summary>The path of the work file on the locking owner computer.</summary>
    function Get_Path_File: string; virtual; stdcall; abstract;
    function Unlock_If_Needed: Boolean; virtual; stdcall; abstract;
    function CheckIf_User_Can_Unlock: Boolean; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sOwnerName".</summary>
    ///<summary>The owner name. It is only needed for display purpose and therefore initialized "on demand".</summary>
    function Get_OwnerName: string; virtual; stdcall; abstract;
    function Get_Remaining_Duration: Double; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Attribute'}
  TLink_Display_Mode=(
    ldmTree,
    ldmTreeMax,
    ldmList);

  ///<summary>Class storing the informations on a Attribute.</summary>
  TS_Attribute=class(TOTObject)
  public
    ///<summary>Setter for the variable "bParent_Inheritage".</summary>
    ///<summary>If true, the Attribute is used by at least one inherited Attribute (for this user).</summary>
    ///<summary>Functioning variable.</summary>
    procedure Set_Parent_Inheritage(const AParent_Inheritage: Boolean); virtual; stdcall; abstract;
    procedure Set_Under_Visibility_Control(const AUnderVisibilityControl: Boolean); virtual; stdcall; abstract;
    function Get_Under_Visibility_Control: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bTriggering_MA".</summary>
    ///<summary>If true, the attribute triggers at least one model application on data writing.</summary>
    ///<summary>Functioning variable.</summary>
    procedure Set_Triggering_MA(const ATriggering_MA: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTriggering_MA".</summary>
    ///<summary>If true, the attribute triggers at least one model application on data writing.</summary>
    ///<summary>Functioning variable.</summary>
    function Get_Triggering_MA: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute_Inherited".</summary>
    ///<summary>The identifier of the Attribute used as inheritage by the current Attribute.</summary>
    procedure Set_ID_Attribute_Inherited(const AID_Attribute_Inherited: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute_Inherited".</summary>
    ///<summary>The identifier of the Attribute used as inheritage by the current Attribute.</summary>
    function Get_ID_Attribute_Inherited: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bTraceable".</summary>
    ///<summary>If true, tracking of data modification is activated.</summary>
    procedure Set_Traceable(const ATraceable: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTraceable".</summary>
    ///<summary>If true, tracking of data modification is activated.</summary>
    function Get_Traceable: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Information".</summary>
    ///<summary>The identifier of the Information Object describing the Attribute.</summary>
    procedure Set_ID_Object_Information(const AID_Object_Information: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Information".</summary>
    ///<summary>The identifier of the Information Object describing the Attribute.</summary>
    function Get_ID_Object_Information: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Link_Type".</summary>
    ///<summary>ID_Link_Type: integer - identifier of the Link Type in case of a link or inherited Attribute.</summary>
    ///<summary>In case of an inherited Attribute, this is the identifier of the Link Type used for the inheritage (to be modified).</summary>
    procedure Set_ID_Link_Type(const AID_Link_Type: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Link_Type".</summary>
    ///<summary>ID_Link_Type: integer - identifier of the Link Type in case of a link or inherited Attribute.</summary>
    ///<summary>In case of an inherited Attribute, this is the identifier of the Link Type used for the inheritage (to be modified).</summary>
    function Get_ID_Link_Type: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Unit".</summary>
    ///<summary>The identifier of the main unit in case of a decimal Attribute.</summary>
    procedure Set_ID_Unit(const AID_Unit: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Unit".</summary>
    ///<summary>The identifier of the main unit in case of a decimal Attribute.</summary>
    function Get_ID_Unit: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_File_Type".</summary>
    ///<summary>The identifier of the File Type in case of Document Attribute.</summary>
    procedure Set_ID_File_Type(const AID_File_Type: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_File_Type".</summary>
    ///<summary>The identifier of the File Type in case of Document Attribute.</summary>
    function Get_ID_File_Type: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bList".</summary>
    ///<summary>If true, the Attribute is a list Attribute.</summary>
    procedure Set_List(const AList: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bList".</summary>
    ///<summary>If true, the Attribute is a list Attribute.</summary>
    function Get_List: Boolean; virtual; stdcall; abstract;
    procedure Set_Float_Format(const AFloatFormat: TFloatFormat); virtual; stdcall; abstract;
    function Get_Float_Format: TFloatFormat; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iPrecision".</summary>
    ///<summary>Settings for the decimal Attribute display. See FloatToStrF for more details.</summary>
    procedure Set_Precision(const APrecision: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iPrecision".</summary>
    ///<summary>Settings for the decimal Attribute display. See FloatToStrF for more details.</summary>
    function Get_Precision: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iDigits".</summary>
    ///<summary>Settings for the decimal Attribute display. See FloatToStrF for more details.</summary>
    procedure Set_Digits(const ADigits: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iDigits".</summary>
    ///<summary>Settings for the decimal Attribute display. See FloatToStrF for more details.</summary>
    function Get_Digits: Integer; virtual; stdcall; abstract;
    procedure Set_Lower_Bound(const ALowerBound: Double); virtual; stdcall; abstract;
    function Get_Lower_Bound: Double; virtual; stdcall; abstract;
    procedure Set_Upper_Bound(const AUpperBound: Double); virtual; stdcall; abstract;
    function Get_Upper_Bound: Double; virtual; stdcall; abstract;
    procedure Set_LB_Inclusive(const AInclusiveLowerBound: Boolean); virtual; stdcall; abstract;
    function Get_LB_Inclusive: Boolean; virtual; stdcall; abstract;
    procedure Set_UB_Inclusive(const AInclusiveUpperBound: Boolean); virtual; stdcall; abstract;
    function Get_UB_Inclusive: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDisplay_In_Main_Unit".</summary>
    ///<summary>If true, the data will be displayed into the main unit and not in the unit filled by the user.</summary>
    procedure Set_Display_In_Main_Unit(const ADisplay_In_Main_Unit: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDisplay_In_Main_Unit".</summary>
    ///<summary>If true, the data will be displayed into the main unit and not in the unit filled by the user.</summary>
    function Get_Display_In_Main_Unit: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bInherited".</summary>
    ///<summary>If true, the Attribute is inherited.</summary>
    procedure Set_Inherited(const AInherited: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bInherited".</summary>
    ///<summary>If true, the Attribute is inherited.</summary>
    function Get_Inherited: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Table_Type".</summary>
    ///<summary>The identifier of the Table Type in case of Table Attribute.</summary>
    procedure Set_ID_Table_Type(const AID_Table_Type: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Table_Type".</summary>
    ///<summary>The identifier of the Table Type in case of Table Attribute.</summary>
    function Get_ID_Table_Type: Integer; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "SL_ID_Unit".</summary>
    ///<summary>The list of unit identifiers of the Attribute.</summary>
    function Get_SL_ID_Unit: TStringList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bParent_Inheritage".</summary>
    ///<summary>If true, the Attribute is used by at least one inherited Attribute (for this user).</summary>
    ///<summary>Functioning variable.</summary>
    function Get_Parent_Inheritage: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDisplay_Table".</summary>
    ///<summary>If false, the Table of Table data will be hidden.</summary>
    ///<summary>If the data has no graph, the data will be completly hidden.</summary>
    procedure Set_Display_Table(const ADisplay_Table: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDisplay_Table".</summary>
    ///<summary>If false, the Table of Table data will be hidden.</summary>
    ///<summary>If the data has no graph, the data will be completly hidden.</summary>
    function Get_Display_Table: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bTranspose".</summary>
    ///<summary>If true, the Table data will be displayed vertically.</summary>
    procedure Set_Transpose(const ATranspose: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTranspose".</summary>
    ///<summary>If true, the Table data will be displayed vertically.</summary>
    function Get_Transpose: Boolean; virtual; stdcall; abstract;
    procedure Set_Display_Series_Name(const ADisplaySeriesName: Boolean); virtual; stdcall; abstract;
    function Get_Display_Series_Name: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDisplay_Indexes".</summary>
    ///<summary>If true, a row/column with the indexes will be displayed for Table Data into the read mode.</summary>
    procedure Set_Display_Indexes(const ADisplayIndexes: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDisplay_Indexes".</summary>
    ///<summary>If true, a row/column with the indexes will be displayed for Table Data into the read mode.</summary>
    function Get_Display_Indexes: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sColor".</summary>
    ///<summary>The style of the attribute</summary>
    procedure Set_Color(const AColor: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sColor".</summary>
    ///<summary>The style of the attribute</summary>
    function Get_Color: string; virtual; stdcall; abstract;
    procedure Set_Underlined(const AUnderlined: Boolean); virtual; stdcall; abstract;
    function Get_Underlined: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iLink_Display_Mode".</summary>
    ///<summary>Only for Link Attribute</summary>
    procedure Set_Link_Display_Mode(const AValue: TLink_Display_Mode); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iLink_Display_Mode".</summary>
    ///<summary>Only for Link Attribute</summary>
    function Get_Link_Display_Mode: TLink_Display_Mode; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TS_Attribute object with it default creator.</summary>
  TCreate_Attribute=function: TS_Attribute; stdcall;

  ///<summary>Procedure deleting Attributes into the database.</summary>
  ///<param name="ATD_Object">The identifier of the datatype of the Object.</param>
  ///<param name="AID_Object">The identifier of the Object.</param>
  TDelete_Attribute=procedure(const ATD_Object: Integer; const AID_Object: Integer); stdcall;
  {$ENDREGION}

  {$REGION 'U_Object_Type'}
  ///<summary>Class storing the information of an Object Type.</summary>
  TS_Object_Type=class(TTree_Object)
  public
    ///<summary>Getter for the variable "OL_Attribute".</summary>
    ///<summary>The list of TS_Attribute objects belonging to the Object Type. The list does NOT own its objects.</summary>
    function Get_OL_Attribute: TObjectList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Tab".</summary>
    ///<summary>The list of tab Attributes of the Object Type. The list does NOT own its objects.</summary>
    function Get_OL_Tab: TObjectList; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bVisible".</summary>
    ///<summary>If true, the Object Type will appear in the main tree. If not, it won't appear but will be visible if the user click on a link to this Object Type.</summary>
    procedure Set_Visible(const AVisible: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bVisible".</summary>
    ///<summary>If true, the Object Type will appear in the main tree. If not, it won't appear but will be visible if the user click on a link to this Object Type.</summary>
    function Get_Visible: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iType".</summary>
    ///<summary>The type of Object Type. See the list of "Special" Object Type.</summary>
    procedure Set_Type(const AType: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iType".</summary>
    ///<summary>The type of Object Type. See the list of "Special" Object Type.</summary>
    function Get_Type: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDistinct_Names".</summary>
    ///<summary>If true, Objects of the Object Type have distinct names.</summary>
    procedure Set_Distinct_Names(const ADistinct_Names: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDistinct_Names".</summary>
    ///<summary>If true, Objects of the Object Type have distinct names.</summary>
    function Get_Distinct_Names: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iLocking_Type".</summary>
    ///<summary>The type of object's locking.</summary>
    procedure Set_Locking_Type(const ALocking_Type: TLocking_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iLocking_Type".</summary>
    ///<summary>The type of object's locking.</summary>
    function Get_Locking_Type: TLocking_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fLocking_Duration".</summary>
    ///<summary>In case of a manual or automatic locking, the maximum locking duration (in days).</summary>
    procedure Set_Locking_Duration(const ALocking_Duration: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fLocking_Duration".</summary>
    ///<summary>In case of a manual or automatic locking, the maximum locking duration (in days).</summary>
    function Get_Locking_Duration: Double; virtual; stdcall; abstract;
    procedure Set_Shift(const AShift: Integer); virtual; stdcall; abstract;
    function Get_Shift: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDisplayResultsIntoTextSearch".</summary>
    ///<summary>If true, the Object Type will appear in the TextSearch resultats.</summary>
    procedure Set_DisplayResultsIntoTextSearch(const ADisplayResultsIntoTextSearch: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDisplayResultsIntoTextSearch".</summary>
    ///<summary>If true, the Object Type will appear in the TextSearch resultats.</summary>
    function Get_DisplayResultsIntoTextSearch: Boolean; virtual; stdcall; abstract;
    function Get_TabsCount: Integer; virtual; stdcall; abstract;
    function Get_AttributesCount: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TS_Object_Type object.</summary>
  TCreate_Object_Type=function: TS_Object_Type; stdcall;
  {$ENDREGION}

  {$REGION 'U_Object'}
  ///<summary>Class storing the informations of an TEEXMA Object.</summary>
  TS_Object=class(TOTObject)
  public
    ///<summary>Getter for the variable "fDate_Creation".</summary>
    ///<summary>The creation date of the Object.</summary>
    function Get_Date_Creation: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Owner".</summary>
    ///<summary>The identifier of the Object associated to the user who created the Object.</summary>
    procedure Set_ID_Object_Owner(const AID_Object_Owner: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Owner".</summary>
    ///<summary>The identifier of the Object associated to the user who created the Object.</summary>
    function Get_ID_Object_Owner: Integer; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Object_Data'}
  ///<summary>Class storing data belonging to an object.</summary>
  ///<summary>It also enables</summary>
  ///<summary> - to sort the data thanks to a list of attributes.</summary>
  ///<summary> - to display the texts (more or less complete) associated to those data.</summary>
  ///<summary> - to set a reference object and associate a status to each data (added/modified/removed).</summary>
  TS_Object_Data=class(TS_Object)
  public
    ///<summary>Procedure adding a TD_Data object to the various lists.</summary>
    ///<summary>Warning: this function does not raise any error if they are incoherencies between the attribute and object defined for the current object and those defined by the data.</summary>
    ///<summary>Warning: this function does not update the various text and status.</summary>
    ///<param name="AData">The data to add.</param>
    ///<param name="ACopy">If true, the data object is copied.</param>
    procedure Add_Data(const AData: TObject; const ACopy: Boolean=True); virtual; stdcall; abstract;
    ///<summary>Function writing the data of the Object.</summary>
    function Write_Data: string; virtual; stdcall; abstract;
    ///<summary>Procedure initializing the Object: it clears the lists of data and eventually prepares the arrays and list of text values.</summary>
    ///<param name="AOL_Attribute">The list of Attributes to use for the initialization.</param>
    ///<param name="AFormat_OL">If true, the lists and arrays are prepared to display the data values. This only prepares the array: the data must be then read and used to fill the arrays and lists.</param>
    procedure Reinitialize(const AOL_Attribute: TObjectList; const AFormat_OL: Boolean=True); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Data".</summary>
    ///<summary>The list of data of the Object (for the Attributes read).</summary>
    function Get_OL_Data: TObjectList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Source".</summary>
    ///<summary>The list of source of the Object (for the Attributes read).</summary>
    function Get_OL_Source: TObjectList; virtual; stdcall; abstract;
    function Get_Data_Count: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the source of a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Source(const AID_Attribute: Integer; const ASorted: Boolean=True): TObject; virtual; stdcall; abstract;
    ///<summary>Function returning the list of Data of a given Attribute.</summary>
    ///<summary>The Object must be initialized before calling this function. If not, the function raises a EObject_Data_Not_Initialized exception.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    function Get_OL_Sub_Data(const AID_Attribute: Integer): TObjectList; virtual; stdcall; abstract;
    ///<summary>Function returning the "first" data of a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data(const AID_Attribute: Integer; const ASorted: Boolean=False): TObject; virtual; stdcall; abstract;
    ///<summary>Procedure remove the Data for a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    procedure Remove_Data(const AID_Attribute: Integer); overload; virtual; stdcall; abstract;
    ///<summary>Procedure remove the Data for a given Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    procedure Remove_Data(const ATag: string); overload; virtual; stdcall; abstract;
    ///<summary>Procedure setting a value for a given numerical Attribute.</summary>
    ///<summary>Procedure removing a Data object from the various lists.</summary>
    ///<summary>Warning: this function does not raise any error if they are incoherencies between the attribute and object defined for the current object and those defined by the data.</summary>
    ///<summary>Warning: this function does not update the various text and status.</summary>
    ///<param name="AData">The data to remove.</param>
    procedure Remove_Data(const AData: TObject); overload; virtual; stdcall; abstract;
    ///<summary>The procedure implicitly assumes that the Attributes is not a list.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AValue">The value to set.</param>
    procedure Set_Data_fValue(const AID_Attribute: Integer; const AValue: Double); overload; virtual; stdcall; abstract;
    ///<summary>Procedure setting a value for a given numerical Attribute.</summary>
    ///<summary>The procedure implicitly assumes that the Attributes is not a list.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AValue">The value to set.</param>
    procedure Set_Data_fValue(const ATag: string; const AValue: Double); overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given numerical Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_fValue(const AID_Attribute: Integer; const ASorted: Boolean=False; const ADefault_Value: Double=-NAN): Double; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given numerical Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_fValue(const ATag: string; const ASorted: Boolean=False; const ADefault_Value: Double=-NAN): Double; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given numerical Attribute and raising an error if empty.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_fValue(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): Double; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given numerical Attribute and raising an error if empty.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_fValue(const ATag: string; const AMessage: string; const ASorted: Boolean=False): Double; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the integer value of a given numerical Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_iValue(const AID_Attribute: Integer; const ASorted: Boolean=False; const ADefault_Value: Integer=0): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the integer value of a given numerical Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_iValue(const ATag: string; const ASorted: Boolean=False; const ADefault_Value: Integer=0): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the integer value of a given numerical Attribute and raising an error if empty.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_iValue(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the integer value of a given numerical Attribute and raising an error if empty.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_iValue(const ATag: string; const AMessage: string; const ASorted: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Procedure setting a value for a given boolean Attribute.</summary>
    ///<summary>The procedure implicitly assumes that the Attributes is not a list.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AValue">The value to set.</param>
    procedure Set_Data_bValue(const AID_Attribute: Integer; const AValue: Boolean); overload; virtual; stdcall; abstract;
    ///<summary>Procedure setting a value for a given boolean Attribute.</summary>
    ///<summary>The procedure implicitly assumes that the Attributes is not a list.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AValue">The value to set.</param>
    procedure Set_Data_bValue(const ATag: string; const AValue: Boolean); overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given boolean Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_bValue(const AID_Attribute: Integer; const ASorted: Boolean=False; const ADefault_Value: Boolean=False): Boolean; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given boolean Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_bValue(const ATag: string; const ASorted: Boolean=False; const ADefault_Value: Boolean=False): Boolean; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given boolean Attribute and raising an error if empty.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_bValue(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): Boolean; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given boolean Attribute and raising an error if empty.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_bValue(const ATag: string; const AMessage: string; const ASorted: Boolean=False): Boolean; overload; virtual; stdcall; abstract;
    ///<summary>Procedure setting a value for a given string Attribute.</summary>
    ///<summary>The procedure implicitly assumes that the Attributes is not a list.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AValue">The value to set.</param>
    procedure Set_Data_sValue(const AID_Attribute: Integer; const AValue: string); overload; virtual; stdcall; abstract;
    ///<summary>Procedure setting a value for a given string Attribute.</summary>
    ///<summary>The procedure implicitly assumes that the Attributes is not a list.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AValue">The value to set.</param>
    procedure Set_Data_sValue(const ATag: string; const AValue: string); overload; virtual; stdcall; abstract;
    ///<summary>Function returning the text value of a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_sValue(const AID_Attribute: Integer; const ASorted: Boolean=False; const ADefault_Value: string=''): string; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the text value of a given Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_sValue(const ATag: string; const ASorted: Boolean=False; const ADefault_Value: string=''): string; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the text value of a given Attribute and raising an error if empty.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_sValue(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): string; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the text value of a given Attribute and raising an error if empty.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_sValue(const ATag: string; const AMessage: string; const ASorted: Boolean=False): string; overload; virtual; stdcall; abstract;
    ///<summary>Function setting the value of a given Link Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASL_Values">The list of identifiers of the Linked Objects.</param>
    procedure Set_Data_Link_Value(const AID_Attribute: Integer; const ASL_Values: TStringList); overload; virtual; stdcall; abstract;
    ///<summary>Function setting the value of a given Link Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AValue">The list of identifiers of the Linked Objects, separated by a given value separator.</param>
    ///<param name="ASeparator_Used">The separator used between the identifiers.</param>
    procedure Set_Data_Link_Value(const AID_Attribute: Integer; const AValue: string; const ASeparator_Used: string='<v>'); overload; virtual; stdcall; abstract;
    ///<summary>Function setting the value of a given Link Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASL_Values">The list of identifiers of the Linked Objects.</param>
    procedure Set_Data_Link_Value(const ATag: string; const ASL_Values: TStringList); overload; virtual; stdcall; abstract;
    ///<summary>Function setting the value of a given Link Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AValue">The list of identifiers of the Linked Objects, separated by a given value separator.</param>
    ///<param name="ASeparator_Used">The separator used between the identifiers.</param>
    procedure Set_Data_Link_Value(const ATag: string; const AValue: string; const ASeparator_Used: string='<v>'); overload; virtual; stdcall; abstract;
    ///<summary>Function setting the value of a given Link Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AValue">The identifier of the linked object.</param>
    procedure Set_Data_Link_Value(const ATag: string; const AValue: Integer); overload; virtual; stdcall; abstract;
    ///<summary>Function setting the value of a given Link Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AValue">The identifier of the linked object.</param>
    procedure Set_Data_Link_Value(const AID_Attribute: Integer; const AValue: Integer); overload; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the linked Object of a given Link Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_ID_Object_Lkd(const AID_Attribute: Integer; const ASorted: Boolean=False; const ADefault_Value: Integer=0): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the linked Object of a given Link Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="ADefault_Value">A default value to return in case of no data found.</param>
    function Get_Data_ID_Object_Lkd(const ATag: string; const ASorted: Boolean=False; const ADefault_Value: Integer=0): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the linked Object of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_ID_Object_Lkd(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the linked Object of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_ID_Object_Lkd(const ATag: string; const AMessage: string; const ASorted: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the list of linked Objects of a given Link Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_OL_Object_Lkd(const AID_Attribute: Integer; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the list of linked Objects of a given Link Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_OL_Object_Lkd(const ATag: string; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the list of linked Objects of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_OL_Object_Lkd(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the list of linked Objects of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_OL_Object_Lkd(const ATag: string; const AMessage: string; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the the list of linked Objects identifiers of a given Link Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_SL_ID_Object_Lkd(const AID_Attribute: Integer; const ASorted: Boolean=False): TStringList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the the list of linked Objects identifiers of a given Link Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_SL_ID_Object_Lkd(const ATag: string; const ASorted: Boolean=False): TStringList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the the list of linked Objects identifiers of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_SL_ID_Object_Lkd(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): TStringList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the the list of linked Objects identifiers of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_SL_ID_Object_Lkd(const ATag: string; const AMessage: string; const ASorted: Boolean=False): TStringList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the linked Object of a given Link Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_Object_Lkd(const AID_Attribute: Integer; const ASorted: Boolean=False): TS_Object_Data; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the linked Object of a given Link Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_Object_Lkd(const ATag: string; const ASorted: Boolean=False): TS_Object_Data; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the linked Object of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_Object_Lkd(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): TS_Object_Data; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the linked Object of a given Link Attribute and raising an error if not found.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<returns>The function returns a nil value if no data could be found.</returns>
    function Get_Data_Object_Lkd(const ATag: string; const AMessage: string; const ASorted: Boolean=False): TS_Object_Data; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the archived file identifier of a given file Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="AID_Default_Archived_File">The default value to return if no data could be found.</param>
    function Get_Data_ID_Archived_File(const AID_Attribute: Integer; const ASorted: Boolean=False; const AID_Default_Archived_File: Integer=0): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the archived file identifier of a given file Attribute and raising an error if not found.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_ID_Archived_File(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the archived file identifier of a given file Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    ///<param name="AID_Default_Archived_File">The default value to return if no data could be found.</param>
    function Get_Data_ID_Archived_File(const ATag: string; const ASorted: Boolean=False; const AID_Default_Archived_File: Integer=0): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the archived file identifier of a given file Attribute and raising an error if not found.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_ID_Archived_File(const ATag: string; const AMessage: string; const ASorted: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the list of series of a given table Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_OL_Series(const AID_Attribute: Integer; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the archived file identifier of a given file Attribute and raising an error if not found.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_OL_Series(const AID_Attribute: Integer; const AMessage: string; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the archived file identifier of a given file Attribute.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_OL_Series(const ATag: string; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the archived file identifier of a given file Attribute and raising an error if not found.</summary>
    ///<param name="ATag">The tag of the Attribute.</param>
    ///<param name="AMessage">The error message.</param>
    ///<param name="ASorted">If true and in case of an unitialized object, this allows to speed the search.</param>
    function Get_Data_OL_Series(const ATag: string; const AMessage: string; const ASorted: Boolean=False): TObjectList; overload; virtual; stdcall; abstract;
    ///<summary>Procedure setting the texts for a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="AShort_Text">The short text.</param>
    ///<param name="ALong_Text">The long text.</param>
    ///<param name="AComplete_Text">The complete text.</param>
    procedure Set_Data_Text(const AID_Attribute: Integer; const AShort_Text: string; const ALong_Text: string; const AComplete_Text: string); virtual; stdcall; abstract;
    ///<summary>Function returning the short text for a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    function Get_Data_Short_Text(const AID_Attribute: Integer): string; virtual; stdcall; abstract;
    ///<summary>Function returning the long text for a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    function Get_Data_Long_Text(const AID_Attribute: Integer): string; virtual; stdcall; abstract;
    ///<summary>Function returning the complete text for a given Attribute.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    function Get_Data_Complete_Text(const AID_Attribute: Integer): string; virtual; stdcall; abstract;
    ///<summary>Procedure defining the Attributes status thanks to a given reference Object.</summary>
    ///<summary>It allows to say "Compared to the reference object, this attribute has not the same data" or "this Attribute has its data deleted".</summary>
    ///<param name="AObject_Reference">The reference object.</param>
    procedure Define_Status(const AObject_Reference: TS_Object_Data); virtual; stdcall; abstract;
    ///<summary>Function returning the status for a given Attribute (in comparison with the reference Object).</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    function Get_Status(const AID_Attribute: Integer): TDB_Action; virtual; stdcall; abstract;
    function CreateOlLeafData(const ASlIdAttribute: TStringList): TObjectList; overload; virtual; stdcall; abstract;
    function CreateOlLeafData(const AAttributesTags: string): TObjectList; overload; virtual; stdcall; abstract;
  end;

  TCreate_Object_Data=function: TS_Object_Data; stdcall;

  ///<summary>Procedure reading the data of a list of TS_Object_Data objects and a list of Attributes.</summary>
  ///<param name="AOL_Object_Data">The list of objects to update.</param>
  ///<param name="AOL_Attribute">The list of Attributes.</param>
  ///<param name="ARead_Object_Lkd_Names">If true, linked objects names will be read. This action slowers the function.</param>
  ///<param name="AARM">The associtivity reading mode (right links,...).</param>
  ///<param name="ATable">If not empty, the preselection table is used (and not created by the function).</param>
  TUpdate_OL_Object_Data=procedure(const AOL_Object_Data: TObjectList; const AOL_Attribute: TObjectList; const ARead_Object_Lkd_Names: Boolean; const AARM: TAssociativity_Reading_Mode; const ATable: string=''); stdcall;
  {$ENDREGION}

  {$REGION 'U_Path'}
  ///<summary>Enumeration of the objects pathes reading modes.</summary>
  TPath_Read_Mode=(
    ///The object and its children objects are read.
    prmFull_Branch,
    ///The object and its root objects are read.
    prmPath_Only,
    ///The object, its roots objects and its direct children objects are read.
    prmPath_and_Direct_Children);

  ///<summary>Class handling the path to a given Object.</summary>
  TPath=class(TObject)
  public
    function Get_Arr_ID: PArr_Integer; virtual; stdcall; abstract;
    function Get_Index(const AIdObject: Integer): Integer; virtual; stdcall; abstract;
    function Check_Kinship(const AIdObject: Integer; const AIdSupposedParent: Integer; out AIsChildOf: TAdvanced_Boolean): Boolean; virtual; stdcall; abstract;
    function IsSame(const APath: TPath): Boolean; virtual; stdcall; abstract;
    function IsRelevant(const APath: TPath): Boolean; virtual; stdcall; abstract;
    function Contains(const APath: TPath): Boolean; virtual; stdcall; abstract;
  end;

  TCreate_OL_Path=function(const ASlIdObject: TStringList): TObjectList; stdcall;

  ///<summary>function creating a TPath object for a given object.</summary>
  ///<param name="AIdObject">the identifier of the Object.</param>
  TCreate_Path=function(const AIdObject: Integer): TPath; stdcall;

  TCreate_Path_From_IDs=function(const AIDsObjects: string): TPath; stdcall;
  {$ENDREGION}

  {$REGION 'U_Reverse_Path'}
  ///<summary>Class handling the reverses pathes of a given Object: in business view, an object can be present many times. This class allows to handling theses numerous pathes.</summary>
  TReverse_Path=class(TID_Object)
  public
    ///<summary>Getter for the variable "OL_Reverse_Path".</summary>
    ///<summary>List of the reverse paths of the Object.</summary>
    function Get_OL_Reverse_Path: TObjectList; virtual; stdcall; abstract;
    procedure Clear; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Bv_Object'}
  ///<summary>Class containing the informations of an object belonging to a business view.</summary>
  ///<summary>An object belonging to a business view is not only defined by its identifier but also by the manner it was accessed (ie the level of the Attribute Set).</summary>
  TBV_Object=class(TS_Object)
  public
    procedure SetIdAttributesSet(const AIdAttributesSet: Integer); virtual; stdcall; abstract;
    function GetIdAttributesSet: Integer; virtual; stdcall; abstract;
    procedure SetIdLevel(const AIdAttributesSetLevel: Integer); virtual; stdcall; abstract;
    function GetIdLevel: Integer; virtual; stdcall; abstract;
    function HasObjectsToDisplay: Boolean; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Structure'}
  ///<summary>Deprecated: do not use.</summary>
  TObjectKinship=(
    okChild,
    okSibling,
    okParent);

  ///<summary>Listing of link reading modes (probably for the array view).</summary>
  TReading_Link_Mode=(
    ///None of the linked Objects names are read (very fast but very poor ^^).
    rlmNone,
    ///All of the linked Objects names are read (may be slow for long list of links).
    rlmAll,
    ///Only the first linked Object name is read. This allow to show to the user that the table cell is not empty.
    rlmFirst);

  ///<summary>Deprecated: do not use.</summary>
  TTrash_Mode=(
    tmNone,
    tmInTrash,
    tmOutTrash);

  ///<summary>Procedure updating the bFolder value of a given Object.</summary>
  ///<param name="AIdObjectType">The identifier of the Object's Object Type.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AFolder">If true, the Object is turned into a folder. Otherwise, the Object is turned into a standard Object.</param>
  TSet_Object_Folder=procedure(const AIdObjectType: Integer; const AIdObject: Integer; const AFolder: Boolean); stdcall;

  ///<summary>Function returning the right of the current user on a given object.</summary>
  TGetObjectRight=function(const AIdObject: Integer): TDB_Right; stdcall;

  ///<summary>Function returning the deepness of an object (ie the number of parents, grand-parents, aso).</summary>
  ///<summary>0 means the Object is at the root of the tree.</summary>
  ///<param name="AIdObject">The identifier of the Object.</param>
  TGet_Object_Deepness=function(const AIdObject: Integer): Integer; stdcall;

  ///<summary>Function returning the hint of a given Object.</summary>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<returns>The hint text. The function returns an empty string if the Object was not found.</returns>
  TGet_Object_Hint=function(const AIdObject: Integer): string; stdcall;

  ///<summary>Function returning the identifier of the Object Type of a given Object.</summary>
  ///<param name="AIdObject">identifier of the object.</param>
  TGet_Object_ID_OT=function(const AIdObject: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of the first object found thanks to its name.</summary>
  ///<param name="AName">The name of the searched Object.</param>
  ///<param name="AIdObjectType">The identifier of the Object Type of the searched object.</param>
  ///<param name="AIdParent">The identifier of the parent object.</param>
  TGet_ID_Object_From_Name=function(const AName: string; const AIdObjectType: Integer; const AIdParent: Integer=-1): Integer; stdcall;

  ///<summary>Function returning the number of children of a given object or Object Type.</summary>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AIdObjectType">The identifier of the Object Type. This input is needed if the parent object is the trash.</param>
  ///<param name="ARecursive">If true, the function returns the whole branch count.</param>
  ///<param name="AInclude_Folders">If false, folders are excluded from the count.</param>
  TGet_Object_Nb_Children=function(const AIdObject: Integer; const AIdObjectType: Integer; const ARecursive: Boolean=False; const AInclude_Folders: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a list of TS_Object Objects from a parent.</summary>
  ///<param name="AIdObjectType">The identifier of the Object Type. Not necessary if a parent identifier different from 0 is sent.</param>
  ///<param name="AIdParent">The identifier of the parent Object.</param>
  ///<param name="ARecursivity">If true, the whole branch will be read.</param>
  ///<param name="AIncludeFolders">If false, the preselection will be filtered.</param>
  ///<param name="ARemoveTrashedObjects">If true, trashed objects will be removed.</param>
  ///<param name="ADataType">The class of the objects to create.</param>
  ///<returns>The list contains TS_Object objects or derivated objects.</returns>
  TCreate_OL_Object=function(const AIdObjectType: Integer; const AIdParent: Integer; const ARecursivity: Boolean=False; const AIncludeFolders: Boolean=False; const ARemoveTrashedObjects: Boolean=True; const ADataType: Integer=-3): TObjectList; stdcall;

  ///<summary>Function returning a list of TS_Object Oobjects from a given list of object Types and parents. Only the objects of the first level will be read. Folders are read.</summary>
  ///<param name="ASlIdParent">The list of parent identifiers.</param>
  ///&lt;<param name="ASlIdObjectType">The list of object Type identifiers.</param>
  ///<param name="ADataType">The class of the objects to create.</param>
  ///<returns>The list contains TS_Object objects or derivated objects.</returns>
  TCreate_OL_Object_Link_Form=function(const ASlIdParent: TStringList; const ASlIdObjectType: TStringList; const ADataType: Integer=-3): TObjectList; stdcall;

  ///<summary>Fonction permettant de savoir si une Caracteristique est parente d'un heritage. Elle permet aussi de recuperer la liste des PEs Heritees.</summary>
  ///<summary>Utilisee uniquement dans la version web. A voir donc.</summary>
  TGet_Parent_Inheritage=function(AOL_Attributes_Complete: TObjectList; AID_Link_Type: Integer; AOL_Inherited_Attributes: TObjectList=nil; AExtract_Atttibutes: Boolean=False): Boolean; stdcall;

  ///<summary>Function returning a list of objects tree sorted from a given preselection. The function can add the parent objects to the result list if desired.</summary>
  ///<param name="ASL_ID_Object">The list of object's identifiers.</param>
  ///<param name="AAdd_Parents">If true, parents objects are added to the list (even if not present in the preselection).</param>
  ///<param name="ATD_Object">The data type of the objects to create.</param>
  TCreate_OL_Object_Tree_Sorted_From_SL_ID=function(const ASL_ID_Object: TStringList; const AAdd_Parents: Boolean=False; const ATD_Object: Integer=-3): TObjectList; stdcall;

  ///<summary>Function creating a list of Objects tree sorted. The function can add the parent objects to the result list if desired.</summary>
  ///<param name="AOlObject">The list containing the objects to be sorted.</param>
  ///<param name="AAddParents">If true, parents objects are added to the list (even if not present in the list sent as parameter). The parents objects added are of the same class as their children objects (TD_Object_Data for example).</param>
  ///<returns>The objects returned are copies of the objects sent as parameter.</returns>
  TCreate_OL_Object_Tree_Sorted=function(AOlObject: TObjectList; AAddParents: Boolean=False): TObjectList; stdcall;

  ///<summary>Function returning a list of Object's identifier from a parent object or at the root of the Object Type.</summary>
  ///<param name="AIdObjectType">The identifier of the Object Type. Not necessary if a parent identifier different from 0 is sent.</param>
  ///<param name="AIdParent">The identifier of the parent Object.</param>
  ///<param name="ARecursivity">If true, the whole branch will be read.</param>
  ///<param name="AIncludeFolders">If false, the preselection will be filtered.</param>
  ///<param name="AHandleRights">If true, rights are taken into account and only objects visible by the active user are read.</param>
  TCreate_SL_ID_Object=function(const AIdObjectType: Integer; const AIdParent: Integer; const ARecursivity: Boolean=False; const AIncludeFolders: Boolean=False; const AHandleRights: Boolean=True): TStringList; stdcall;

  ///<summary>Function returning a list of TS_Object Objects from a given preselection of identifiers.</summary>
  ///<param name="ASlIdObject">the list of (string) identifiers.</param>
  ///<param name="ASortType">The ordering type.</param>
  ///<param name="ADataType">the class of the objects to create.</param>
  ///<param name="ARespectRights">If false, rights are ignored.</param>
  ///<returns>The result list contains TS_Object objects or derivated objects.</returns>
  TCreate_OL_Object_From_Preselection=function(const ASlIdObject: TStringList; const ASortType: TObject_Ordering_Type=ootOrder_Ascending; const ADataType: Integer=-3; const ARespectRights: Boolean=True): TObjectList; stdcall;

  ///<summary>Function creating and returning a list of Objects to display into a link form filtered by another link, for a given object. The objects are obtained by concatenating the list of objects already checked and the list of object linked to the object of the filtering link Attribute, through an Attribute set. This list is therefore dependant of the object displayed.</summary>
  ///<param name="AIdObject">the identifier of the Object.</param>
  ///<param name="AID_Attribute_Filtered">the identifier of the Attribute to filter.</param>
  ///<param name="ASL_ID_Object_Checked">The list of object checked into the filtering link.</param>
  ///<param name="ASL_ID_Object_Filtering">The list of objects checked into the filtering link. If nil, the list is read from the database.</param>
  TCreate_OL_Object_Link_Form_Filtered=function(const AIdObject: Integer; const AID_Attribute_Filtered: Integer; const ASL_ID_Object_Checked: TStringList; const ASL_ID_Object_Filtering: TStringList=nil): TObjectList; stdcall;

  ///<summary>Function returning the identifier of the parent Object of a given Object.</summary>
  ///<param name="AIdObject">The identifier of the object.</param>
  TGet_Object_ID_Parent=function(const AIdObject: Integer): Integer; stdcall;

  ///<summary>Function creating an object into the database. It handles the ordering, the naming rules, the model applications.</summary>
  ///<param name="AName_Proposed">the proposed name of the object. Use result.Get_Name to know the real name.</param>
  ///<param name="AIdParent">the identifier of the parent object. 0 or less means "at root".</param>
  ///<param name="AIdObjectType">the identifier of the Object Type.</param>
  ///<param name="AID_Next_Sibling">= -1 - the identifier of the next sibling object. 0 or less means "at the end of the branch".</param>
  ///<param name="AFolder">= false - if true, the object will be considered as a folder.</param>
  ///<param name="AOrder">=-1 - the order. If unknown, do not fill.</param>
  ///<param name="ATags">= '', for standart Object, do not fill.</param>
  ///<param name="ATD_Object">= C_TD_Obj, for standart Object.</param>
  ///<param name="ATrigger_MA">If true, model applications triggerring on Object Creation are activated. If not, they are disabled (usefull for TxAPI internal use).</param>
  TCreate_Object_In_DB=function(AName_Proposed: string; AIdParent: Integer; AIdObjectType: Integer; AID_Next_Sibling: Integer=0; AFolder: Boolean=False; AOrder: Integer=-1; ATags: string=''; ATrigger_MA: Boolean=True; ATD_Object: Integer=-3): TS_Object; stdcall;

  ///<summary>Procedure sorting the Objects of a given Object Type by ascending names. It preserve the folders architecture.</summary>
  TSort_Objects_in_DB=procedure(const AIdObjectType: Integer; const AIdParent: Integer; const AAscending_Order: Boolean); stdcall;

  ///<summary>Procedure moving a given object.</summary>
  ///<summary>Do not use.</summary>
  TMove_Object=procedure(const AIdObject: Integer; const AIdObjectType: Integer; const AIdOldParent: Integer; const AIdNewParent: Integer; const AIdNewNextSibling: Integer; const AMode: TObjectKinship; const ATrashMode: TTrash_Mode=tmNone; const ATriggerModelApplications: Boolean=True); stdcall;

  ///<summary>Function returning the list of duplicable and not duplicable Attributes.</summary>
  ///<param name="AIdObject_Type">The identifier of the Object Type.</param>
  ///<param name="AOL_Duplicable_Attribute">A list to fill with the duplicable Attributes.</param>
  ///<param name="AOL_Attribute_Forbidden">A list to fill with the non duplicable Attributes. Inherited Attributes, Group Attributes are not added to this list.</param>
  ///<param name="AWarning">A message warning in case of non duplicable Attributes.</param>
  ///<param name="AHandleRights">If true, read-only Attributes are not considered as duplicable.</param>
  TInitialize_Standard_Duplication=procedure(const AIdObject_Type: Integer; out AOL_Duplicable_Attribute: TObjectList; out AOL_Attribute_Forbidden: TObjectList; out AWarning: string; const AHandleRights: Boolean=True); stdcall;

  ///<summary>Procedure filling a Object using a given Advanced Creation.</summary>
  ///<param name="AIdObject">The identifier of the Object to fill.</param>
  ///<param name="AID_Advanced_Creation_Settings">The identifier of the Advanced Creation Settings.</param>
  TFill_Object_From_Advanced_Creation_Settings=procedure(const AIdObject: Integer; const AID_Advanced_Creation_Settings: Integer); stdcall;

  ///<summary>Procedure filling a Object using a given Advanced Duplication.</summary>
  ///<param name="AIdObjectToDuplicate">The identifier of the Object used for the duplication.</param>
  ///<param name="AIdObject_Duplicated">The identifier of the Object to fill.</param>
  ///<param name="AID_Duplication_Settings">The identifier of the advanced duplication.</param>
  TFill_Object_From_Duplication_Settings=function(const AIdObjectToDuplicate: Integer; const AIdObject_Duplicated: Integer; const AID_Duplication_Settings: Integer): string; stdcall;

  ///<summary>Function creating a duplicated Object using given Duplication settings.</summary>
  ///<param name="AIdObjectToDuplicate">The identifier of the Object to duplicate.</param>
  ///<param name="AID_Duplication_Settings">The identifier of the Duplication Settings.</param>
  ///<param name="ATD_Object">The data type of the class of object to return.</param>
  TCreate_Object_From_Duplication_Settings=function(const AIdObjectToDuplicate: Integer; const AID_Duplication_Settings: Integer; const ATD_Object: Integer=-3): TS_Object; stdcall;

  ///<summary>Function duplicating a given object into the database and returning the object created.</summary>
  ///<summary>The function uses the standard duplication: it DOES respect the user's rights.</summary>
  ///<param name="AIdObject">The identifier of the object to duplicate.</param>
  ///<param name="AOL_Attribute_To_Duplicate">The list of Attributes to duplicate.</param>
  ///<param name="ATD_Object">The type of object to create and return.</param>
  TCreate_Object_Duplicated=function(const AIdObject: Integer; const AOL_Attribute_To_Duplicate: TObjectList; const ATD_Object: Integer=-3): TS_Object; stdcall;

  ///<summary>Function returning the icon index of a given Object.</summary>
  ///<param name="AIdObject">The identifier of the object.</param>
  TGet_Object_Icon=function(const AIdObject: Integer): Integer; stdcall;

  ///<summary>Function extending the "Get_Object_Name" function. It handles the trash and root identifiers. It can search the name into a given list and return a default value if no object is found.</summary>
  ///<param name="AIdObject">The identifier of the object.</param>
  ///<param name="AOlObject">A list of Objects to search into. If nil, the search is directly made into the database.</param>
  ///<param name="ADefault">A default value in case no object is found.</param>
  TGet_Object_Name_Extended=function(const AIdObject: Integer; const AOlObject: TObjectList=nil; const ADefault: string=''): string; stdcall;

  ///<summary>Function returning the name of a given Object thanks to its identifier.</summary>
  ///<param name="AIdObject">The identifier of the object.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Object_Name=function(const AIdObject: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Procedure restauring a given Object.</summary>
  ///<summary>Do not use.</summary>
  ///<param name="AIdObject">The object ID</param>
  ///<param name="AIdObjectType">The ID_OT concerned.</param>
  ///<param name="AName">The object name</param>
  ///<param name="AID_New_Parent">The ID object parent</param>
  ///<param name="AID_New_Prev_Sibling">The previous cibling ID object</param>
  ///<param name="AMode">The affilitation mode</param>
  TRestore_Object=function(const AIdObject: Integer; const AIdObjectType: Integer; const AName: string; const AID_New_Parent: Integer; const AID_New_Prev_Sibling: Integer; const AMode: TObjectKinship): string; stdcall;

  ///<summary>Procedure empty the trahs of a given Object Type.</summary>
  ///<param name="AIdObjectType">The identifier of the Object Type of the trash to empty. If equals to 0, the trashes of all Objects Types are emptied.</param>
  TEmpty_Trash=procedure(const AIdObjectType: Integer=0); stdcall;

  ///<summary>Function returning a list of Object's identifiers from a list of names.</summary>
  ///<param name="AIdObjectType">The identifier of the Object Type.</param>
  ///<param name="ASlName">A list of object names.</param>
  TCreate_SL_ID_Object_From_Names=function(const AIdObjectType: Integer; const ASlName: TStringList): TStringList; stdcall;

  ///<summary>Procedure allowing to delete a given list of Objects.</summary>
  ///<summary>Do not use.</summary>
  TDelete_Objects=procedure(const ASlIdObject: TStringList; const AGoToTrash: Boolean; const AIdObjectType: Integer=-1); stdcall;

  ///<summary>Procedure deleting an Object and its linked Objects thanks to a Deletion Settings.</summary>
  ///<param name="ASL_ID_Object">The list of objects identifiers to delete.</param>
  ///<param name="AID_Deletion_Settings">the identifier of the deletion settings.</param>
  TDelete_Objects_From_Deletion_Settings=procedure(const ASL_ID_Object: TStringList; const AID_Deletion_Settings: Integer); stdcall;

  ///<summary>Procedure deleting Object(s) into the database. The function is recursive and delete the children Objects.</summary>
  ///<param name="AIdObject">The identifier of the object responsible of the deletion.</param>
  ///<param name="ATD_Object">The data type of the object responsible of the deletion.</param>
  ///<param name="AHandle_Sources">If true, the function reads and delete the objects related to the sources of the data belonging to the object(s).</param>
  ///<param name="AHandle_Associativities">If true, the function reads and delete the associative object related to the object to delete.</param>
  TDelete_Object=procedure(const AIdObject: Integer; const ATD_Object: Integer; const AHandle_Sources: Boolean=True; const AHandle_Associativities: Boolean=True); stdcall;

  TAttributeTypeToShortCodedStr=function(const ADataType: Integer): string; stdcall;

  ///<summary>Function returning a coded string described the full type of a given Attribute.</summary>
  TAttributeTypeToStr=function(const AAttribute: TS_Attribute): string; stdcall;

  ///<summary>Function returning the name of an Attribute Data Type.</summary>
  ///<param name="AAttribute">The Attribute.</param>
  ///<param name="AOL_Attribute">A complete list of Attributes. If nil, the loaded list is used.</param>
  ///<param name="AOL_Link_Type">A complete list of Link Types.If nil, the loaded list is used.</param>
  TGet_AttributeTypeLabel=function(const AAttribute: TS_Attribute; const AOL_Attribute: TObjectList=nil; const AOL_Link_Type: TObjectList=nil): string; stdcall;

  ///<summary>Function returning true if a given Object is a folder.</summary>
  ///<param name="AIdObject">The identifier of the object.</param>
  TGet_Object_Folder=function(const AIdObject: Integer): Boolean; stdcall;

  ///<summary>Function returning a list of Object's identifiers without data for a given Attribute.</summary>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  TCreate_SL_ID_Object_Without_Data=function(const AID_Attribute: Integer): TStringList; stdcall;

  ///<summary>Function returning true if the Object owns at least one data.</summary>
  ///<param name="AIdObject">The identifier of the Object.</param>
  THasObjectData=function(const AIdObject: Integer): Boolean; stdcall;

  ///<summary>Function returning true if a given Object exists. The function may also raise an error if desired.</summary>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AIgnore_Rights">If true, rights are ignored.</param>
  ///<param name="ARaise_Error">If true, the function raises an EObject_Not_Found error in case the object is not found.</param>
  ///<param name="AName">The name of the object supposed to exist. It is only used in the error message.</param>
  TCheck_Object_Existence=function(const AIdObject: Integer; const AIgnore_Rights: Boolean=True; const ARaise_Error: Boolean=False; const AName: string=''): Boolean; stdcall;

  ///<summary>Deprecated: do not use.</summary>
  TCreer_Instance_Erreur_Parente_Modifiee=function(AID_E: Integer): EObject_Parent_Modified; stdcall;

  ///<summary>Function returning the path (a string) of an object : "Root Parent\..\Parent\Object".</summary>
  ///<param name="AIdObject">The identifier of the object</param>
  ///<param name="AOlObject">The list of object (containing the parent objects). If nil, the function reads the parent from the database. WARNING: the list is assumed be sorted per ID ascending (use Sort_OL).</param>
  ///<param name="ASeparator">The token separator.</param>
  TGet_Object_sPath=function(const AIdObject: Integer; const ASeparator: string; const AOlObject: TObjectList=nil): string; stdcall;

  ///<summary>Base procedure for all Objects massive readings. It creates a TObjectList of TS_Object objects (or derivated objects) from a preselection table.</summary>
  ///<param name="ATable">The name of the preselection table.</param>
  ///<param name="AIncludeFolders">If false, the preselection will be filtered.</param>
  ///<param name="ASortType">The ordering type.</param>
  ///<param name="ADataType">The class of the objects to create.</param>
  ///<param name="ARespectRights">If false, rights are ignored.</param>
  ///<returns>The result list contains TS_Object objects (or derivated objects).</returns>
  TCreate_OL_Object_From_Table=function(const ATable: string; const AIncludeFolders: Boolean=False; const ASortType: TObject_Ordering_Type=ootOrder_Ascending; const ADataType: Integer=-3; const ARespectRights: Boolean=True): TObjectList; stdcall;

  ///<summary>Function returning true if a given Object exists and is not trashed. The function may also raise an error if desired.</summary>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AIgnore_Rights">If true, rights are ignored.</param>
  ///<param name="ARaise_Error">If true, the function raises an EObject_Not_Found error in case the object is not found.</param>
  ///<param name="AName">The name of the object supposed to exist. It is only used in the error message.</param>
  TCheck_Object_ExistenceExt=function(const AIdObject: Integer; const AIgnore_Rights: Boolean=True; const ARaise_Error: Boolean=False; const AName: string=''): Boolean; stdcall;

  ///<summary>Function writing a new object into the database and returning its identifier.</summary>
  ///<param name="AIdObjectType">The identifier of the Object Type of the Object.</param>
  ///<param name="AName">The name of the Object.</param>
  ///<param name="AIdParent">The identifier of the parent object of the object. If nul, the Object is created at the root of the Object Type.</param>
  ///<param name="AID_Next_Sibling">The identifier of the next sibling Object. if nil, the Object is placed at the last position of its branch.</param>
  ///<param name="AFolder">If true, the object is created is a simple folder and cannot contain data.</param>
  TWrite_New_Object=function(const AIdObjectType: Integer; const AName: string; const AIdParent: Integer=0; const AFolder: Boolean=False; const AID_Next_Sibling: Integer=0): Integer; stdcall;

  ///<summary>Function renaming an Object into the database. THe function returns the name really written into the database (which might be different from the proposed name).</summary>
  ///<param name="AName">The new name of the object.</param>
  ///<param name="AIdObjectType">The identifier of the Object Type of the Object.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ARaiseErrors">If false, some errors will be treated directly into the function.</param>
  ///<param name="AOldName">If known, the previous name of the Object.</param>
  TRename_Object=function(const AName: string; const AIdObjectType: Integer; const AIdObject: Integer; const ARaiseErrors: Boolean; const AOldName: string=''): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_Attribute_Set_Level'}
  ///<summary>Listing of the different type of levels.</summary>
  TLevel_Type=(
    ///In case of a level belonging to an Advanced Duplication: the data of the Attribute are duplicated.
    ltDuplicate_Data,
    ///In case of a level belonging to an Advanced Duplication or an Advanced Creation: the data of the Attribute are to be modified (and therefore displayed in a form).
    ltModify_Data,
    ///In case of a level belonging to an Advanced Duplication and a link Attribute: the linked objects are to be duplicated.
    ltDuplicate_Lkd_Objects,
    ///In case of an Advanced Duplication (versioning) and a link Attribute: the existing linked Object must be replaced by the Object used for the duplication.
    ltReplace_Lkd_Object,
    ///In case of an Advanced Duplication (versionning) and a link Attribute: the object used for the duplication must be added to the list of linked objects.
    ltAdd_Duplicating_Object_To_Lnk,
    ///In case of an Advanced Creation or an Advanced Duplication, the Attribute must be filled with a constant value (defined into an xml format).
    ltDefined_Value,
    ///In case of an Advanced Creation or an Advanced Duplication, the Date Attribute must be filled with the current date.
    ltCurrent_Date,
    ///In case of an Advanced creation or an Advanced Duplication, the link Attribute must be filled with the object associated to the current user.
    ltActive_User);

  ///<summary>A list of TLevel_Type values.</summary>
  TLevel_Types=set of TLevel_Type;

  ///<summary>Class containing the settings of an attribute set's level.</summary>
  TS_Attribute_Set_Level=class(TTree_Object)
  public
    procedure Set_ID_Attribute_Set(const AID_Attribute_Set: Integer); virtual; stdcall; abstract;
    function Get_ID_Attribute_Set: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the attribute of the level.</summary>
    procedure Set_ID_Attribute(const AID_Attribute: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the attribute of the level.</summary>
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iType".</summary>
    ///<summary>The type of duplication of a given attribute when the Attribute Set is used as a Duplication Setting.</summary>
    procedure Set_Type(const AType: TLevel_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iType".</summary>
    ///<summary>The type of duplication of a given attribute when the Attribute Set is used as a Duplication Setting.</summary>
    function Get_Type: TLevel_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iCol".</summary>
    ///<summary>The column where to put the Attribute in case the Attribute Set is used for exportation.</summary>
    procedure Set_Col(const ACol: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iCol".</summary>
    ///<summary>The column where to put the Attribute in case the Attribute Set is used for exportation.</summary>
    function Get_Col: Integer; virtual; stdcall; abstract;
    procedure Set_Format_Date(const AFormat_Date: string); virtual; stdcall; abstract;
    function Get_Format_Date: string; virtual; stdcall; abstract;
    ///<summary>Function returning the default string value in case of a string (or equivalent) Attribute.</summary>
    ///<values>The function raises an EAttribute_Not_String error if the Attribute is not a string (or equivalent) Attribute.</values>
    function Get_Defined_sValue: string; virtual; stdcall; abstract;
    ///<summary>Function returning the default double value in case of a numerical Attribute.</summary>
    ///<values>The function raises an EAttribute_Not_Numerical error if the Attribute is not a numerical Attribute.</values>
    function Get_Defined_fValue: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the default boolean value in case of a boolean Attribute.</summary>
    ///<values>The function raises an EAttribute_Not_Boolean error if the Attribute is not a boolean Attribute.</values>
    function Get_Defined_bValue: Boolean; virtual; stdcall; abstract;
    function Get_Defined_LkdValue: string; virtual; stdcall; abstract;
    procedure Set_Defined_Value(const AValue: string); overload; virtual; stdcall; abstract;
    procedure Set_Defined_Value(const AValue: Double); overload; virtual; stdcall; abstract;
    procedure Set_Defined_Value(const AValue: Boolean); overload; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sXML".</summary>
    ///<summary>The default value into an xml format in case iType=iDefined_Value</summary>
    procedure Set_XML(const AXML: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sXML".</summary>
    ///<summary>The default value into an xml format in case iType=iDefined_Value</summary>
    function Get_XML: string; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TS_Attribute_Set_Level object.</summary>
  TCreate_Attribute_Set_Level=function: TS_Attribute_Set_Level; stdcall;
  {$ENDREGION}

  {$REGION 'U_Attribute_Set'}
  ///<summary>Listing of the different types of attributes sets.</summary>s
  TAttribute_Set_Type=(
    ///Business view.
    astBusiness_View,
    ///Applied Input/Output.
    astApplied_IO,
    ///Standard Attribute Set.
    astStandard,
    ///Advanced Duplication.
    astDuplication_Settings,
    ///Advanced Deletion.
    astDeletion_Settings,
    ///Exportation settings.
    astExportation,
    ///Advanced creation.
    astAdvanced_Creation,
    ///Table type importation (from TEEXMA).
    astData_Table,
    ///Users Group
    astUsers_Group,
    ///Advanced_Comparison
    astComparison_Settings,
    ///Link_Type
    astLink_Type,
    ///Link_Type_inv
    astLink_Type_Inv);

  ///<summary>A list of TAttribute_Set_Type values.</summary>
  ///<summary>A list of TAttribute_Set_Type values.</summary>
  TAttribute_Set_Types=set of TAttribute_Set_Type;

  ///<summary>Class containing the settings of an attribute set.</summary>
  TS_Attribute_Set=class(TOTObject)
  public
    procedure Set_ID_Exportation(const AID_Exportation: Integer); virtual; stdcall; abstract;
    function Get_ID_Exportation: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Applied_IO(const AID_Applied_IO: Integer); virtual; stdcall; abstract;
    function Get_ID_Applied_IO: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iType".</summary>
    ///<summary>The type of attribute set.</summary>
    procedure Set_Type(const AType: TAttribute_Set_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iType".</summary>
    ///<summary>The type of attribute set.</summary>
    function Get_Type: TAttribute_Set_Type; virtual; stdcall; abstract;
    function Get_OL_Level: TObjectList; virtual; stdcall; abstract;
    function Get_OLColSortedLevel: TObjectList; virtual; stdcall; abstract;
    procedure Set_ID_Data_Table(const AID_Data_Table: Integer); virtual; stdcall; abstract;
    function Get_ID_Data_Table: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bTrigger_MA".</summary>
    ///<summary>For duplication settings: if true, the event 'on object creation' and 'on data writing' trigger model applications.</summary>
    procedure Set_Trigger_MA(const ATrigger_MA: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTrigger_MA".</summary>
    ///<summary>For duplication settings: if true, the event 'on object creation' and 'on data writing' trigger model applications.</summary>
    function Get_Trigger_MA: Boolean; virtual; stdcall; abstract;
    procedure Set_ID_Users_Group(const AID_Users_Group: Integer); virtual; stdcall; abstract;
    function Get_ID_Users_Group: Integer; virtual; stdcall; abstract;
    procedure Set_Default(const ADefault: Boolean); virtual; stdcall; abstract;
    function Get_Default: Boolean; virtual; stdcall; abstract;
    procedure Set_ID_S_Link_Type(const AID_Link_Type: Integer); virtual; stdcall; abstract;
    function Get_ID_S_Link_Type: Integer; virtual; stdcall; abstract;
    function CheckIf_Empty: Boolean; virtual; stdcall; abstract;
    procedure Fill(const AID_OT: Integer; const AInclude_Associative_Attributes: Boolean=True; const AInclude_Folders: Boolean=False; const ASplitInherited: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Fill(const AOL_Attribute: TObjectList; const AInclude_Associative_Attributes: Boolean=True; const AInclude_Folders: Boolean=False; const ASplitInherited: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Fill(const AID_OT: Integer; const AArr_TD: array of Integer; const AInclude_Associative_Attributes: Boolean=True; const ASplitInherited: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Fill(const AOL_Attribute: TObjectList; const AArr_TD: array of Integer; const AInclude_Associative_Attributes: Boolean=True; const ASplitInherited: Boolean=False); overload; virtual; stdcall; abstract;
    function Add_To_Attributes(const AID_Parent_Level: Integer; const AID_Attribute: Integer): Integer; overload; virtual; stdcall; abstract;
    function Add_To_Attributes(const AID_Attribute: Integer; const AInclude_Associative_Attributes: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    function Add_To_Attributes(const AAttribute: TS_Attribute; const AInclude_Associative_Attributes: Boolean=False): Integer; overload; virtual; stdcall; abstract;
    function Add_To_Attributes(const AID_Parent_Level: Integer; const AAttributeTag: string; const AInclude_Associative_Attributes: Boolean=False; const ARaiseException: Boolean=True): Integer; overload; virtual; stdcall; abstract;
    function Add_To_Attributes(const ATagsStrings: string; const ARaiseException: Boolean=True): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Function returning true if a given Object Type is present into the attribute set.</summary>
    ///<param name="AID_OT">The identifier of the Object Type.</param>
    ///<param name="ADeep_Search">If false, only the  root Object Type of the Attribute Set is evaluated.</param>
    function Get_Relevancy(const AID_OT: Integer; const ADeep_Search: Boolean): Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning true if a given Attribute is present into the attribute set.</summary>
    ///<param name="AID_Attribute">The identifier of the Attribute.</param>
    ///<param name="ALTs">A list of filtering level types. If empty, no filtering is done.</param>
    ///<param name="ADeep_Search">If false, only the  root levels of the Attribute Set is evaluated.</param>
    function Get_Attribute_Relevancy(const AID_Attribute: Integer; const ALTs: TLevel_Types; const ADeep_Search: Boolean): Boolean; virtual; stdcall; abstract;
    ///<summary>Function creating and returning a list containing the "leaf" levels ; no matter the branches.</summary>
    function Create_OL_LeafLevel: TObjectList; virtual; stdcall; abstract;
    ///<summary>Function filling a given list with the leaf levels filtered on a given parent level.</summary>
    ///<param name="AOL_LeafLevel">The list to fill.</param>
    ///<param name="AID_Parent">The identifier of the branch to filter on.</param>
    function Fill_OL_LeafLevel(const AOL_LeafLevel: TObjectList; const AID_Parent: Integer=0): Integer; virtual; stdcall; abstract;
    function Fill_OL_LeafAttribute(const AOL_LeafAttribute: TObjectList; const AID_ParentLevel: Integer=0): Integer; virtual; stdcall; abstract;
    ///<summary>Function creating and returning a list containing the "root" levels.</summary>
    function Create_OL_RootLevel: TObjectList; virtual; stdcall; abstract;
    ///<summary>Function filling a given list with the root level.</summary>
    ///<param name="AOL_RootLevel">The list to fill.</param>
    procedure Fill_OL_RootLevels(const AOL_RootLevel: TObjectList); virtual; stdcall; abstract;
    ///<summary>Function returning the number of root levels.</summary>
    function Get_RootLevelsCount: Integer; virtual; stdcall; abstract;
    function GetLevel(const AIdParentLevel: Integer; const AIdAttribute: Integer; const ARaiseException: Boolean=False): TS_Attribute_Set_Level; virtual; stdcall; abstract;
    ///<summary>Function returning the number of levels.</summary>
    function Get_LevelsCount: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning first root level object found.</summary>
    function Get_RootLevel: TS_Attribute_Set_Level; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the leaf attribute of the first branch found. The function assumes that the Attributes Set is made of a single branch.</summary>
    function Get_ID_LeafAttribute: Integer; virtual; stdcall; abstract;
    function Get_AttributesTags: string; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TS_Attribute_Set object.</summary>
  TCreate_Attribute_Set=function: TS_Attribute_Set; stdcall;
  {$ENDREGION}

  {$REGION 'U_Business_View'}
  ///<summary>Function returning the list of available Advanced Duplications for a given object Type.</summary>
  ///<param name="AID_OT">The identifier of the filtering Object Type.</param>
  ///<param name="AOnly_Default">If true, only default advanced duplications are returned.</param>
  TCreate_OL_Duplication_Settings_Filtered=function(const AID_OT: Integer; const AOnly_Default: Boolean=False): TObjectList; stdcall;

  ///<summary>Function returning the list of available Advanced Deletions for a given object Type.</summary>&gt;
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TCreate_OL_Deletion_Settings_Filtered=function(const AID_OT: Integer): TObjectList; stdcall;

  ///<summary>Function returning the list of available Advanced Creation Settings for a given object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="AOnly_Default">If true, only default advanced creations are returned.</param>
  TCreate_OL_Advanced_Creation_Settings_Filtered=function(const AID_OT: Integer; const AOnly_Default: Boolean): TObjectList; stdcall;

  ///<summary>Function returning the list of Attributes to display into the write form of an advanced duplication.</summary>
  ///<param name="AID_Advanced_Duplication">The identifier of the advanced duplication.</param>
  TCreate_OL_Attribute_For_Advanced_Duplication=function(const AID_Advanced_Duplication: Integer): TObjectList; stdcall;

  ///<summary>Function returning the list of available Advanced Comparison Settings for a given object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TCreate_OL_Advanced_Comparison_Settings_Filtered=function(const AID_OT: Integer): TObjectList; stdcall;

  ///<summary>Function returning the default Advanced Comparison Settings for a given object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TGet_Default_Advanced_Comparison_Settings=function(const AID_OT: Integer): TS_Attribute_Set; stdcall;

  ///<summary>Function returning the list of Attributes to display into the write form of an advanced creation.</summary>
  ///<param name="AID_Advanced_Creation">The identifier of the advanced creation.</param>
  TCreate_OL_Attribute_For_Advanced_Creation=function(const AID_Advanced_Creation: Integer): TObjectList; stdcall;

  ///<summary>Function returning the list of Attributes to display into the write form of an advanced comparison.</summary>
  ///<param name="AID_Advanced_Comparison">The identifier of the advanced comparison.</param>
  TCreate_OL_Attribute_For_Advanced_Comparison=function(const AID_Advanced_Comparison: Integer): TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Link_Type'}
  ///<summary>Link frame filtering type.</summary>
  TLink_Attribute_Filtering_Type=(
    ///No filtering defined.
    laftUndefined,
    ///No special filtering: the frame displays the root Objects of the tree.
    laftNone,
    ///The frame displays to children Objects of a given parent
    laftParent,
    ///The frame displays the Objects linked through a given Attribute Set. Objects coming from different leaf branches are merged with an "OR" operator.
    laftOr_Filter,
    ///The frame displays the Objects linked through a given Attribute Set. Objects coming from different leaf branches are merged with an "AND" operator.
    laftAnd_Filter,
    laftAndButNotEmpty_Filter);

  ///<summary>Class handling the informations of a Link Type.</summary>
  TS_Link_Type=class(TTree_Object)
  public
    ///<summary>Setter for the variable "ID_OT_Source".</summary>
    ///<summary>The identifier of the Source Object Type.</summary>
    procedure Set_ID_OT_Source(const AID_OT_Source: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_OT_Source".</summary>
    ///<summary>The identifier of the Source Object Type.</summary>
    function Get_ID_OT_Source: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_OT_Destination".</summary>
    ///<summary>The identifier of the Destination Object Type.</summary>
    procedure Set_ID_OT_Destination(const AID_OT_Destination: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_OT_Destination".</summary>
    ///<summary>The identifier of the Destination Object Type.</summary>
    function Get_ID_OT_Destination: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bMultiplicity".</summary>
    ///<summary>If true, the direct link Attribute is multiple (0..*).</summary>
    procedure Set_Multiplicity(const AMultiplicity: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bMultiplicity".</summary>
    ///<summary>If true, the direct link Attribute is multiple (0..*).</summary>
    function Get_Multiplicity: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bMultiplicity_Inv".</summary>
    ///<summary>If true, the inverse link Attribute is multiple (0..*).</summary>
    procedure Set_Multiplicity_Inv(const AMultiplicity_Inv: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bMultiplicity_Inv".</summary>
    ///<summary>If true, the inverse link Attribute is multiple (0..*).</summary>
    function Get_Multiplicity_Inv: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bAssociativity".</summary>
    ///<summary>If true, the link Type is one of the two associative Link Type used for an associative class.</summary>
    procedure Set_Associativity(const AAssociativity: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bAssociativity".</summary>
    ///<summary>If true, the link Type is one of the two associative Link Type used for an associative class.</summary>
    function Get_Associativity: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Filtering".</summary>
    ///<summary>The identifier of the Object filtering the direct link Attribute.</summary>
    procedure Set_ID_Object_Filtering(const AID_Object_Filtering: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Filtering".</summary>
    ///<summary>The identifier of the Object filtering the direct link Attribute.</summary>
    function Get_ID_Object_Filtering: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Filtering_Inv".</summary>
    ///<summary>The identifier of the Object filtering the inverse link Attribute.</summary>
    procedure Set_ID_Object_Filtering_Inv(const AID_Object_Filtering_Inv: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Filtering_Inv".</summary>
    ///<summary>The identifier of the Object filtering the inverse link Attribute.</summary>
    function Get_ID_Object_Filtering_Inv: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bTranspose".</summary>
    ///<summary>If true, the table made of linked object and their inherited Attribute is transposed.</summary>
    ///<summary>(Attribute in row, Objects in column).</summary>
    procedure Set_Transpose(const ATranspose: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTranspose".</summary>
    ///<summary>If true, the table made of linked object and their inherited Attribute is transposed.</summary>
    ///<summary>(Attribute in row, Objects in column).</summary>
    function Get_Transpose: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bTranspose_Inv".</summary>
    ///<summary>Same as bTranspose for the inverse link Attribute.</summary>
    procedure Set_Transpose_Inv(const ATranspose_Inv: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTranspose_Inv".</summary>
    ///<summary>Same as bTranspose for the inverse link Attribute.</summary>
    function Get_Transpose_Inv: Boolean; virtual; stdcall; abstract;
    function Get_Filter_Type: TLink_Attribute_Filtering_Type; virtual; stdcall; abstract;
    procedure Set_Filter_Type(const AType: TLink_Attribute_Filtering_Type); virtual; stdcall; abstract;
    function Get_Filter_Type_Inv: TLink_Attribute_Filtering_Type; virtual; stdcall; abstract;
    procedure Set_Filter_Type_Inv(const AType: TLink_Attribute_Filtering_Type); virtual; stdcall; abstract;
    function Get_Link_Attribute_Filtering_Type(const ATD: Integer): TLink_Attribute_Filtering_Type; virtual; stdcall; abstract;
    procedure Set_Attribute_Set_Filtering(const AAttribute_Set: TS_Attribute_Set); virtual; stdcall; abstract;
    function Get_Attribute_Set_Filtering: TS_Attribute_Set; virtual; stdcall; abstract;
    procedure Set_Attribute_Set_Filtering_Inv(const AAttribute_Set: TS_Attribute_Set); virtual; stdcall; abstract;
    function Get_Attribute_Set_Filtering_Inv: TS_Attribute_Set; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bStrongFilter".</summary>
    ///<summary>The Research in this link is filter?</summary>
    procedure Set_StrongFilter(const AStrongFilter: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bStrongFilter".</summary>
    ///<summary>The Research in this link is filter?</summary>
    function Get_StrongFilter: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bStrongFilterInv".</summary>
    ///<summary>The Research in this link is filter?</summary>
    procedure Set_StrongFilterInv(const AStrongFilterInv: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bStrongFilterInv".</summary>
    ///<summary>The Research in this link is filter?</summary>
    function Get_StrongFilterInv: Boolean; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TLink_Type object.</summary>
  TCreate_Link_Type=function: TS_Link_Type; stdcall;
  {$ENDREGION}

  {$REGION 'U_D_Data'}
  ///<summary>Virtual base class for all data type (even links).</summary>
  ///<remarks>It is an associative class between the Objects and the Attributes.</remarks>
  TD_Data=class(TID_Object)
  public
    procedure AssignId(const AData: TD_Data); virtual; stdcall; abstract;
    ///<summary>Function returning true if the input data is identical to the object.</summary>
    ///<param name="AData">The data to compare to.</param>
    ///<param name="ACompare_IDs">If true, object and attribute identifiers are also compared.</param>
    function SameValue(const AData: TD_Data; const ACompare_IDs: Boolean=True): Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object owning the data.</summary>
    procedure Set_ID_Object(const AID_Object: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object owning the data.</summary>
    function Get_ID_Object: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute owning the data.</summary>
    procedure Set_ID_Attribute(const AID_Attribute: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute owning the data.</summary>
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    ///<reintroduced/>
    function ToString(const AFormated: Boolean=False; const ADisplay_Unit: Boolean=False; const AOL_Object: TObjectList=nil): string; reintroduce; virtual; stdcall; abstract;
    function IsEmpty: Boolean; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Data_Date'}
  ///<summary>Class storing a "date" value.</summary>
  TD_Data_Date=class(TD_Data)
  public
    ///<summary>Setter for the variable "fValue".</summary>
    ///<summary>The value of the Data. The default value is the current date.</summary>
    procedure Set_Value(const AValue: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fValue".</summary>
    ///<summary>The value of the Data. The default value is the current date.</summary>
    function Get_Value: Double; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TD_Data_Date object.</summary>
  TCreate_Data_Date=function: TD_Data_Date; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_String'}
  ///<summary>A string value has a size limit (depending on the database type) but is faster to read/write.</summary>
  TD_Data_String=class(TD_Data)
  public
    ///<summary>Setter for the variable "sValue".</summary>
    ///<summary>text value of the data.</summary>
    procedure Set_Value(const AValue: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sValue".</summary>
    ///<summary>text value of the data.</summary>
    function Get_Value: string; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a string (short string, long string, url and email) data and assigning it a value.</summary>
  ///<value>The function raises an EAttribute_Not_String if the Attribute is not a string.</value>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  ///<param name="AValue">The value. If empty, the data action is set to dbaDel.</param>
  TCreate_Data_String=function(const AID_Attribute: Integer; const AID_Object: Integer; const AValue: string): TD_Data_String; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_Text'}
  ///<summary>Class storing a "text" value.</summary>
  ///<summary>A text value has no size limit but it is generally slower to read/write.</summary>
  TD_Data_Text=class(TD_Data_String);

  TCreate_Data_Text=function: TD_Data_Text; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_URL'}
  ///<summary>Class storing an "URL" (a string) value.</summary>
  ///<summary>A view option enables to directly view the data into the form.</summary>
  TD_Data_URL=class(TD_Data_String)
  public
    ///<summary>Setter for the variable "bView".</summary>
    ///<summary>If true, the webpage is displayed in the form.</summary>
    procedure Set_View(const AView: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bView".</summary>
    ///<summary>If true, the webpage is displayed in the form.</summary>
    function Get_View: Boolean; virtual; stdcall; abstract;
  end;

  TCreate_Data_URL=function: TD_Data_URL; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_Boolean'}
  ///<summary>Class storing an "boolean" value.</summary>
  TD_Data_Boolean=class(TD_Data)
  public
    ///<summary>Setter for the variable "bValue".</summary>
    ///<summary>The boolean value.</summary>
    procedure Set_Value(const AValue: Boolean); overload; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bValue".</summary>
    ///<summary>The boolean value.</summary>
    procedure Set_Value(const AValue: TAdvanced_Boolean); overload; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bValue".</summary>
    ///<summary>The boolean value.</summary>
    function Get_Value: Boolean; virtual; stdcall; abstract;
    function GetabValue: TAdvanced_Boolean; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a boolean data and assigning it a value.</summary>
  ///<summary>The function raises an EAttribute_Not_Boolean if the Attribute is not a boolean.</summary>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  ///<param name="AValue">The value.</param>
  TCreate_Data_Boolean=function(const AID_Attribute: Integer; const AID_Object: Integer; const AValue: Boolean): TD_Data_Boolean; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_Decimal'}
  ///<summary>Class storing an "decimal" value.</summary>
  ///<summary>A decimal value can be a single value, a range or a range+mean value.</summary>
  ///<summary>It can also have a unit defined.</summary>
  TD_Data_Decimal=class(TD_Data)
  public
    ///<summary>Setter for the variable "fMin".</summary>
    ///<summary>The min value.</summary>
    procedure Set_Min(const AMin: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMin".</summary>
    ///<summary>The min value.</summary>
    function Get_Min: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fMax".</summary>
    ///<summary>The max value.</summary>
    procedure Set_Max(const AMax: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMax".</summary>
    ///<summary>The max value.</summary>
    function Get_Max: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fMean".</summary>
    ///<summary>The mean value.</summary>
    procedure Set_Mean(const AMean: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMean".</summary>
    ///<summary>The mean value.</summary>
    function Get_Mean: Double; virtual; stdcall; abstract;
    procedure Set_ID_Unit(const AID_Unit: Integer); virtual; stdcall; abstract;
    function Get_ID_Unit: Integer; virtual; stdcall; abstract;
  end;

  TCreate_Data_Decimal=function: TD_Data_Decimal; stdcall;
  {$ENDREGION}

  {$REGION 'U_Archived_File'}
  ///<summary>Class storing information on a file archived into the database or in a directory.</summary>
  TD_Archived_File=class(TID_Object)
  public
    function SameValue(AArchived_File: TD_Archived_File): Boolean; virtual; stdcall; abstract;
    procedure Fill; virtual; stdcall; abstract;
    function Check_Availability(ARaise_Exception: Boolean=False): Boolean; virtual; stdcall; abstract;
    procedure Set_Path_File_Source(APath_File_Source: string; AVersion: Boolean); virtual; stdcall; abstract;
    function Get_Path_File_Source: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iIndex".</summary>
    ///<summary>The index of the Archived File relative to the Document Type.</summary>
    procedure Set_Index(AIndex: Integer); overload; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iIndex".</summary>
    ///<summary>The index of the Archived File relative to the Document Type.</summary>
    procedure Set_Index(AIndex: string); overload; virtual; stdcall; abstract;
    procedure Set_sLeft(ALeft: string); virtual; stdcall; abstract;
    function Get_sLeft: string; virtual; stdcall; abstract;
    function Get_sIndex: string; virtual; stdcall; abstract;
    function Get_sRight: string; virtual; stdcall; abstract;
    procedure Set_Filename(AFilename: string); virtual; stdcall; abstract;
    function Get_Filename: string; virtual; stdcall; abstract;
    function Extract_File(const APath: string=''): string; virtual; stdcall; abstract;
    ///<summary>Function returning the relative path of the file associated with the data. This path is built thanks to the relative directory of the File Type + the filename of the file.</summary>
    function Get_RPath_File: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_File_Type".</summary>
    ///<summary>The identifier of the Document Type.</summary>
    procedure Set_ID_File_Type(AID_File_Type: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_File_Type".</summary>
    ///<summary>The identifier of the Document Type.</summary>
    function Get_ID_File_Type: Integer; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iVersion".</summary>
    ///<summary>The version number of the Document.</summary>
    function Get_Version: Boolean; virtual; stdcall; abstract;
    function DoWrite: Boolean; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_DataFileFile'}
  TD_File=class(TD_Data)
  public
    function GetFileName: string; virtual; stdcall; abstract;
    function GetIdArchivedFile: Integer; virtual; stdcall; abstract;
    function GetArchivedFile: TD_Archived_File; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bView".</summary>
    ///<summary>If true, the document is displayed into the read form.</summary>
    procedure Set_View(const AView: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bView".</summary>
    ///<summary>If true, the document is displayed into the read form.</summary>
    function Get_View: Boolean; virtual; stdcall; abstract;
    function ExtractFile(const APath: string=''): string; virtual; stdcall; abstract;
    ///<summary>Function returning the relative path of the file associated with the data. This path is built thanks to the relative directory of the File Type + the filename of the file.</summary>
    function Get_RPath_File: string; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Data_File'}
  ///<summary>Class storing the informations of a file Data.</summary>
  TD_Data_File=class(TD_Data)
  public
    function AddFile: TD_File; overload; virtual; stdcall; abstract;
    function AddFile(const AFile: TD_File): TD_File; overload; virtual; stdcall; abstract;
    function AddFile(const AArchivedFile: TD_Archived_File): TD_File; overload; virtual; stdcall; abstract;
    function AddFile(const AFilePath: string): TD_File; overload; virtual; stdcall; abstract;
    function GetOlFile: TObjectList; virtual; stdcall; abstract;
    function Extract_File(const APath: string=''): string; virtual; stdcall; abstract;
    function GetArchivedFile: TD_Archived_File; virtual; stdcall; abstract;
    function GetIdArchivedFile: Integer; virtual; stdcall; abstract;
    function GetFileName: string; virtual; stdcall; abstract;
    function GetFilesCount: Integer; virtual; stdcall; abstract;
    function GetFile(const AIdArchivedFile: Integer): TD_File; virtual; stdcall; abstract;
    function GetLastFile: TD_File; virtual; stdcall; abstract;
    function GetLastArchivedFile: TD_Archived_File; virtual; stdcall; abstract;
    function GetIdFileType: Integer; virtual; stdcall; abstract;
  end;

  TCreate_Data_File=function: TD_Data_File; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_Table_Value'}
  TTableValueType=(
    tvtUndefined,
    tvtNumerical,
    tvtLkdObject);

  ///<summary>Class storing the infosrmations concerning a table value.</summary>
  TD_Data_Table_Value=class(TNamed_Object)
  public
    function isEmpty: Boolean; virtual; stdcall; abstract;
    function SameValue(AData: TD_Data_Table_Value): Boolean; virtual; stdcall; abstract;
    procedure SetIdSeries(const AIdSeries: Integer); virtual; stdcall; abstract;
    function GetIdSeries: Integer; virtual; stdcall; abstract;
    procedure Set_Value(const AValue: string; const AIdUnit: Integer=0); overload; virtual; stdcall; abstract;
    procedure Set_Value(const AValue: Double; const AIdUnit: Integer=0); overload; virtual; stdcall; abstract;
    procedure Set_Value(const AValue: TDate); overload; virtual; stdcall; abstract;
    procedure Set_Value(const AValue: TDateTime); overload; virtual; stdcall; abstract;
    procedure Set_Value(const AValue: Boolean); overload; virtual; stdcall; abstract;
    procedure Set_Value(const AIdLkdObject: Integer; const ATextToDisplay: string=''); overload; virtual; stdcall; abstract;
    function GetRawValue: string; virtual; stdcall; abstract;
    function Get_Value: string; virtual; stdcall; abstract;
    function Get_fValue: Double; virtual; stdcall; abstract;
    function GetIdLkdObject: Integer; virtual; stdcall; abstract;
    function GetType: TTableValueType; virtual; stdcall; abstract;
    procedure SetType(const AType: TTableValueType); virtual; stdcall; abstract;
    function GetIdUnit: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TD_Data_Table_Value object.</summary>
  TCreate_Table_Value=function: TD_Data_Table_Value; stdcall;
  {$ENDREGION}

  {$REGION 'U_Series'}
  ///<summary>Class storing the informations of a table Series.</summary>
  TD_Series=class(TNamed_Object)
  public
    function isEmpty: Boolean; virtual; stdcall; abstract;
    function Update_ID_and_Action(ASeries: TD_Series): TDB_Action; virtual; stdcall; abstract;
    procedure Set_ID_Series_Type(const AID_Series_Type: Integer); virtual; stdcall; abstract;
    function Get_ID_Series_Type: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Data_Table(const AID_Data_Table: Integer); virtual; stdcall; abstract;
    function Get_ID_Data_Table: Integer; virtual; stdcall; abstract;
    function To_Arr_Double: TArr_Double; virtual; stdcall; abstract;
    function To_Arr_String: TArr_String; virtual; stdcall; abstract;
    function Get_OL_Table_Value: TObjectList; virtual; stdcall; abstract;
    function Get_Order_Max: Integer; virtual; stdcall; abstract;
    function Get_Data_Table_Value_From_Value(const AValue: string; const AIgnore_Deleted: Boolean=True): TD_Data_Table_Value; virtual; stdcall; abstract;
    function Get_Data_Table_Value_From_Order(const AOrder: Integer; const AIgnore_Deleted: Boolean=True): TD_Data_Table_Value; virtual; stdcall; abstract;
    function Get_Table_iValue(const AOrder: Integer; const AIgnore_Deleted: Boolean=True; const ADefault: Integer=0): Integer; virtual; stdcall; abstract;
    function Get_Table_bValue(const AOrder: Integer; const AIgnore_Deleted: Boolean=True; const ADefault: Boolean=False): Boolean; virtual; stdcall; abstract;
    function Get_Table_fValue(const AOrder: Integer; const AIgnore_Deleted: Boolean=True; const ADefault: Double=-NAN): Double; virtual; stdcall; abstract;
    function Get_Table_sValue(const AOrder: Integer; const AIgnore_Deleted: Boolean=True; const ADefault: string=''): string; virtual; stdcall; abstract;
    function Get_Table_dValue(const AOrder: Integer; const AIgnore_Deleted: Boolean=True; const ADefault: TDate=-NAN): TDate; virtual; stdcall; abstract;
    function Get_Table_Value_Order(const AValue: string; const AIgnore_Deleted: Boolean=True): Integer; overload; virtual; stdcall; abstract;
    function Get_Table_Value_Order(const AValue: Double; const AIgnore_Deleted: Boolean=True): Integer; overload; virtual; stdcall; abstract;
    procedure Set_Table_Value(const AOrder: Integer; const AValue: Integer); overload; virtual; stdcall; abstract;
    procedure Set_Table_Value(const AOrder: Integer; const AValue: Boolean); overload; virtual; stdcall; abstract;
    procedure Set_Table_Value(const AOrder: Integer; const AValue: Double); overload; virtual; stdcall; abstract;
    procedure Set_Table_Value(const AOrder: Integer; const AValue: string); overload; virtual; stdcall; abstract;
    procedure Set_Table_Value(const AOrder: Integer; const AValue: TDate); overload; virtual; stdcall; abstract;
    procedure Add_Table_Value(const AValue: Integer); overload; virtual; stdcall; abstract;
    procedure Add_Table_Value(const AValue: Boolean); overload; virtual; stdcall; abstract;
    procedure Add_Table_Value(const AValue: Double); overload; virtual; stdcall; abstract;
    procedure Add_Table_Value(const AValue: string); overload; virtual; stdcall; abstract;
    procedure Add_Table_Value(const AValue: TDate); overload; virtual; stdcall; abstract;
    procedure Add_Table_Values(const AArr_Values: array of string); overload; virtual; stdcall; abstract;
    procedure Add_Table_Values(const AArr_Values: array of Double); overload; virtual; stdcall; abstract;
    procedure Add_Table_Values(ASL: TStringList); overload; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Data_Table'}
  ///<summary>Enumeration of the various sources usable to fill a table data.</summary>
  TTable_Source=(
    ///The source is a CSV file.
    tsCSV_File,
    ///The source is a formated string.
    tsFormated_String,
    ///The source is an Excel file.
    tsExcel_File);

  ///<summary>TD_Data_Table: class storing a "table" value.</summary>
  TD_Data_Table=class(TD_Data)
  public
    function LinInter(const AID_Series_X: Integer; const AID_Series_Y: Integer; const AX: Double; const ACalculate_Regression: Boolean): Double; virtual; stdcall; abstract;
    ///<summary>Function allowing to set DYNAMICALLY the Table Type identifier of the Data.</summary>
    ///<summary>This function is DANGEROUS since the Table Type is normally deduced from the Attribute the data belongs to.</summary>
    ///<summary>Do not use this function if you were not asked to!</summary>
    procedure Set_ID_Table_Type(const AID_Table_Type: Integer); virtual; stdcall; abstract;
    function Get_ID_Table_Type: Integer; virtual; stdcall; abstract;
    function ToFile(const ADir: string=''): string; virtual; stdcall; abstract;
    function ToExcel(const ADir: string=''; const ADisplay: Boolean=False): Variant; virtual; stdcall; abstract;
    function Get_OL_Series: TObjectList; virtual; stdcall; abstract;
    function Get_AS_Import: TS_Attribute_Set; virtual; stdcall; abstract;
    procedure Set_AS_Import(const AAS_Import: TS_Attribute_Set); virtual; stdcall; abstract;
    function Add_Series(const AID_Series_Type: Integer; const AArr_Values: array of Double; const AName: string=''): TD_Series; overload; virtual; stdcall; abstract;
    function Add_Series(const AID_Series_Type: Integer; const AArr_Values: array of string; const AName: string=''): TD_Series; overload; virtual; stdcall; abstract;
    function Add_Series(const AID_Series_Type: Integer; const AName: string=''): TD_Series; overload; virtual; stdcall; abstract;
    procedure Select_From_Series_Name(const AWhat: array of string; const AWhere: array of string; var AResult: TStrings; const AClear_Result: Boolean=True); virtual; stdcall; abstract;
    function Get_Series_From_Series_Type(const AID_Series_Type: Integer; AIgnore_Deleted: Boolean=True): TD_Series; virtual; stdcall; abstract;
    function Get_Series_From_Series_Type_Name(const AName: string; const ACase_Sensitive: Boolean=False; AIgnore_Deleted: Boolean=True): TD_Series; virtual; stdcall; abstract;
    function Get_Series_From_Series_Type_Order(const AOrder: Integer; AIgnore_Deleted: Boolean=True): TD_Series; virtual; stdcall; abstract;
    function Get_Series(const AID_Series: Integer): TD_Series; virtual; stdcall; abstract;
    function Get_Series_From_Name(const AName: string; const ACase_Sensitive: Boolean=False; AIgnore_Deleted: Boolean=True): TD_Series; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TD_Data_Table object from various sources: a path to a csv file, excel file or a formatted string.</summary>
  ///<param name="ASource">Defines the source used to create the table data.</param>
  ///<param name="AID_Table_Type">The identifier of the Table Type of the table.</param>
  ///<param name="AValue">If source is an excel or csv file, the value is the absolute path to the file. If the source is a formatted string, the value is this formatted string.</param>
  ///<param name="ACol_Separator">In case of a csv file, it is possible to define the value separator. By default, this is the tabulation character (#9).</param>
  ///<param name="ATranspose">if true, the source must be transposed before parsed. This input is relevant for excel and text sources only.</param>
  ///<param name="ARaise_Exception">If false, errors in the source are not raised.</param>
  TCreate_Data_Table=function(const ASource: TTable_Source; const AID_Table_Type: Integer; const AValue: string; const ACol_Separator: string=''; const ATranspose: Boolean=True; const ARaise_Exception: Boolean=True): TD_Data_Table; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_Link'}
  ///<summary>Listing indicating the type of values sent to procedure handling links values as string.</summary>
  TLink_String_Format=(
    ///A list of objects identifiers separated by a comma (,).
    lsfObject_IDs,
    ///A list of objects names. The separator depends on the method/function.
    lsfObject_Names);

  ///<summary>Class storing links. The associated table does not work as the other data table.</summary>
  TD_Data_Link=class(TD_Data)
  public
    procedure AssignLkdObjects(const AArrLkdObject: TJSONArray); virtual; stdcall; abstract;
    procedure AssignIDsLkdObjects(const AArrIDLkdObject: TJSONArray); virtual; stdcall; abstract;
    ///<summary>Procedure comparing the current data to the data read from the database and updating its list of added or removed links.</summary>
    ///<param name="AData_DB">The link data read from the database.</param>
    procedure Update_Lists(const AData_DB: TD_Data_Link); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "SL_ID_Object_Lkd".</summary>
    ///<summary>The list of identifiers of the linked Objects.</summary>
    function Get_SL_ID_Object_Lkd: TStringList; virtual; stdcall; abstract;
    function Get_IDs_Object_Lkd: string; virtual; stdcall; abstract;
    function Get_ID_Object_Lkd: Integer; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Object".</summary>
    ///<summary>The list of TS_Object_Data objects corresponding to the linked Object.</summary>
    ///<summary>This list has the same length as SL_IDs when the data is read (and when OL_Object is initialized).</summary>
    function Get_OL_Object: TObjectList; virtual; stdcall; abstract;
    procedure Set_Value(const AIdObject_Lkd: Integer; const AReplace: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Set_Value(const AIDs_Object_Lkd: string; const AReplace: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Set_Value(const ASL_ID_Object_Lkd: TStringList; const AReplace: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Set_Value(const AOL_Object_Lkd: TObjectList; const AReplace: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Add_Object(const AIdObject: Integer); virtual; stdcall; abstract;
    procedure Add_Objects(const AIDs_Object_Lkd: string); overload; virtual; stdcall; abstract;
    procedure Add_Objects(const ASL_ID_Object_Lkd: TStringList); overload; virtual; stdcall; abstract;
    procedure Add_Objects(const AOL_Object_Lkd: TObjectList); overload; virtual; stdcall; abstract;
    procedure Remove_Object(const AIdObject: Integer); virtual; stdcall; abstract;
    procedure Clear; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "SL_ID_Added".</summary>
    ///<summary>The list of identifiers of the added linked objects.</summary>
    ///<summary>This list must be initialized with Update_SLs before calling the write function.</summary>
    function Get_SL_ID_Added: TStringList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "SL_ID_Deleted".</summary>
    ///<summary>The list of the Identifiers of the deleted linked objects.</summary>
    ///<summary>This list must be initialized with Update_SLs before calling the write function.</summary>
    function Get_SL_ID_Deleted: TStringList; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a boolean data and assigning it a value.</summary>
  ///<summary>The function raises an EAttribute_Not_Link if the Attribute is not a link.</summary>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AValue">The identifier of the linked objects.</param>
  ///<param name="ALSF">The nature of the value sent.</param>
  TCreate_Data_Link=function(const AIdAttribute: Integer; const AIdObject: Integer; const AValue: string; const ALSF: TLink_String_Format=lsfObject_IDs): TD_Data_Link; stdcall;
  {$ENDREGION}

  {$REGION 'U_Object_Associative'}
  ///<summary>Class storing an associative Object and its data.</summary>
  TS_Object_Associative=class(TS_Object_Data)
  public
    function SameValue(AData: TS_Object_Associative): Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Left".</summary>
    ///<summary>The identifier of the left object of the associative object.</summary>
    procedure Set_ID_Object_Left(AID_Left: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Left".</summary>
    ///<summary>The identifier of the left object of the associative object.</summary>
    function Get_ID_Object_Left: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Right".</summary>
    ///<summary>The identifier of the right object of the associative object.</summary>
    procedure Set_ID_Object_Right(AID_Right: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Right".</summary>
    ///<summary>The identifier of the right object of the associative object.</summary>
    function Get_ID_Object_Right: Integer; virtual; stdcall; abstract;
  end;

  TCreate_Object_Associative=function(const AID_Object_Left: Integer; const AID_Object_Right: Integer): TS_Object_Associative; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_Link_Ass'}
  ///<summary>Class storing an associative Data.</summary>
  TD_Data_Link_Ass=class(TD_Data_Link)
  public
    function Get_Initialized: Boolean; virtual; stdcall; abstract;
  end;

  TCreate_Data_Link_Ass=function: TD_Data_Link_Ass; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data'}
  TCreate_Data_From_String=function(const ATD: Integer; const S: string; const AStringType: TStringType; const AHandle_Associativity: Boolean=False): TD_Data; stdcall;

  ///<summary>Function creating a data object (the exact class depends on the "Data Type"). If the identifier is positive, it is read from the database.</summary>
  ///<param name="ADataType">Data type.</param>
  ///<param name="AHandleAssociativity">False if true, in case of an inverse link, the object created is a TD_Data_Link_Ass.</param>
  ///<param name="AIdData">If not null, the data is read from the database.</param>
  TCreate_Data_From_TD=function(const ADataType: Integer; const AHandleAssociativity: Boolean=False; const AIdData: Integer=0): TD_Data; stdcall;

  ///<summary>Function returning a data at the intersection of an Attribute and an Object. The function first tries to read from the database. If not found, it creates the data and initializes its Attribute and Object identifiers.</summary>
  ///<value>The function may raise an error if the Attribute is a "list" Attribute (except if no reading in the database is specified).</value>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AReadInDataBase">If false, no reading in the database is done.</param>
  TCreate_Data=function(const AIdAttribute: Integer; const AIdObject: Integer; const AReadInDataBase: Boolean=True): TD_Data; stdcall;

  ///<summary>Function creating a numerical data (decimal, date) and assigning it a value.</summary>
  ///<value>The function raises an EAttribute_Not_Numerical if the Attribute is not numerical.</value>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AValue">The value. If NaN, the data action is set to dbaDel.</param>
  TCreate_Data_Numerical=function(const AIdAttribute: Integer; const AIdObject: Integer; const AValue: Double): TD_Data; stdcall;

  ///<summary>Function creating a TD_Series object.</summary>
  TCreate_Series=function: TD_Series; stdcall;

  ///<summary>Function returning a formated string of a given float value thanks to the display settings of a given Attribute.</summary>
  ///<param name="AValue">The value.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute to use for the settings.</param>
  ///<param name="AAdd_Unit">If true, the unit name is added to the result string (in case the Attribute has a defined Unit).</param>
  ///<param name="ADefault_Result">The default result in case the string is not a numerical.</param>
  TDecToStrF_From_Attribute=function(const AValue: Double; const AIdAttribute: Integer; const AAdd_Unit: Boolean=False; const ADefault_Result: string=''): string; stdcall;

  ///<summary>Function returning the list of data of a list of attributes and a single Object.</summary>
  ///<param name="AOL_Attribute">The list of Attributes.</param>
  ///<param name="AIdObject">List of Objects identifiers. If nil, the whole list of Objects of the Object Type is used.</param>
  ///<param name="ATreat_Inherited_Attribute">If true, data of inherited attributes are read.</param>
  ///<param name="AARM">The associativity reading mode.</param>
  TCreate_OL_Data_From_Object=function(const AOL_Attribute: TObjectList; const AIdObject: Integer; const ATreat_Inherited_Attribute: Boolean=True; const AARM: TAssociativity_Reading_Mode=armAll): TObjectList; stdcall;

  ///<summary>Function returning the list of data of a given attribute and a preselection of Objects.</summary>
  ///<summary>Warning: this function does not handle inherited attributes.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="ASL_ID_Object">List of Object's identifiers. If nil, the whole list of Object of the Object Type is used.</param>
  ///<param name="AARM">The associativity reading mode.</param>
  TCreate_OL_Data_From_Attribute=function(const AIdAttribute: Integer; const ASL_ID_Object: TStringList=nil; const AARM: TAssociativity_Reading_Mode=armAll): TObjectList; stdcall;

  ///<summary>Function creating the list of data associated to couples of object and attributes.</summary>
  ///<param name="AOlAttribute">The list of Attributes.</param>
  ///<param name="ASlIdObject">List of Object's identifiers. If nil, the whole list of Object of the Object Type is used.</param>
  ///<param name="ATreatInheritedAttribute">If true, data of inherited attributes are read.</param>
  ///<param name="AAssociativityReadingMode">The associativity reading mode.</param>
  ///<param name="ATable">Apreselection table name.</param>
  TCreate_OL_Data=function(const AOlAttribute: TObjectList; const ASlIdObject: TStringList; const ATreatInheritedAttribute: Boolean=True; const AAssociativityReadingMode: TAssociativity_Reading_Mode=armAll; const ATable: string=''): TObjectList; stdcall;

  ///<summary>Function returning the TD_Data object corresponding to a given Object and Attribute.</summary>
  ///<param name="AOlData">The list to search into.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list AOlData is supposed to be sorted by Object and Attribute ascending identifiers. This accelerates the searching process.</param>
  ///<returns>The function returns a nil value if no Data is found.</returns>
  TGet_Data=function(const AOlData: TObjectList; const AIdAttribute: Integer; const AIdObject: Integer; const ASorted: Boolean=False): TD_Data; stdcall;

  ///<summary>Function filling a given sub list of data for a given couple of Attribute and Object. The data are not read but taken from a given list.</summary>
  ///<param name="AOlFilteredData">The list of data to fill.</param>
  ///<param name="AOlData">The list of data to filter.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list of data is supposed to be sorted (faster searches).</param>
  ///<param name="AFormatedData">If true, the inherited data are supposed to be into the linked objects of the link data (clear ? huhuhu).</param>
  TFillOlFilteredData=function(const AOlFilteredData: TObjectList; const AOlData: TObjectList; const AIdAttribute: Integer; const AIdObject: Integer; const ASorted: Boolean=False; const AFormatedData: Boolean=False): TObjectList; stdcall;

  ///<summary>Function creating a sub list of data for a given couple of Attribute and Object.</summary>
  ///<param name="AOlData">The list of data to filter.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list of data is supposed to be sorted (faster searches).</param>
  ///<param name="AFormatedData">If true, the inherited data are supposed to be into the linked objects of the link data (clear ? huhuhu).</param>
  TCreate_OL_Data_Filtered=function(const AOlData: TObjectList; const AIdAttribute: Integer; const AIdObject: Integer; const ASorted: Boolean=False; const AFormatedData: Boolean=False): TObjectList; stdcall;

  ///<summary>Function exporting the table data of many given objects and a given Attribute into a file.</summary>
  ///<param name="ASL_ID_Object">The identifiers of the objects to export.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="ASuperpose">If true (and in case of an excel file), the curves of the various objects must be displayed on the same graphic.</param>
  ///<param name="ADisplay_Mean_Curve">If true, the mean curve(s) must be calculated by the excel file.</param>
  ///<param name="ADisplay">It true, the file must be opened after the execution.</param>
  TExport_Multiple_Data_Table_To_File=function(const ASL_ID_Object: TStringList; const AIdAttribute: Integer; const ASuperpose: Boolean; const ADisplay_Mean_Curve: Boolean; const ADisplay: Boolean=False): Variant; stdcall;

  ///<summary>Function exporting a table data to a file (text or excel). This function may also be used to generated the pictures associated to the data using Excel.</summary>
  ///<value>If the Table Type grapher is set to Excel, the data are exported to the Excel format, using the setting file.</value>
  TExport_Data_Table_To_File=function(const AIdAttribute: Integer; const AIdObject: Integer): string; stdcall;

  ///<summary>Function retrieving an associative Object thanks to its right linked object.</summary>
  ///<param name="AOlObject">The list of object to search into.</param>
  ///<param name="AIdObject_Right">The identifier of the right Object.</param>
  TGet_Object_Associative=function(const AOlObject: TObjectList; const AIdObject_Right: Integer): TS_Object_Associative; stdcall;

  ///<summary>Function returning the numerical value of a given numerical data.</summary>
  ///<summary>The function raises an E_Attribute_Not_Numerical error if the type of data is not numerical.</summary>
  ///<param name="AData">The data to use</param>
  ///<param name="ADefaultValue">The default value if not data is found.</param>
  TGet_NumericalData_fValue=function(const AData: TD_Data; const ADefaultValue: Double): Double; stdcall;

  ///<summary>Function returning the numerical value of a data found into a list of data thank to its attribute and object identifiers.</summary>
  ///<summary>The function raises an E_Attribute_Not_Numerical error if the type of data is not numerical.</summary>
  ///<param name="AOlData">The list of data.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list is supposed to be sorted by Objects then Attributes (ootData_by_Object).</param>
  ///<param name="ADefaultValue">The default value if not data is found.</param>
  TGet_Data_fValue=function(const AOlData: TObjectList; const AIdAttribute: Integer; const AIdObject: Integer; const ASorted: Boolean=True; const ADefaultValue: Double=-NAN): Double; stdcall;

  ///<summary>Function returning the boolean value of a data found into a list of data thank to its attribute and object identifiers.</summary>
  ///<summary>The function raises an E_Attribute_Not_Numerical error if the type of data is not boolean.</summary>
  ///<param name="AOlData">The list of data.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list is supposed to be sorted by Objects then Attributes (ootData_by_Object).</param>
  ///<param name="ADefaultValue">The default value if not data is found.</param>
  TGet_Data_bValue=function(const AOlData: TObjectList; const AIdAttribute: Integer; const AIdObject: Integer; const ASorted: Boolean=True; const ADefaultValue: Boolean=False): Boolean; stdcall;

  ///<summary>Function returning the string value of a data found into a list of data thank to its attribute and object identifiers.</summary>
  ///<summary>The function raises an E_Attribute_Not_Numerical error if the type of data is not a string.</summary>
  ///<param name="AOlData">The list of data.</param>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list is supposed to be sorted by Objects then Attributes (ootData_by_Object).</param>
  ///<param name="ADefaultValue">The default value if not data is found.</param>
  TGet_Data_sValue=function(const AOlData: TObjectList; const AIdAttribute: Integer; const AIdObject: Integer; const ASorted: Boolean=True; const ADefaultValue: string=''): string; stdcall;

  ///<summary>Function returning the identifier of a single object found into a list of data thank to its attribute and object identifiers.</summary>
  ///<summary>The function raises an E_Attribute_Not_Link error if the type of data is not a link.</summary>
  ///<summary>The function ignores the other linked objects (in case of a N link attribute).</summary>
  ///<param name="AOlData">The list of data.</param>
  ///<param name="AIdAttribute_Link">The identifier of the Attribute.</param>
  ///<param name="AIdObject">Thhe identifier of the Object.</param>
  ///<param name="ADefaultValue">A default identifier in case no data could be found.</param>
  ///<param name="ASorted">If true, the list is supposed to be sorted by Objects then Attributes (ootData_by_Object).</param>
  TGet_Data_ID_Object_Linked=function(const AOlData: TObjectList; const AIdAttribute_Link: Integer; const AIdObject: Integer; const ASorted: Boolean=True; const ADefaultValue: Integer=0): Integer; stdcall;

  ///<summary>Function returning the a list of linked objects found into a list of data thank to its attribute and object identifiers.</summary>
  ///<summary>The function raises an E_Attribute_Not_Link error if the type of data is not a link.</summary>
  ///<param name="AOlData">The list of data.</param>
  ///<param name="AIdAttribute_Link">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list is supposed to be sorted by Objects then Attributes (ootData_by_Object).</param>
  TGet_Data_OL_Object_Linked=function(const AOlData: TObjectList; const AIdAttribute_Link: Integer; const AIdObject: Integer; const ASorted: Boolean=True): TObjectList; stdcall;

  ///<summary>Function returning the a list of linked objects identifiers found into a list of data thank to its attribute and object identifiers.</summary>
  ///<summary>The function raises an E_Attribute_Not_Link error if the type of data is not a link.</summary>
  ///<param name="AOlData">The list of data.</param>
  ///<param name="AIdAttribute_Link">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ASorted">If true, the list is supposed to be sorted by Objects then Attributes (ootData_by_Object).</param>
  TGet_Data_SL_ID_Object_Linked=function(const AOlData: TObjectList; const AIdAttribute_Link: Integer; const AIdObject: Integer; const ASorted: Boolean=True): TStringList; stdcall;

  ///<summary>Function returning a single linked object found into a list of data thank to its attribute and object identifiers.</summary>
  ///<summary>The function raises an E_Attribute_Not_Link error if the type of data is not a link.</summary>
  ///<summary>The function ignores the other linked objects (in case of a N link attribute).</summary>
  ///<param name="AOlData">The list of data.</param>
  ///<param name="AIdAttribute_Link">The identifier of the Attribute.</param>
  ///<param name="AIdObject">Tthe identifier of the Object.</param>
  ///<param name="ASorted">If true, the list is supposed to be sorted by Objects then Attributes (ootData_by_Object).</param>
  TGet_Data_Object_Linked=function(const AOlData: TObjectList; const AIdAttribute_Link: Integer; const AIdObject: Integer; const ASorted: Boolean=True): TS_Object_Data; stdcall;

  ///<summary>Function writing a single data into the database and returning a Model application queries string.</summary>
  ///<param name="AData_Modified">The modified data.</param>
  ///<param name="AData_Existing">The existing data. If nil, it is read from the database.</param>
  ///<param name="AHandleTraceability">If true, tracability is handled.</param>
  ///<param name="ATriggerModelApplications">If true, Models application are handled.</param>
  TWrite_Single_Data=function(const AData_Modified: TD_Data; const AData_Existing: TD_Data=nil; const AHandleTraceability: Boolean=True; const ATriggerModelApplications: Boolean=True): string; stdcall;

  ///<summary>Procedure writing a Link data into the database.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AValue">The value to write (a list of identifiers or object's names).</param>
  ///<param name="ALSF">The nature of the value sent.</param>
  TWrite_Data_Link=function(const AIdAttribute: Integer; const AIdObject: Integer; const AValue: string; const ALSF: TLink_String_Format=lsfObject_IDs): string; stdcall;

  ///<summary>Procedure writing a boolean data into the database.</summary>
  ///<summary>The procedure raises an EAttribute_Not_Boolean if the Attribute is not a boolean.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AValue">The value.</param>
  TWrite_Data_Boolean=function(const AIdAttribute: Integer; const AIdObject: Integer; const AValue: Boolean): string; stdcall;

  ///<summary>Procedure writing a numerical data (decimal, date).</summary>
  ///<summary>The procedure raises an EAttribute_Not_Numerical if the Attribute is not numerical.</summary>
  ///<param name="AIdAttribute">Tthe identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AValue">The value. If NaN, the data action is set to dbaDel.</param>
  ///<returns>The identifier of the data written.</returns>
  TWrite_Data_Numerical=function(const AIdAttribute: Integer; const AIdObject: Integer; const AValue: Double): string; stdcall;

  ///<summary>Procedure writing a string (real string, text, url and email) data.</summary>
  ///<summary>The procedure raises an EAttribute_Not_String if the Attribute is not a string.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="AValue">The value. If empty, the data action is set to dbaDel.</param>
  ///<returns>The identifier of the data written.</returns>
  TWrite_Data_String=function(const AIdAttribute: Integer; const AIdObject: Integer; const AValue: string): string; stdcall;

  ///<summary>Function writing a data file. It handles the settings of the associated archived file depending on various settings (list attribute, versioned File Type, aso).</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute of the Data.</param>
  ///<param name="AIdObject">The identifier of the Object of the Data.</param>
  ///<param name="APath_File_Source">The path to the Source File.</param>
  ///<returns>The identifier of the data written.</returns>
  TWrite_Data_File=function(const AIdAttribute: Integer; const AIdObject: Integer; const APath_File_Source: string): string; stdcall;

  ///<summary>Function writing data into the database and returning a Model application queries string.</summary>
  ///<param name="AOlModifiedData">The list of modified data.</param>
  ///<param name="AOlExistingData">The list of existing data. If nil, it is read from the database.</param>
  ///<param name="AHandleTraceability">If true, tracability is handled.</param>
  ///<param name="ATriggerModelApplications">If true, Models application are handled.</param>
  TWrite_Data=function(const AOlModifiedData: TObjectList; const AOlExistingData: TObjectList=nil; const AHandleTraceability: Boolean=True; const ATriggerModelApplications: Boolean=True): string; stdcall;

  ///<summary>Function reading from the database a Link data related to a given Attribute and a given Object and returning the result as a string containing either the identifiers of the linked Objects or their names.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ALSF">The nature of the value returned.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  TRead_Data_Link=function(const AIdAttribute: Integer; const AIdObject: Integer; const ALSF: TLink_String_Format=lsfObject_IDs; const ADefaultValue: string=''): string; stdcall;

  ///<summary>Function reading from the database a Link data related to a given Attribute and a given Object and returning the first linked Object identifier.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  TRead_Data_Link_Single_ID_Object=function(const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultValue: Integer=0): Integer; stdcall;

  ///<summary>Function reading from the database a Link data related to a given Attribute and a given Object and returning its value.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  TRead_Data_Boolean=function(const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultValue: Boolean=False): Boolean; stdcall;

  ///<summary>Function reading from the database a decimal data related to a given Attribute and a given Object and returning its value.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  ///<returns>In case of range or a range+mean data, it returns the mean value.</returns>
  TRead_Data_Numerical=function(const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultValue: Double=-NAN): Double; stdcall;

  ///<summary>Function reading from the database a string (short text, long text, url and e-mail) data related to a given Attribute and a given Object and returning its value.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  ///<returns>The value returned is formated with linebreaks.</returns>
  TRead_Data_String=function(const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultValue: string=''): string; stdcall;

  ///<summary>Function reading from the database a table data related to a given Attribute and a given Object and returning its value.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  ///<returns>The value returned is a formated table: linebreaks as series separator, tabs as value separator and the table is possibly transposed.</returns>
  TRead_Data_Table=function(const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultValue: string=''): string; stdcall;

  ///<summary>Function reading from the database a file data related to a given Attribute and a given Object and returning the path of it associated file.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  TRead_Data_File=function(const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultValue: string=''): string; stdcall;

  ///<summary>Function reading from the database the filename related to a given Attribute and a given Object.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ADefaultValue">A default value in case no data could be found.</param>
  TRead_Data_Filename=function(const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultValue: string=''): string; stdcall;

  ///<summary>Procedure extracting the graphics pictures associated to a table data and returning the path to the directory</summary>
  ///<param name="AID_Data_Table">the identifier of the data table.</param>
  ///<param name="ADir">the directory where to extract the files.</param>
  TExtract_Data_Table_Graphics=procedure(const AID_Data_Table: Integer; const ADir: string); stdcall;

  ///<summary>procedure deleting Data (all types) into the database.</summary>
  ///<param name="ADataType">Identifier of the datatype of the Object.</param>
  ///<param name="AIdObject">Identifier of the Object.</param>
  TDelete_Data=procedure(const ADataType: Integer; const AIdObject: Integer); stdcall;

  ///<summary>Function creating a list of all archived files belonging to a given File Type.</summary>
  ///<param name="AID_File_Type">The identifier of the file type.</param>
  TCreate_OL_Archived_File=function(const AID_File_Type: Integer): TObjectList; stdcall;

  ///<summary>Function creating a TArchived_File object.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  ///<param name="AID_Archived_File">An archived file identifier.</param>
  TCreate_Archived_File=function(const AID_File_Type: Integer; const AID_Archived_File: Integer=0): TD_Archived_File; stdcall;

  ///<summary>Function extracting the file of a given data file and returing the path of the file.</summary>
  ///<param name="AID_Data_File">The identifier of the data file.</param>
  ///<param name="APath">This may be the path to a directory or a file where the file should be extracted. If empty, the file is copied in the "temp" folder.</param>
  TExtract_Data_File_File=function(const AID_Data_File: Integer; const APath: string=''): string; stdcall;

  ///<summary>Function extracting the file of a given Archived file and returing the path of the file.</summary>
  ///<param name="AID_Archived_File">The identifier of the Archived file.</param>
  ///<param name="APath">This may be the path to a directory or a file where the file should be extracted. If empty, the file is copied in the "temp" folder.</param>
  ///<returns>The absolute path to the file extracted.</returns>
  TExtract_Archived_File_File=function(const AID_Archived_File: Integer; const APath: string=''): string; stdcall;

  ///<summary>Function returning the identifier of an  Archived File from a given filename and file Type identifier.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  ///<param name="AFilename">The filename.</param>
  TGet_ID_Archived_File_From_Filename=function(const AID_File_Type: Integer; const AFilename: string): Integer; stdcall;

  ///<summary>Function creating a TD_Data_File object ready for publication. It handles the settings of the associated archived file depending on various settings (list attribute, versioned File Type, aso).</summary>
  ///<summary>In any case, the new TD_File object is added to the end of the list. Use GetLastDataFileFile or GetLastArchivedFile to retrieve the new objects.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute of the Data.</param>
  ///<param name="AIdObject">The identifier of the Object of the Data.</param>
  ///<param name="ASourceFilePath">The path to the file. If the file does not physically exist, the function searches for an Archived file with the given filename.</param>
  TCreate_Data_File_For_Publication=function(const AIdAttribute: Integer; const AIdObject: Integer; const ASourceFilePath: string): TD_Data_File; stdcall;

  ///<summary>Do not use.</summary>
  TInitialize_New_Document_Model=function(const AID_Document_Model: Integer; const APath_File: string; const ADataType: Integer=-3): TS_Object; stdcall;

  ///<summary>Do not use.</summary>
  TCheck_Document_With_Template_Gestion=function(AID_Document: Integer): Boolean; stdcall;

  ///<summary>Do not use.</summary>
  ///<param name="AID_Document">the document ID</param>
  ///<param name="APath_File">the string path file</param>
  ///<param name="AModel">use model ?</param>
  ///<param name="AUse_Extract_Template">If true, the extraction associated to the document model is used.</param>
  TInitialize_New_Document=function(const AID_Document: Integer; const APath_File: string; const AModel: Boolean=False; const AUse_Extract_Template: Boolean=False): string; stdcall;

  ///<summary>Do not use.</summary>
  TCreate_Document_Versionned_In_DB=function(const AID_Document: Integer; const ADuplicate_Work_Files: Boolean): TS_Object; stdcall;

  ///<summary>Do not use.</summary>
  TPass_Document_As_Reference=procedure(const AID_Document: Integer; const ATransform_Into_PDF: Boolean); stdcall;
  {$ENDREGION}

  {$REGION 'U_Right'}
  ///<summary>Base class for all TEEXMA Right classes.</summary>
  TRM_Right=class(TTree_Object)
  public
    procedure Set_ID_Users_Group(const AIdUsersGroup: Integer); virtual; stdcall; abstract;
    function Get_ID_Users_Group: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Object(const AIdObject: Integer); virtual; stdcall; abstract;
    function Get_ID_Object: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Object_Type(const AIdObjectType: Integer); virtual; stdcall; abstract;
    function Get_ID_Object_Type: Integer; virtual; stdcall; abstract;
  end;

  TCreate_Right=function: TRM_Right; stdcall;

  ///<summary>Function modifying the rights of an Object for a given Users Group.</summary>
  ///<param name="AIdObject">The identifier of the Object to modify.</param>
  ///<param name="ANewRight">The new right of the Object.</param>
  ///<param name="AIdUsersGroup">The identifier of the Users Group. If null, the right is applied to all Groups.</param>
  TModify_Object_Rights=procedure(const AIdObject: Integer; const ANewRight: TDB_Right; const AIdUsersGroup: Integer=0); stdcall;

  ///Defining the default rights for the users groups.
  ///The object type must have at least a read default right for its objects.
  ///The parent object must also be "at least" visible for the Users Group.
  ///<summary>Function returning the default right on of a new object belonging to a given Object Type for a given User.</summary>
  ///<param name="AID_User">The identifier of the User.</param>
  ///<param name="AID_OT">The identifier of the Object's Object Type.</param>
  TGet_User_Default_Right_On_New_Object=function(const AID_User: Integer; const AID_OT: Integer): TDB_Right; stdcall;

  TGetActiveUserRightOnObject=function(const AIdObject: Integer): TDB_Right; stdcall;
  {$ENDREGION}

  {$REGION 'U_Right_Object_Type'}
  ///<summary>Class storing the informations on the right of User group on a given Object Type.</summary>
  TRM_Object_Type=class(TRM_Right)
  public
    procedure SetNewObjectsDefaultRight(const ANewObjectDefaultRight: TDB_Right); virtual; stdcall; abstract;
    function GetNewObjectDefaultRight: TDB_Right; virtual; stdcall; abstract;
    procedure SetLkdObjectRight(const ALkdObjectRight: TDB_Right); virtual; stdcall; abstract;
    function GetLkdObjectRight: TDB_Right; virtual; stdcall; abstract;
    function IsRightModified: Boolean; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Function_Rights'}
  ///<summary>Listing of Function rights for a user group.</summary>
  ///<summary>Values starting with fra are related to the Administration of TEEXMA.</summary>
  ///<summary>Values starting with fru are related to the Use of TEEXMA.</summary>
  TFunction_Right=(
    ///<summary>Right on the various structure Administrations.</summary>
    fraStructure,
    ///<summary>Right on the Users and Users Groups Administrations.</summary>
    fraRights,
    ///<summary>Right on the importation.</summary>
    fraImportation,
    ///<summary>Right to use the exportation function.</summary>
    fruExportation,
    ///<summary>Right to use the extraction function.</summary>
    fruExtraction,
    ///<summary>Right to use the multicriteria selection and the choice guides.</summary>
    fruMCS,
    ///<summary>Right to use the models.</summary>
    fruModels,
    ///<summary>Right to use the data-mining interface.</summary>
    fruData_Mining);

  ///<summary>A set of function's rights.</summary>
  TFunction_Rights=set of TFunction_Right;
  {$ENDREGION}

  {$REGION 'U_LObject'}
  ///<summary>Parent class for the TRM_User and TRM_Users_Group classes containing the "sLogin" attribute, common to both classes.</summary>
  TRM_LObject=class(TTree_Object)
  public
    ///<summary>Setter for the variable "sLogin".</summary>
    ///<summary>The login of the User or Users Group.</summary>
    procedure Set_Login(const ALogin: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sLogin".</summary>
    ///<summary>The login of the User or Users Group.</summary>
    function Get_Login: string; virtual; stdcall; abstract;
  end;

  TCreate_LObject=function: TRM_LObject; stdcall;
  {$ENDREGION}

  {$REGION 'U_Users_Group_User'}
  ///<summary>Class storing the bind between a given User and a given Users Group.</summary>
  TRM_Users_Group_User=class(TNamed_Object)
  public
    function Get_ID_User: Integer; virtual; stdcall; abstract;
    procedure Set_ID_User(AIdUser: Integer); virtual; stdcall; abstract;
    function Get_ID_Users_Group: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Users_Group(AIdUsersGroup: Integer); virtual; stdcall; abstract;
  end;

  TCreate_Users_Group_User2=function: TRM_Users_Group_User; stdcall;

  ///<summary>Function creating a TUsers_Group_User object using the default constructor.</summary>
  ///<param name="AIdUsersGroup">The identifier of the Users Group.</param>
  ///<param name="AIdUser">The identifier of the User.</param>
  TCreate_Users_Group_User=function(const AIdUsersGroup: Integer=0; const AIdUser: Integer=0): TRM_Users_Group_User; stdcall;
  {$ENDREGION}

  {$REGION 'U_User'}
  ///<summary>Class storing the information concerning a given user.</summary>
  TRM_User=class(TRM_LObject)
  public
    ///<summary>Setter for the variable "fLast_change_Password_Date".</summary>
    ///<summary>The date of the last change of password of the User.</summary>
    procedure Set_Last_change_Password_Date(const ADate: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fLast_change_Password_Date".</summary>
    ///<summary>The date of the last change of password of the User.</summary>
    function Get_Last_change_Password_Date: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iDuration_Password_Validity".</summary>
    ///<summary>The number of days of the password validity.</summary>
    procedure Set_Duration_password_validity(const ADuration: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iDuration_Password_Validity".</summary>
    ///<summary>The number of days of the password validity.</summary>
    function Get_Duration_Password_Validity: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fAccount_Expiration_Date".</summary>
    ///<summary>A fixed date beyond which the account is no longer valid.</summary>
    procedure Set_Account_Expiration_Date(const ADate: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fAccount_Expiration_Date".</summary>
    ///<summary>A fixed date beyond which the account is no longer valid.</summary>
    function Get_Account_Expiration_Date: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fLast_Connection_Date".</summary>
    ///<summary>The date of the last connection of the User.</summary>
    procedure Set_Last_Connection_Date(const ALast_Connection_Date: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fLast_Connection_Date".</summary>
    ///<summary>The date of the last connection of the User.</summary>
    function Get_Last_Connection_Date: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object associated with the User.</summary>
    procedure Set_ID_Object(const AID_Object: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object associated with the User.</summary>
    function Get_ID_Object: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPassword".</summary>
    ///<summary>The password associated with the login.</summary>
    procedure Set_Password(const APassword: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPassword".</summary>
    ///<summary>The password associated with the login.</summary>
    function Get_Password: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bBlocked".</summary>
    ///<summary>If true, the account is not usable.</summary>
    procedure Set_Blocked(const ABlocked: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bBlocked".</summary>
    ///<summary>If true, the account is not usable.</summary>
    function Get_Blocked: Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning true if the user has the right to use a given functionality.</summary>
    ///<param name="AFunction_Right">The function right to test.</param>
    function GetFunctionRight(const AFunction_Right: TFunction_Right): Boolean; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a user, reading its informations from the database.</summary>
  ///<summary>If the given identifier is null, the function uses the default constructor.</summary>
  ///<param name="AID_User">The identifier of the user.</param>
  TCreate_User=function(const AID_User: Integer=0): TRM_User; stdcall;

  ///<summary>Function creating the list of users.</summary>
  ///<param name="AInclude_Disabled_Users">If true, disabled/blocked are also read.</param>
  TCreate_OL_User=function(const AInclude_Disabled_Users: Boolean): TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Users_Group'}
  ///<summary>Types of Users Group.</summary>
  TUsers_Group_Type=(
    ///<summary>Standard.</summary>
    ugtStandard,
    ///<summary>Linked to a User: The Users does only contains one User and is not deletable manually.</summary>
    ugtUser,
    ///<summary>Business Users Group: see the specifications.</summary>
    ugtBusiness);

  ///<summary>Class storing the informations concerning a given Users Group.</summary>
  TRM_Users_Group=class(TRM_LObject)
  public
    function GetConceptRightsDictionary(const ADataType: Integer): TObjectDictionary<Integer,TRM_Right>; virtual; stdcall; abstract;
    function GetRightsDictionary: TObjectDictionary<Integer,TObjectDictionary<Integer,TRM_Right>>; virtual; stdcall; abstract;
    ///<summary>Procedure reading the Objects Rights from the database.</summary>
    procedure LoadObjectsRights; virtual; stdcall; abstract;
    function SetObjectsRights(const AIdObjectType: Integer; const ARight: TDB_Right): Boolean; virtual; stdcall; abstract;
    procedure SetType(const AType: TUsers_Group_Type); virtual; stdcall; abstract;
    function GetType: TUsers_Group_Type; virtual; stdcall; abstract;
    procedure SetIdUser(const AIdUser: Integer); virtual; stdcall; abstract;
    function GetIdUser: Integer; virtual; stdcall; abstract;
    ///<summary>Procedure setting the identifier of the Object Type of a business Users Group.</summary>
    ///<values>The function also add a "read" right to this Object Type.</values>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    procedure Set_ID_OT(const AIdObjectType: Integer); virtual; stdcall; abstract;
    ///<summary>Function returning the root Object Type of a Users Group. If not a business Users Group, the function returns 0.</summary>
    function Get_ID_OT: Integer; virtual; stdcall; abstract;
    procedure SetAttributesSet(const AAttributesSet: TS_Attribute_Set); virtual; stdcall; abstract;
    function GetAttributesSet: TS_Attribute_Set; virtual; stdcall; abstract;
    ///<summary>Function returning the TRM_Object_Type object of a given Object Type for this Group.</summary>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    ///<param name="ACreateIfNeeded">If true, the function creates a TRM_Object_Type object if none is found and set the right to "dbrNone".</param>
    function GetObjectTypeRightObject(const AIdObjectType: Integer; const ACreateIfNeeded: Boolean=True): TRM_Object_Type; virtual; stdcall; abstract;
    ///<summary>Function returning the right of a given Object Type for this Group.</summary>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    function GetObjectTypeRight(const AIdObjectType: Integer): TDB_Right; virtual; stdcall; abstract;
    ///<summary>Function trying to assign a given right to a given Object Type for this Group.</summary>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    ///<param name="ARight">The right to assign.</param>
    ///<returns>The function returns true if the right was successfully assigned.</returns>
    function SetObjectTypeRight(const AIdObjectType: Integer; const ARight: TDB_Right): Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning the TRM_Object object of a given concept for this Group.</summary>
    ///<param name="ADataType">The concept's data type.</param>
    ///<param name="AIdConcept">The identifier of the concept.</param>
    ///<param name="AIdObjectType">The identifier of the Object Type owning the concept.</param>
    ///<param name="ACreateIfNeeded">If true, the function creates a TRM_Right object if none is found and set the right to "dbrNone".</param>
    function GetConceptRightObject(const ADataType: Integer; const AIdConcept: Integer; const AIdObjectType: Integer; const ACreateIfNeeded: Boolean=True): TRM_Right; virtual; stdcall; abstract;
    ///<summary>Function returning the right of a given concept for this Group.</summary>
    ///<param name="ADataType">The concept's data type.</param>
    ///<param name="AIdConcept">The identifier of the concept.</param>
    ///<param name="AIdObjectType">The identifier of the Object Type owning the concept.</param>
    function GetConceptRight(const ADataType: Integer; const AIdConcept: Integer; const AIdObjectType: Integer): TDB_Right; virtual; stdcall; abstract;
    ///<summary>Function trying to assign a given right to a given concept for this Group.</summary>
    ///<param name="ADataType">The concept's data type.</param>
    ///<param name="AIdConcept">The identifier of the concept.</param>
    ///<param name="AIdObjectType">The identifier of the Object Type owning the concept.</param>
    ///<param name="ARight">The right to assign.</param>
    ///<returns>The function returns true if the right was successfully assigned.</returns>
    function SetConceptRight(const ADataType: Integer; const AIdConcept: Integer; const AIdObjectType: Integer; const ARight: TDB_Right): Boolean; virtual; stdcall; abstract;
    function GetFunctionRight(const AFunctionight: TFunction_Right): Boolean; virtual; stdcall; abstract;
    procedure SetFunctionRights(const AFunctionRights: TFunction_Rights); virtual; stdcall; abstract;
    function GetFunctionRights: TFunction_Rights; virtual; stdcall; abstract;
    ///<summary>Procedure adding a functioning right to the Users Group.</summary>
    ///<param name="AFunctionRight">The functioning right to add.</param>
    procedure AddFunctionRight(const AFunctionRight: TFunction_Right); virtual; stdcall; abstract;
    ///<summary>Procedure removing a functioning right to the Users Group.</summary>
    ///<param name="AFunctionRight">The functioning right to remove.</param>
    procedure RemoveFunctionRight(const AFunctionRight: TFunction_Right); virtual; stdcall; abstract;
    function GetOlUsersGroupUser: TObjectList; virtual; stdcall; abstract;
    ///<summary>Procedure adding a user to the Users Group.</summary>
    ///<param name="AIdUser">The identifier of the User to add.</param>
    function AddUser(const AIdUser: Integer): TRM_Users_Group_User; virtual; stdcall; abstract;
    ///<summary>Procedure removing a user to the Users Group.</summary>
    ///<param name="AIdUser">The identifier of the User to remove.</param>
    ///<param name="AAffectDatabase">If true, the TRM_Users_Group_User is kept and written when the Users Group is written. In the other case, the object is removed: the deletion in the database must be done "elsewhere".</param>
    procedure RemoveUser(const AIdUser: Integer; const AAffectDatabase: Boolean=True); virtual; stdcall; abstract;
    ///<summary>Function returning true if a User belongs to the Users Group.</summary>
    ///<param name="AIdUser">The identifier of the User.</param>
    function OwnsUser(const AIdUser: Integer): Boolean; virtual; stdcall; abstract;
    function GetNbUsers: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning true if the Users Group is a business Users Group and the given Object Type is part of its Attribute Set.</summary>
    ///<values>The function does not take into account the "root" Object Type.</values>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    function IsBusinessObjectType(const AIdObjectType: Integer): Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning true if the Users Group is a business Users Group and the given Object Type is usable in the Attribute Set.</summary>
    ///<values>Small exeception: the function returns "false" if the given Object Type is the root Object Type of the Business Users Group whereas it can be used in the Attribute Set (there is no such restriction).</values>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    function IsObjectTypeLinkable(const AIdObjectType: Integer): Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning true if the Users Group is a business Users Group and the given Attribute is used in the Attribute Set.</summary>
    ///<param name="AIdAttribute">The identifier of the Attribute.</param>
    function isBusinessAttribute(const AIdAttribute: Integer): Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning the TRM_Users_Group_User of a given User.</summary>
    ///<param name="AIdUser">The identifier of the User.</param>
    ///<returns>The function returns a nil value if the User does not belong to the Users Group.</returns>
    function GetUsersGroupUser(const AIdUser: Integer): TRM_Users_Group_User; virtual; stdcall; abstract;
    ///<summary>Function returning true if the list of Object's rights is loaded.</summary>
    function IsObjectsRightsLoaded: Boolean; virtual; stdcall; abstract;
    procedure SetAssignToNewUsers(const AAssignToNewUsers: Boolean); virtual; stdcall; abstract;
    function GetAssignToNewUsers: Boolean; virtual; stdcall; abstract;
    ///<summary>Procedure defining the rights for the linked Objects of the Group (supposed to be a business Users Group).</summary>
    procedure DefineLkdObjectsRights; virtual; stdcall; abstract;
    ///<summary>Function duplicating the current Users Group. It is more evoluated than the copy function: it searches for a unique login, load the objects rights (to avoid bugs).</summary>
    function Duplicate: TRM_Users_Group; virtual; stdcall; abstract;
    function ObjectTypeToOtherConceptRight(const AObjectTypeRight: TDB_Right; const ADataType: Integer): TDB_Right; overload; virtual; stdcall; abstract;
    ///<summary>Function returning true if the actual user can modify rights of the capabilities</summary>
    function ObjectTypeToOtherConceptRight(const AIdObjectType: Integer; const ADataType: Integer): TDB_Right; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the "natural" Attributes right for a given Object Type.</summary>
    ///<param name="AIdObjectType">The identifier of the Objects Type.</param>
    function ObjectTypeToAttributeRight(const AIdObjectType: Integer): TDB_Right; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the "natural" Object right for a given Object Type.</summary>
    ///<param name="AIdObjectType">The identifier of the Objects Type.</param>
    function ObjectTypeToObjectRight(const AIdObjectType: Integer): TDB_Right; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the "natural" Attributes right for a given Object Type.</summary>
    ///<param name="AObjectTypeRight">The Object Type right.</param>
    function ObjectTypeToAttributeRight(const AObjectTypeRight: TDB_Right): TDB_Right; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the "natural" Object right for a given Object Type.</summary>
    ///<param name="AObjectTypeRight">The Object Type right.</param>
    function ObjectTypeToObjectRight(const AObjectTypeRight: TDB_Right): TDB_Right; overload; virtual; stdcall; abstract;
    function IsContributor: Boolean; virtual; stdcall; abstract;
    function IsAdministrator: Boolean; virtual; stdcall; abstract;
  end;

  TCreate_Users_Group=function(const AType: TUsers_Group_Type): TRM_Users_Group; stdcall;
  {$ENDREGION}

  {$REGION 'U_Users_Manager'}
  ///<summary>Function creating the list of "user" users group.</summary>
  TCreateOlSpecificUsersGroup=function: TObjectList; stdcall;

  ///<summary>Function loading the Users Group visible by the current User.</summary>
  TLoad_Users_Groups=procedure; stdcall;

  ///<summary>Function testing the binding between a given User and a given Group.</summary>
  ///<param name="AIdUser">The identifier of the User.</param>
  ///<param name="AIdUsersGroup">The identifier of the Users Group.</param>
  TTest_Binding_Between_User_And_Users_Group=function(const AIdUser: Integer; const AIdUsersGroup: Integer): Boolean; stdcall;

  ///<summary>Function generating a very simple password from the Object name associated to the User.</summary>
  ///<values>The password is made of five time the first letter of the User's name.</values>
  ///<param name="AObjectName">The name of the User.</param>
  TGet_Generated_Password=function(const AObjectName: string): string; stdcall;

  ///<summary>Function returning true if the password is considered as strong enough. read the specifications for the rules.</summary>
  ///<param name="APassword">The password to check.</param>
  TCheck_Password_Policy=function(const APassword: string): Boolean; stdcall;

  ///<summary>Function returning a User's pasword expiration date from its identifier.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  TGet_User_Expiration_Date=function(const AIdUser: Integer): Double; stdcall;

  ///<summary>Function returning a User's password duration (in month) from its identifier.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  TGet_User_Duration_Password_Validity=function(const AIdUser: Integer): Integer; stdcall;

  ///<summary>Function returning a User's pasword change date from its identifier.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  TGet_User_Password_Last_Change_Date=function(const AIdUser: Integer): Double; stdcall;

  ///<summary>Function returning a User's name from its identifier.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_User_Name=function(const AIdUser: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the number of Users Groups of a given user.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  TGet_User_Nb_UG=function(const AIdUser: Integer): Integer; stdcall;

  ///<summary>Function returning an User's identifier from its Object's identifier.</summary>
  ///<param name="AIdObject">The identifier of the Object linked to the User.</param>
  TGet_ID_User_From_ID_Object=function(const AIdObject: Integer): Integer; stdcall;

  ///<summary>Function returning an Object's identifier associated to a User.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  TGet_User_ID_Object=function(const AIdUser: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of a User from its login.</summary>
  ///<param name="ALogin">The login of the User.</param>
  TGet_ID_User_From_Login=function(const ALogin: string): Integer; stdcall;

  ///<summary>Function returning the identifier of a User from its object's name.</summary>
  ///<param name="AObjectName">The name of the Object linked to the User.</param>
  TGet_ID_User_From_Name=function(const AObjectName: string): Integer; stdcall;

  ///<summary>Function returning a User's login from its identifier.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  TGet_User_Login=function(const AIdUser: Integer): string; stdcall;

  ///<summary>Function returning the login of a User from its object's name.</summary>
  ///<param name="AObjectName">The name of the Object linked to the User.</param>
  TGet_User_Login_From_Name=function(const AObjectName: string): string; stdcall;

  ///<summary>Function returning the date of last connection of a User.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  TGet_User_Date_Last_Connection=function(const AIdUser: Integer): Double; stdcall;

  ///<summary>Function returning a Users Group identifier from its login.</summary>
  ///<param name="ALogin">The login of the Users Group.</param>
  TGet_ID_Users_Group_From_Login=function(const ALogin: string): Integer; stdcall;

  ///<summary>Function returning the identifier of a Users Group thanks to its name.</summary>
  ///<param name="AName">The name of the Users Group.</param>
  TGet_ID_Users_Group_From_Name=function(const AName: string): Integer; stdcall;

  ///<summary>Function creating a user group into the database and returning its identifier.</summary>
  ///<values>If the name is already used by an existing Groupe, the function raises an EUser_Group_Already_Existing error.</values>
  ///<param name="AName">The name of the new Users Group.</param>
  TWrite_New_Users_Group=function(const AName: string): Integer; stdcall;

  ///<summary>Function returning a unique Users Group login built from a given name.</summary>
  ///<param name="AName">The name of the Users Group.</param>
  TGet_Unique_Login=function(const AName: string): string; stdcall;

  ///<summary>Function returning a unique Users Group name built from a given name.</summary>
  ///<summary>The condition is on both the RM_Users_Group AND RM_User table.</summary>
  ///<param name="AName">The proposed name.</param>
  TGet_Unique_Users_Group_Name=function(const AName: string): string; stdcall;

  ///<summary>Function returning the identifier of the Users Group associated to a given User.</summary>
  ///<values>In case of the Administrator, the function returns 1 even if the Administration Users Group is not a "real" User's Users Group.</values>
  ///<param name="AIdUser">The identifier of the User.</param>
  TGet_ID_Users_Group_From_User=function(const AIdUser: Integer): Integer; stdcall;

  ///<summary>Function Binding a User and a Users Group.</summary>
  ///<param name="AIdUsersGroup">The identifier of the Users Group.</param>
  ///<param name="AIdUser">The identifier of the User.</param>
  ///<returns>The function returns 1 if the user was effectively added.</returns>
  TAdd_User_To_Users_Group=function(const AIdUsersGroup: Integer; AIdUser: Integer): Integer; stdcall;

  ///<summary>Function unbinding a User and a Users Group.</summary>
  ///<param name="AIdUsersGroup">The identifier of the Users Group.</param>
  ///<param name="AIdUser">The identifier of the User.</param>
  TRemove_User_From_Users_Group=procedure(const AIdUsersGroup: Integer; const AIdUser: Integer); stdcall;

  ///<summary>Function creating (if not existing) a User into TEEXMA and returning its identifier.</summary>
  ///<summary>If the User already exists, its profile and existing associations with Users Groups are preserved.</summary>
  ///<param name="AName">The name of the User.</param>
  ///<param name="AUserCanModifyItsProfile">If true, the new User is given a "Write" access to its profile. Btw, this right is limited: the user must also be given a "Write" access to the Attributes of its profile. This can be done via the parameter "AArrIdUsersGroup".</param>
  ///<param name="AArrIdUsersGroup">Array containing Users Groups identifiers the User must be bound with. Theses groups may for example allow the User to modify some of the Attributes of its profile.</param>
  ///<param name="AAccountExpirationDate">The date of expiracy of the account.</param>
  ///<param name="ALogin">The login of the user to create. If empty, a default login is assigned built from the object name.</param>
  TWrite_New_UserExt=function(const AName: string; const AUserCanModifyItsProfile: Boolean; const AArrIdUsersGroup: array of Integer; const ALogin: string=''; const AAccountExpirationDate: Double=5.479e+04): Integer; stdcall;

  ///<summary>Function creating (if not existing) a User into TEEXMA and returning its identifier.</summary>
  ///<summary>If the User already exists, its profile and existing associations with Users Groups are preserved.</summary>
  ///<param name="AName">The name of the User.</param>
  ///<param name="AUserCanModifyItsProfile">If true, the new User is given a "Write" access to its profile. Btw, this right is limited: the user must also be given a "Write" access to the Attributes of its profile. This can be done via the parameter "AArrIdUsersGroup".</param>
  ///<param name="AArrIdUsersGroup">Array containing Users Groups identifiers the User must be bound with. Theses groups may for example allow the User to modify some of the Attributes of its profile.</param>
  TWrite_New_User=function(const AName: string; const AUserCanModifyItsProfile: Boolean; const AArrIdUsersGroup: array of Integer): Integer; stdcall;

  ///<summary>Procedure assigning/modifying the right of a given Object for a given Users Group. The procedure does not care if the User has the right on the Object Type or not.</summary>
  ///<values>This function must be used carefully. It should be reserved to the management of Users personnal rights.</values>
  ///<param name="AIdUsersGroup">The identifier of the Users Group. Note: to retrieve the personnal Users Group of a User, use the function Get_ID_Users_Group_From_User.</param>
  ///<param name="AIdObject">The identifier of the Object.</param>
  ///<param name="ARight">The right to assign.</param>
  TUpdate_Users_Group_Object_Right=procedure(const AIdUsersGroup: Integer; const AIdObject: Integer; const ARight: TDB_Right); stdcall;

  ///<summary>procedure removing the specific right given to users on a given Object</summary>
  TRemove_Users_Specific_Rights_On_Object=procedure(const AIdObject: Integer); stdcall;

  ///<summary>Function returning the list of Users Group loaded.</summary>
  TGet_OL_Users_Group=function: TObjectList; stdcall;

  ///<summary>Function returning the password of a given user.</summary>
  ///<param name="AIdUser">The user ID.</param>
  TGet_User_Password=function(const AIdUser: Integer): string; stdcall;

  ///<summary>Procedure updating the password of a given user.</summary>
  ///<summary>The function may raise an EPassword_Policy exception if the password does not respect the password policy.</summary>
  ///<summary>This function is not designed to be used into a massive treatment.</summary>
  ///<param name="AIdUser">The identifier of the user.</param>
  ///<param name="ANewPassword">The new password.</param>
  TUpdate_User_Password=procedure(const AIdUser: Integer; const ANewPassword: string); stdcall;

  ///<summary>Function returning the icon index of the "Users" Object Type.</summary>
  TGet_User_Icon=function: Integer; stdcall;

  ///<summary>Function returning a given Users Group from its identifier. The search is made in the list of loaded Users Group.</summary>
  ///<param name="AIdUsersGroup">The identifier of the Users Group.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Users_Group=function(const AIdUsersGroup: Integer; const ARaiseException: Boolean=True): TRM_Users_Group; stdcall;

  ///<summary>Function the name of a given Users Group. The search is made in the list of loaded Users Group.</summary>
  ///<param name="AIdUsersGroup">The identifier of the Users Group.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Users_Group_Name=function(const AIdUsersGroup: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Procedure removing the rights on a given Object to all specific Users Groups.</summary>
  TRemove_Object_Specific_Rights=procedure(const AIdObject: Integer); stdcall;

  ///<summary>Procedure removing the rights on a given Object to all standard and business Users Groups.</summary>
  TRemove_Object_Standard_Rights=procedure(const AIdObject: Integer); stdcall;

  TRemoveUnrelevantUsersGroups=function: Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Unit'}
  ///<summary>Class containing the informations concerning a unit.</summary>
  TS_Unit=class(TTree_Object);

  ///<summary>Class containing the informations enabling to convert a value from a unit to another with a linear conversion relationship.</summary>
  TS_Conversion=class(TNamed_Object)
  public
    ///<summary>Setter for the variable "ID_Unit_Src".</summary>
    ///<summary>The identifier of the source unit.</summary>
    procedure Set_ID_Unit_Src(const AID_Unit_Src: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Unit_Src".</summary>
    ///<summary>The identifier of the source unit.</summary>
    function Get_ID_Unit_Src: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Unit_Dest".</summary>
    ///<summary>The identifier of the destination unit</summary>
    procedure Set_ID_Unit_Dest(const AID_Unit_Dest: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Unit_Dest".</summary>
    ///<summary>The identifier of the destination unit</summary>
    function Get_ID_Unit_Dest: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fA".</summary>
    ///<summary>Value(Unit_Dest) = fA x Value(Unit_Src) + fB</summary>
    procedure Set_A(const AA: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fA".</summary>
    ///<summary>Value(Unit_Dest) = fA x Value(Unit_Src) + fB</summary>
    function Get_A: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fB".</summary>
    ///<summary>Value(Unit_Dest) = fA x Value(Unit_Src) + fB</summary>
    procedure Set_B(const AB: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fB".</summary>
    ///<summary>Value(Unit_Dest) = fA x Value(Unit_Src) + fB</summary>
    function Get_B: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the value converted from a given unit to another unit.</summary>
    ///<summary>The units must be those handled by the object.</summary>
    ///<param name="AValue">The value to convert.</param>
    ///<param name="AID_Unit_From">The identifier of the unit of the value to convert.</param>
    ///<param name="AID_Unit_To">The identifier of the destination unit.</param>
    function Convert_Value(const AValue: Double; const AID_Unit_From: Integer; const AID_Unit_To: Integer): Double; virtual; stdcall; abstract;
    ///<summary>Function returning a delta of values converted from a given unit to another unit.</summary>
    ///<summary>The units must be those handled by the object.</summary>
    ///<param name="ADelta">The delta of values to convert.</param>
    ///<param name="AID_Unit_From">The identifier of the unit of the value to convert.</param>
    ///<param name="AID_Unit_To">The identifier of the destination unit.</param>
    function Convert_DValue(const ADelta: Double; const AID_Unit_From: Integer; const AID_Unit_To: Integer): Double; virtual; stdcall; abstract;
  end;

  ///<summary>Function returning a TS_Conversion object, created with the default constructor.</summary>
  TCreate_Conversion=function: TS_Conversion; stdcall;

  ///<summary>Function returning a TS_Unit object, created with the default constructor.</summary>
  TCreate_Unit=function: TS_Unit; stdcall;
  {$ENDREGION}

  {$REGION 'U_File_Type'}
  ///<summary>Listing of File Index types.</summary>
  TFile_Index_Type=(
    ///No index
    fitNone,
    ///An index specific to the file type
    fitFile_Type,
    ///A global index
    fitGlobal);

  ///<summary>Class containing the information on file Type.</summary>
  TS_File_Type=class(TNamed_Object)
  public
    ///<summary>Getter for the variable "sBase_Name".</summary>
    ///<summary>The generic name of the files.</summary>
    function Get_Base_Name: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sBase_Name".</summary>
    ///<summary>The generic name of the files.</summary>
    procedure Set_Base_Name(const ABase_Name: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bBase_Name_Modifiable".</summary>
    ///<summary>If true, users can modify the generic name of the file.</summary>
    function Get_Base_Name_Modifiable: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bBase_Name_Modifiable".</summary>
    ///<summary>If true, users can modify the generic name of the file.</summary>
    procedure Set_Base_Name_Modifiable(const ABase_Name_Modifiable: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bIndex_Modifiable".</summary>
    ///<summary>If true, users can modify the default index assigned to the file.</summary>
    function Get_Index_Modifiable: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bIndex_Modifiable".</summary>
    ///<summary>If true, users can modify the default index assigned to the file.</summary>
    procedure Set_Index_Modifiable(const AIndex_Modifiable: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iFile_Index_Type".</summary>
    ///<summary>iFile_Index_Type: TFile_Index_Type - the index type of the file type (none, globale, aso).</summary>
    function Get_File_Index_Type: TFile_Index_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iFile_Index_Type".</summary>
    ///<summary>iFile_Index_Type: TFile_Index_Type - the index type of the file type (none, globale, aso).</summary>
    procedure Set_File_Index_Type(const AFile_Index_Type: TFile_Index_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bVersion".</summary>
    ///<summary>bVersion: boolean - if true, the file may be versionned. </summary>
    function Get_Version: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bVersion".</summary>
    ///<summary>bVersion: boolean - if true, the file may be versionned. </summary>
    procedure Set_Version(const AVersion: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDate_File".</summary>
    ///<summary>bDate_File: boolean - if true, the current date is added to the file name.</summary>
    function Get_Date_File: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDate_File".</summary>
    ///<summary>bDate_File: boolean - if true, the current date is added to the file name.</summary>
    procedure Set_Date_File(const ADate_File: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sRDir".</summary>
    ///<summary>The path where to store the files (relative to the "Documents" folder).</summary>
    function Get_RDir: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sRDir".</summary>
    ///<summary>The path where to store the files (relative to the "Documents" folder).</summary>
    procedure Set_RDir(const ADir: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bRead_Only".</summary>
    ///<summary>If true, file stored on a shared zone are copied with the read-only tag.</summary>
    function Get_Read_Only: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bRead_Only".</summary>
    ///<summary>If true, file stored on a shared zone are copied with the read-only tag.</summary>
    procedure Set_Read_Only(const ARead_Only: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sTitle_Index".</summary>
    ///<summary>A string before the index.</summary>
    function Get_Title_Index: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sTitle_Index".</summary>
    ///<summary>A string before the index.</summary>
    procedure Set_Title_Index(const ATitle_Index: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bAlpha_Index".</summary>
    ///<summary>If true, indexes are alphabetical, numerical in the other case.</summary>
    function Get_Alpha_Index: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bAlpha_Index".</summary>
    ///<summary>If true, indexes are alphabetical, numerical in the other case.</summary>
    procedure Set_Alpha_Index(const AAlpha_Index: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sTitle_Version".</summary>
    ///<summary>A string before the version.</summary>
    function Get_Title_Version: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sTitle_Version".</summary>
    ///<summary>A string before the version.</summary>
    procedure Set_Title_Version(const ATitle_Version: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bAlpha_Version".</summary>
    ///<summary>If true, versions are alphabetical, numerical in the other case.</summary>
    function Get_Alpha_Version: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bAlpha_Version".</summary>
    ///<summary>If true, versions are alphabetical, numerical in the other case.</summary>
    procedure Set_Alpha_Version(const AAlpha_Version: Boolean); virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a "File Type" object.</summary>
  TCreate_File_Type=function: TS_File_Type; stdcall;

  ///<summary>Function raising an error if a given File Type is not deletable.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  TCheckIf_File_Type_Deletable=procedure(const AID_File_Type: Integer); stdcall;

  ///<summary>Function returning the number of Archived Files of a given File Type.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  TGet_File_Type_Nb_Archived_Files=function(const AID_File_Type: Integer): Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Table_Type'}
  ///<summary>Enumeration of the grapher type.</summary>
  TGrapher=(
    ///No grapher.
    gNone,
    ///Graphics are generated by an excel configuration file.
    gExcel);

  ///<summary>Class handling the information of a Table Type.</summary>
  TS_Table_Type=class(TTree_Object)
  public
    ///<summary>Setter for the variable "iGrapher".</summary>
    ///<summary>The grapher enabling to generate the curve.</summary>
    procedure Set_Grapher(const AGrapher: TGrapher); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iGrapher".</summary>
    ///<summary>The grapher enabling to generate the curve.</summary>
    function Get_Grapher: TGrapher; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPath_File_Settings".</summary>
    ///<summary>The absolute path to the settings file.</summary>
    procedure Set_Path_File_Settings(const APath_File_Settings: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath_File_Settings".</summary>
    ///<summary>The absolute path to the settings file.</summary>
    function Get_Path_File_Settings: string; virtual; stdcall; abstract;
    function Get_Filename_Settings: string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Series_Type".</summary>
    ///<summary>The list of Series Type of the table Type.</summary>
    function Get_OL_Series_Type: TObjectList; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bMany_Objects_Handled".</summary>
    ///<summary>If true, the settings file is able to handle the drawing of graphics for more than on object (ie table).</summary>
    procedure Set_Many_Objects_Handled(const AMany_Objects_Handled: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bMany_Objects_Handled".</summary>
    ///<summary>If true, the settings file is able to handle the drawing of graphics for more than on object (ie table).</summary>
    function Get_Many_Objects_Handled: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bSuperposed_Objects_Handled".</summary>
    ///<summary>If true, the settings file is able to handle the drawing of graphics with curves from many objects.</summary>
    procedure Set_Superposed_Objects_Handled(const ASuperposed_Objects_Handled: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bSuperposed_Objects_Handled".</summary>
    ///<summary>If true, the settings file is able to handle the drawing of graphics with curves from many objects.</summary>
    function Get_Superposed_Objects_Handled: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bMean_Curve_Handled".</summary>
    ///<summary>If true, the settings file is able to handle the drawing of a "mean" curve.</summary>
    procedure Set_Mean_Curve_Handled(const AMean_Curve_Handled: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bMean_Curve_Handled".</summary>
    ///<summary>If true, the settings file is able to handle the drawing of a "mean" curve.</summary>
    function Get_Mean_Curve_Handled: Boolean; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TS_Table_Type object using the default constructor.</summary>
  TCreate_Table_Type=function: TS_Table_Type; stdcall;
  {$ENDREGION}

  {$REGION 'U_Series_Type'}
  TSeriesTypeType=(
    sttUndefined,
    sttNumerical,
    sttText);

  ///<summary>Class handling the information of a Series Type.</summary>
  TS_Series_Type=class(TTree_Object)
  public
    ///<summary>Setter for the variable "bMultiple".</summary>
    ///<summary>If true, the Series Type only allows numerical values.</summary>
    procedure Set_Multiple(const AMultiple: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bMultiple".</summary>
    ///<summary>If true, the Series Type only allows numerical values.</summary>
    function Get_Multiple: Boolean; virtual; stdcall; abstract;
    procedure Set_ID_Unit(const AID_Unit: Integer); virtual; stdcall; abstract;
    function Get_ID_Unit: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Table_Type(const AID_Table_Type: Integer); virtual; stdcall; abstract;
    function Get_ID_Table_Type: Integer; virtual; stdcall; abstract;
    function GetType: TSeriesTypeType; virtual; stdcall; abstract;
    procedure SetType(const AType: TSeriesTypeType); virtual; stdcall; abstract;
    ///<summary>Function returning "the name of the Series Type [its unit]" (if defined).</summary>
    function Get_Name_Complete: string; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TS_Series_Type object using the default constructor.</summary>
  TCreate_Series_Type=function: TS_Series_Type; stdcall;
  {$ENDREGION}

  {$REGION 'U_NumericalCriterion'}
  ///<summary>Listing of the type of boundaries.</summary>
  TMCS_Bound_Type=(
    ///the boundary type is not defined.
    btUndefined,
    ///The boundary is not part of the criterion's range.
    btExclusive,
    ///The boundary is part of the criterion's range.
    btInclusive);

  ///<summary>Listing of the date criterion type.</summary>
  TMCS_DateCriterionType=(
    ///A fixed date.
    dctFixedDate,
    ///The current date.
    dctCurrentDate);

  ///<summary>&gt;Listing of the numerical criterion types.</summary>
  TMCS_Numerical_Criterion_Type=(
    ///The criterion is not defined.
    nctEmpty,
    ///The data value must lower than the criterion's lower bound value.
    nctLower_Bound,
    ///The data value must higher than the criterion's higher bound value.
    nctUpper_Bound,
    ///The data value must equal to the criterion's value.
    nctEqual_To,
    ///The data value must included into the criterion's range.
    nctRange_Max,
    ///The criterion's range must included into the data value.
    nctRange_Min,
    ///The data value (a range) must have a non null intersection with the criterion's range.
    nctNull_Intersection,
    ///The data value (a range) must have a null intersection with the criterion's range.
    nctNon_Null_Intersection);

  TMCSNumericalCriterion=class(TID_Object)
  public
    procedure SetLowerBoundType(const ALB_Type: TMCS_Bound_Type); virtual; stdcall; abstract;
    function GetLowerBoundType: TMCS_Bound_Type; virtual; stdcall; abstract;
    procedure SetLowerBoundValue(const ALB_Value: Double); virtual; stdcall; abstract;
    function GetLowerBoundValue: Double; virtual; stdcall; abstract;
    procedure SetLowerBoundFuzziness(const ALB_Fuzziness: Double); virtual; stdcall; abstract;
    function GetLowerBoundFuzziness: Double; virtual; stdcall; abstract;
    procedure SetLowerBoundIdUnit(const AID_Unit_LB: Integer); virtual; stdcall; abstract;
    function GetLowerBoundIdUnit: Integer; virtual; stdcall; abstract;
    procedure SetUpperBoundType(const AUB_Type: TMCS_Bound_Type); virtual; stdcall; abstract;
    function GetUpperBoundType: TMCS_Bound_Type; virtual; stdcall; abstract;
    procedure SetUpperBoundValue(const AUB_Value: Double); virtual; stdcall; abstract;
    function GetUpperBoundValue: Double; virtual; stdcall; abstract;
    procedure SetUpperBoundFuzziness(const AUB_Fuzziness: Double); virtual; stdcall; abstract;
    function GetUpperBoundFuzziness: Double; virtual; stdcall; abstract;
    procedure SetUpperBoundIdUnit(const AID_Unit_UB: Integer); virtual; stdcall; abstract;
    function GetUpperBoundIdUnit: Integer; virtual; stdcall; abstract;
    procedure SetNumericalCriterionType(const ANumerical_Criterion_Type: TMCS_Numerical_Criterion_Type); virtual; stdcall; abstract;
    function GetNumericalCriterionType: TMCS_Numerical_Criterion_Type; virtual; stdcall; abstract;
    procedure SetLowerBoundDateCriterionType(const ALBDateCriterionType: TMCS_DateCriterionType); virtual; stdcall; abstract;
    function GetLowerBoundDateCriterionType: TMCS_DateCriterionType; virtual; stdcall; abstract;
    procedure SetUpperBoundDateCriterionType(const AUBDateCriterionType: TMCS_DateCriterionType); virtual; stdcall; abstract;
    function GetUpperBoundDateCriterionType: TMCS_DateCriterionType; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_TableInterpolationCriterion'}
  TMCSTableInterpolationCriterion=class(TMCSNumericalCriterion)
  public
    procedure SetXSeriesValue(const ASeries_X_Value: Double); virtual; stdcall; abstract;
    function GetXSeriesValue: Double; virtual; stdcall; abstract;
    procedure SetIdXSeriesType(const AIdXSeriesType: Integer); virtual; stdcall; abstract;
    function GetIdXSeriesType: Integer; virtual; stdcall; abstract;
    procedure SetIdYSeriesType(const AIdYSeriesType: Integer); virtual; stdcall; abstract;
    function GetIdYSeriesType: Integer; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_TableSubCriterion'}
  TMCSTableSubCriterionType=(
    tsctUndefined,
    tsctTextSearch,
    tsctNumericalCriterion);

  TMCSTableSubCriterion=class(TMCSNumericalCriterion)
  public
    procedure SetSubCritType(const ASubCritType: TMCSTableSubCriterionType); virtual; stdcall; abstract;
    function GetSubCritType: TMCSTableSubCriterionType; virtual; stdcall; abstract;
    procedure SetSearchedValue(const ASearchValue: string); virtual; stdcall; abstract;
    function GetSearchedValue: string; virtual; stdcall; abstract;
    procedure SetIdSeriesType(const AIdSeriesType: Integer); virtual; stdcall; abstract;
    function GetIdSeriesType: Integer; virtual; stdcall; abstract;
    procedure SetValueIndex(const AValueIndex: Integer); virtual; stdcall; abstract;
    function GetValueIndex: Integer; virtual; stdcall; abstract;
  end;

  TMCSTableSubCriterion1=class(TMCSTableSubCriterion);

  TMCSTableSubCriterion2=class(TMCSTableSubCriterion);
  {$ENDREGION}

  {$REGION 'U_TableCriterion'}
  TMCSTableCriterionType=(
    tctUndefined,
    tctInterpolation,
    tctChequerBoard);

  TMCSTableCriterion=class(TID_Object)
  public
    function GetIdAttribute: Integer; virtual; stdcall; abstract;
    procedure SetTableCritType(const ATableCritType: TMCSTableCriterionType); virtual; stdcall; abstract;
    function GetTableCritType: TMCSTableCriterionType; virtual; stdcall; abstract;
    function GetSubCriterion1: TMCSTableSubCriterion1; virtual; stdcall; abstract;
    function GetSubCriterion2: TMCSTableSubCriterion2; virtual; stdcall; abstract;
    function GetInterpolationCriterion: TMCSTableInterpolationCriterion; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Criterion'}
  ///<summary>Listing of the various type of preselection.</summary>
  TMCSPreselectionType=(
    ///Full Object Type.
    ptFullOT,
    ///Manual preselection.
    ptManual_Preselection,
    ///The active User only          0
    ptActiveUser);

  ///<summary>Listing of treatment to apply when the data has no value.</summary>
  TMCSEmptyDataTreatment=(
    ///Uncertain mark: 0..10.
    edtUncertain,
    ///Selected: 10..10.
    edtSelected,
    ///Unselected: 0..0.
    edtUnselected);

  TMCSDataTreatment=(
    ///Expecting a specific value, depending on the type of Data.
    dtSpecificValue,
    ///No specific value, if the object owns a data, it is selected.
    dtSelected,
    ///No specific value, if the object owns a data, it is NOT selected.
    dtNotSelected);

  ///<summary>Listing of the recursivity types.</summary>
  TMCSRecursivityType=(
    ///The recursivity is applied to the preselection only: this allow to increase the preselection only: an object is preselected if it is directly preselected or if one of its linked objects is preselected (directly or recursively).
    rtPreselection,
    ///The recursivity is applied to the selection criteria: an object is selected if it directly selected or if one of its linked objects (via a specific link) is selected.
    rtSelection,
    ///The recursivity is applied both to the preselection and selection.
    rtBoth);

  ///<summary>Listing of the type of optimization's criterion.</summary>
  TMCS_OptimizationCriterionType=(
    ///The optimization type is not defined.
    octUndefined,
    ///The data value must be as low as possible.
    octMinimize,
    ///The data value must be as high as possible.
    octMaximize,
    ///The data value must be as close as possible of a given value.
    octApproach);

  ///<summary>Enumeration of the type of criteria.</summary>
  TMCSCriterionType=(
    ///No type defined.
    ctUndefined,
    ///A preselection criterion (The object the selection must be applied to).
    ctPreselection,
    ///A numerical criterion (date, decimal).
    ctNumerical,
    ///A text criterion (short and long text, url, filename and e-mails).
    ctText,
    ///A criterion on an enumeration.
    ctEnumeration,
    ///A criterion on a boolean Attribute.
    ctBoolean,
    ///A criterion on a link Attribute.
    ctLink,
    ///An (other) preselection criterion on a linked Attribute.
    ctOT_Linked,
    ///a criterion on a table.
    ctTable);

  ///<summary>Listing of the various link criterion types.</summary>
  TMCSLinkCriterionType=(
    ///The criterion is not defined.
    lctUndefined,
    ///The intersection between the linked Objects and those of the criterion preselection must be not be null.
    lctAt_Least_One,
    ///The data must contain a single Object and it must belong to the criterion preselection.
    lctAt_Least_One_Exclusive,
    ///The data must contains all the objects of the criterion preselection.
    lctAll,
    ///The linked Objects and those of the criterion preselection must be the same.
    lctAll_Exclusive,
    ///The data must contain only one object of the criterion preselection.
    lctOnly_One,
    ///???
    lctOnly_One_Exclusive,
    ///The data must contain none of the objects of the criterion preselection.
    lctNone);

  ///<summary>Listing of the boolean criterion types.</summary>
  TMCSBooleanCriterionType=(
    ///The data must be true.
    bctTrue,
    ///The data must be false.
    bctFalse,
    ///The criterion is not defined.
    bctUndefined);

  ///<summary>Class handling the informations contained into the MCS_Criterion table.</summary>
  TMCS_Criterion=class(TOTObject)
  public
    procedure UpdateWeights; virtual; stdcall; abstract;
    procedure Update_Weights; virtual; stdcall; abstract;
    procedure Consolidate; virtual; stdcall; abstract;
    function Build_Name(const ARichText: Boolean=False): string; virtual; stdcall; abstract;
    procedure Set_ID_RL(const AID_RL: Integer); virtual; stdcall; abstract;
    function Get_ID_RL: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Attribute(const AIdAttribute: Integer); virtual; stdcall; abstract;
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    procedure SetCriterionType(const ACriterionType: TMCSCriterionType); virtual; stdcall; abstract;
    function GetCriterionType: TMCSCriterionType; virtual; stdcall; abstract;
    procedure SetLinkCriterionType(const ALinkCriterionType: TMCSLinkCriterionType); virtual; stdcall; abstract;
    function GetLinkCriterionType: TMCSLinkCriterionType; virtual; stdcall; abstract;
    procedure SetBooleanCriterionType(const ABooleanCriterionType: TMCSBooleanCriterionType); overload; virtual; stdcall; abstract;
    procedure SetBooleanCriterionType(const AValue: Boolean); overload; virtual; stdcall; abstract;
    function GetBooleanCriterionType: TMCSBooleanCriterionType; virtual; stdcall; abstract;
    procedure SetOptimizationCriterionType(const AOptimizationCriterionType: TMCS_OptimizationCriterionType); virtual; stdcall; abstract;
    function GetOptimizationCriterionType: TMCS_OptimizationCriterionType; virtual; stdcall; abstract;
    procedure SetOptimizationValue(const AOptimizationValue: Double); virtual; stdcall; abstract;
    function GetOptimizationValue: Double; virtual; stdcall; abstract;
    procedure SetIdUnitOptimization(const AIdUnitOptimization: Integer); virtual; stdcall; abstract;
    function GetIdUnitOptimization: Integer; virtual; stdcall; abstract;
    procedure SetSearchedValue(const ASearchedValue: string); virtual; stdcall; abstract;
    function GetSearchedValue: string; virtual; stdcall; abstract;
    procedure SetWeight(const AWeight: Double); virtual; stdcall; abstract;
    function GetWeight: Double; virtual; stdcall; abstract;
    procedure SetForceCriterion(const AForceCriterion: Boolean); virtual; stdcall; abstract;
    function GetForceCriterion: Boolean; virtual; stdcall; abstract;
    procedure Set_OL_Criterion(const AOlCriterion: TObjectList); virtual; stdcall; abstract;
    function GetOlCriterion(const AReturnPreselectionCriterion: Boolean=False): TObjectList; virtual; stdcall; abstract;
    function GetCriteriaCount: Integer; virtual; stdcall; abstract;
    function RemoveCriterion(const AIdCriterion: Integer): Boolean; overload; virtual; stdcall; abstract;
    function RemoveCriterion(const ACriterion: TMCS_Criterion): Boolean; overload; virtual; stdcall; abstract;
    function GetParentCriterion(const AIdCriterion: Integer): TMCS_Criterion; overload; virtual; stdcall; abstract;
    function GetParentCriterion(const ACriterion: TMCS_Criterion): TMCS_Criterion; overload; virtual; stdcall; abstract;
    function GetCriterion(const AIdCriterion: Integer): TMCS_Criterion; overload; virtual; stdcall; abstract;
    function GetCriterion(const ATag: string): TMCS_Criterion; overload; virtual; stdcall; abstract;
    procedure SetSelectionCriterion(const ASelectionCriterion: Boolean); virtual; stdcall; abstract;
    function GetSelectionCriterion: Boolean; virtual; stdcall; abstract;
    function GetEmptyDataTreatment: TMCSEmptyDataTreatment; virtual; stdcall; abstract;
    procedure SetEmptyDataTreatment(const AEmptyDataTreatment: TMCSEmptyDataTreatment); virtual; stdcall; abstract;
    procedure SetPreselectionCriterionType(const APreselectionType: TMCSPreselectionType); virtual; stdcall; abstract;
    function GetPreselectionCriterionType: TMCSPreselectionType; virtual; stdcall; abstract;
    procedure ClearPreselection; virtual; stdcall; abstract;
    procedure SetPreselection(const ASL_ID_Object_Preselected: TStringList); overload; virtual; stdcall; abstract;
    procedure SetPreselection(const AOL_Object_Preselected: TObjectList); overload; virtual; stdcall; abstract;
    procedure SetPreselection(const AIdObject: Integer); overload; virtual; stdcall; abstract;
    procedure Add_To_Preselection(const AID_Object: Integer); virtual; stdcall; abstract;
    function GetSlIdPreselectedObject: TStringList; virtual; stdcall; abstract;
    procedure SetRecursivityType(const ARecursivity_Type: TMCSRecursivityType); virtual; stdcall; abstract;
    function GetRecursivityType: TMCSRecursivityType; virtual; stdcall; abstract;
    function AddCriterion(const ACriterion: TMCS_Criterion): TMCS_Criterion; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bVisible".</summary>
    ///<summary>If true, the Criterion must be displayed into the advanced results.</summary>-
    procedure Set_Visible(const AVisible: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bVisible".</summary>
    ///<summary>If true, the Criterion must be displayed into the advanced results.</summary>-
    function Get_Visible: Boolean; virtual; stdcall; abstract;
    procedure SetDataTreatment(const ADataTreatment: TMCSDataTreatment); virtual; stdcall; abstract;
    function GetDataTreatment: TMCSDataTreatment; virtual; stdcall; abstract;
    function Get_Expression_Litteraire(const AShift: string; const ARichText: Boolean=True; const AComplete_Version: Boolean=True; const AHTML_Link: Boolean=False): string; virtual; stdcall; abstract;
    procedure AddQuestion(const AIdQuestion: Integer); virtual; stdcall; abstract;
    procedure RemoveQuestion(const AIdQuestion: Integer); virtual; stdcall; abstract;
    function IsRelevantForQuestion(const AIdQuestion: Integer): Boolean; virtual; stdcall; abstract;
    function GetSlIdQuestion_Answered: TStringList; virtual; stdcall; abstract;
    function GetSlIdQuestion: TStringList; virtual; stdcall; abstract;
    function FillOlQuestionCriteria(const AOlCriterion: TObjectList; const AIdQuestion: Integer; AOnlyFirst: Boolean): Boolean; virtual; stdcall; abstract;
    function DefineQuestionAsAnswered(const AIdQuestion: Integer): Boolean; virtual; stdcall; abstract;
    function GetNumericalCriterion: TMCSNumericalCriterion; virtual; stdcall; abstract;
    function GetTableCriterion: TMCSTableCriterion; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating and returning a TMCS_Criterion object.</summary>
  ///<param name="AIdCriterion">The identifier of the Criterion. If not null, the criterion is read from the database.</param>
  TCreate_Criterion=function(const AIdCriterion: Integer=0): TMCS_Criterion; stdcall;

  ///<summary>Procedure enabling to delete a Criterion from the database.</summary>
  ///<param name="AIdCriterion">The identifier of the Criterion.</param>
  ///<param name="AFullyRecursive">If true, child Criteria are read from the database and deleted.</param>
  ///<param name="ACriterionType">The type of the given Criterion.</param>
  TDelete_Criterion=procedure(const AIdCriterion: Integer; const AFullyRecursive: Boolean=True; const ACriterionType: TMCSCriterionType=ctUndefined); stdcall;

  ///<summary>Criterion recursive search function thanks to its identifier.</summary>
  ///<param name="AOlCriterion">The list of criteria.</param>
  ///<param name="AIdCriterion">The identifier of the searched criterion.</param>
  TGet_Criterion=function(const AOlCriterion: TObjectList; const AIdCriterion: Integer): TMCS_Criterion; stdcall;
  {$ENDREGION}

  {$REGION 'U_Requirement_List'}
  ///<summary>Listing of the aggregation function.</summary>
  TMCSAggregationFunction=(
    ///No aggregation function defined.
    afNone,
    ///A geometric mean is used (a very restrictive function).
    afGeometric_Mean,
    ///An arithmetic mean is used.
    afArithmetic_Mean,
    ///The maximum mark is used.
    afMaximum_Score);

  ///<summary>Listing of the requirement list types./</summary>
  TMCSRequirementListType=(
    ///A standard Requirements List directly executable by the User.
    rltStandard,
    ///A Requirements List belonging to a Choice Guide.
    rltChoice_Guide,
    ///A Requirements List belonging to a Question.
    rltQuestion,
    ///Not defined (former Answer).
    rltSystem,
    ///A Requirements list belonging to an Exportation.
    rltExportation);

  ///<summary>Class handling the informations contained into the MCS_Requirement_List table.</summary>
  TMCS_Requirement_List=class(TOTObject)
  public
    ///<summary>This procedure removes all selection criteria and sub requirements lists. It also resets the preselection criterion to "all objects".</summary>
    ///<values>The procedure keeps the criteria and sub requirements lists if written in the database but their action is set to dbadel.</values>
    procedure Clear; virtual; stdcall; abstract;
    ///<summary>This procedure removes all criteria.</summary>
    ///<values>The procedure keeps the criteria if written in the database but their action is set to dbadel.</values>
    procedure RemoveCriteria; virtual; stdcall; abstract;
    procedure SetAggregationFunction(const AAggregation_Function: TMCSAggregationFunction); virtual; stdcall; abstract;
    function GetAggregationFunction: TMCSAggregationFunction; virtual; stdcall; abstract;
    procedure SetWeight(const AWeight: Double); virtual; stdcall; abstract;
    function GetWeight: Double; virtual; stdcall; abstract;
    procedure SetRequirementListType(const ARequirement_List_Type: TMCSRequirementListType); virtual; stdcall; abstract;
    function GetRequirementListType: TMCSRequirementListType; virtual; stdcall; abstract;
    procedure SetPreselectionCriterion(ACriterion: TMCS_Criterion); virtual; stdcall; abstract;
    function GetPreselectionCriterion: TMCS_Criterion; virtual; stdcall; abstract;
    procedure SetIdOwnerRequirementsList(const AID_Requirement_List_Owner: Integer); virtual; stdcall; abstract;
    function GetIdOwnerRequirementsList: Integer; virtual; stdcall; abstract;
    function GetOlCriterion: TObjectList; virtual; stdcall; abstract;
    procedure AddCriterion(ACriterion: TMCS_Criterion); virtual; stdcall; abstract;
    function RemoveCriterion(const ACriterion: TMCS_Criterion): Boolean; overload; virtual; stdcall; abstract;
    function RemoveCriterion(const AIdCriterion: Integer): Boolean; overload; virtual; stdcall; abstract;
    function GetCriterion(const AIdCriterion: Integer; const ARaiseException: Boolean): TMCS_Criterion; overload; virtual; stdcall; abstract;
    function GetCriterion(const ATag: string; const ARaiseException: Boolean): TMCS_Criterion; overload; virtual; stdcall; abstract;
    function GetParentCriterion(const AIdCriterion: Integer): TMCS_Criterion; overload; virtual; stdcall; abstract;
    function GetParentCriterion(const ACriterion: TMCS_Criterion): TMCS_Criterion; overload; virtual; stdcall; abstract;
    function AddSubRequirementsList(const AName: string): TMCS_Requirement_List; overload; virtual; stdcall; abstract;
    function AddSubRequirementsList(const ARL: TMCS_Requirement_List): TMCS_Requirement_List; overload; virtual; stdcall; abstract;
    function GetOlSubRequirementsList: TObjectList; virtual; stdcall; abstract;
    function GetSubRequirementsList(const AIdSubRequirementsList: Integer): TMCS_Requirement_List; virtual; stdcall; abstract;
    function RemoveSubRequirementsList(const ASubRequirementsList: TMCS_Requirement_List): Boolean; overload; virtual; stdcall; abstract;
    function RemoveSubRequirementsList(const AIdSubRequirementsList: Integer): Boolean; overload; virtual; stdcall; abstract;
    procedure SetIdChoiceGuide(const AID_Choice_Guide: Integer); virtual; stdcall; abstract;
    function Get_ID_Choice_Guide: Integer; virtual; stdcall; abstract;
    procedure UpdateCriteriaIdQuestion(const AIdQuestion: Integer; const APrevIdQuestion: Integer=0); virtual; stdcall; abstract;
    procedure SetIdQuestion(const AIdQuestion: Integer); virtual; stdcall; abstract;
    function GetIdQuestion: Integer; virtual; stdcall; abstract;
    procedure RemoveQuestion(const AIdQuestion: Integer); virtual; stdcall; abstract;
    function GetQuestionFirstCriterion(const AIdQuestion: Integer): TMCS_Criterion; virtual; stdcall; abstract;
    function ListQuestionCriteria_(const AIdQuestion: Integer): TObjectList; virtual; stdcall; abstract;
    procedure Set_ID_Exportation(const AID_Exportation: Integer); virtual; stdcall; abstract;
    function Get_ID_Exportation: Integer; virtual; stdcall; abstract;
    function Get_Expression_Litteraire(AShift: string; AUse_HTML: Boolean=True; AVerbose: Boolean=True; AUse_HTML_Links: Boolean=False): string; virtual; stdcall; abstract;
    procedure UpdateWeights; virtual; stdcall; abstract;
    procedure Consolidate; virtual; stdcall; abstract;
    procedure UpdatePreselectionCriterion(const AIdCriterion: Integer; const AIdObject: Integer); overload; virtual; stdcall; abstract;
    procedure UpdatePreselectionCriterion(const AIdCriterion: Integer; const ASlIdObject: TStringList); overload; virtual; stdcall; abstract;
    procedure UpdatePreselectionCriterion(const AIdCriterion: Integer; const AOlObject: TObjectList); overload; virtual; stdcall; abstract;
    procedure UpdatePreselectionCriterion_With_Current_User(const AIdCriterion: Integer); overload; virtual; stdcall; abstract;
    procedure UpdateDecimalCriterion(const AIdCriterion: Integer; const ALowerBound: Double; const AUpperBound: Double); virtual; stdcall; abstract;
    procedure UpdateDecimalCriterionWithCurrentDate(const AIdCriterion: Integer); virtual; stdcall; abstract;
    procedure UpdateBooleanCriterion(const AIdCriterion: Integer; const AValue: Boolean); virtual; stdcall; abstract;
    procedure UpdateTextCriterion(const AIdCriterion: Integer; const AValue: string); virtual; stdcall; abstract;
  end;

  ///<summary>Procedure enabling to delete Requirement Lists from the database.</summary>
  ///<param name="AIdConcept">The identifier of the Object.</param>
  ///<param name="ADataType">The identifier of the datatype of the Object.</param>
  ///<param name="AFully_Recursive">If true, child RL are read from the database (if necessary) and deleted.</param>
  ///<param name="AOwner">If true, child RL are not read from the database in case of a fully recursive deletion. Another query is used, much faster.</param>
  TDelete_Requirement_List=procedure(const ADataType: Integer; const AIdConcept: Integer; const AFully_Recursive: Boolean=True; const AOwner: Boolean=False); stdcall;
  {$ENDREGION}

  {$REGION 'U_MCS'}
  ///<summary>Function creating a list of comparable attribute for a given object : all the non empty attributes of type numerical, text or links.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="AID_Object">The identifier of the Object.</param>
  TCreate_OL_Comparable_Attribute=function(const AID_OT: Integer; const AID_Object: Integer): TObjectList; stdcall;

  ///<summary>Criterion recursive search function thanks to its parent's identifier and its attribute.</summary>
  ///<param name="ARequirement_List">The Requirement List to search into.</param>
  ///<param name="AID_Attribute">The identifier of the attribute.</param>
  ///<param name="AID_Parent_Criterion">The identifier of the parent criterion.</param>
  TGet_Criterion_From_Kinship_and_Attribute=function(const ARequirement_List: TMCS_Requirement_List; const AID_Attribute: Integer; const AID_Parent_Criterion: Integer): TMCS_Criterion; stdcall;
  {$ENDREGION}

  {$REGION 'U_Extraction'}
  ///<summary>Extraction types.</summary>
  TExtraction_Type=(
    etWord,
    etExcel,
    etWord_Non_Automatic_Reporting,
    etExcel_Non_Automatic_Reporting);

  ///<summary>PDF conversion options.</summary>
  TPDF_Conversion_Option=(
    pcoNo_Conversion_By_Default,
    pcoConvert_By_Default,
    pcoConversion_Forced);

  ///<summary>Class handling an Extraction. It allows to write settings into the database.</summary>
  TE_Extraction=class(TOTObject)
  public
    ///<summary>Setter for the variable "sPath_File".</summary>
    ///<summary>The path to the extraction model.</summary>
    procedure Set_Path_File(const APath_File: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath_File".</summary>
    ///<summary>The path to the extraction model.</summary>
    function Get_Path_File: string; virtual; stdcall; abstract;
    function Get_Filename: string; virtual; stdcall; abstract;
    function Get_Path_File_Execution: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iExtraction_Type".</summary>
    ///<summary>The extraction type.</summary>
    procedure Set_Extraction_Type(const AExtraction_Type: TExtraction_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iExtraction_Type".</summary>
    ///<summary>The extraction type.</summary>
    function Get_Extraction_Type: TExtraction_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bFill_In_Column".</summary>
    ///<summary>If true (and in case of an excel extraction), objects are put one per column. If false, they are put one per row.</summary>
    procedure Set_Fill_In_Column(const AFill_In_Column: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bFill_In_Column".</summary>
    ///<summary>If true (and in case of an excel extraction), objects are put one per column. If false, they are put one per row.</summary>
    function Get_Fill_In_Column: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sBookmark_OT".</summary>
    ///<summary>In case of a word extraction, the Object Type's bookmark name(s).</summary>
    procedure Set_Bookmark_OT(const ABookmark_OT: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sBookmark_OT".</summary>
    ///<summary>In case of a word extraction, the Object Type's bookmark name(s).</summary>
    function Get_Bookmark_OT: string; virtual; stdcall; abstract;
    procedure Set_Row_OT(const ARow_OT: Integer); virtual; stdcall; abstract;
    function Get_Row_OT: Integer; virtual; stdcall; abstract;
    procedure Set_Col_OT(const ACol_OT: Integer); virtual; stdcall; abstract;
    function Get_Col_OT: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sBookmark_Object".</summary>
    ///<summary>In case of a word extraction, the Object's bookmark name(s).</summary>
    procedure Set_Bookmark_Object(const ABookmark_Object: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sBookmark_Object".</summary>
    ///<summary>In case of a word extraction, the Object's bookmark name(s).</summary>
    function Get_Bookmark_Object: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iRow_Object".</summary>
    ///<summary>In case of an Excel extraction, the row of the Object's cell.</summary>
    procedure Set_Row_Object(const ARow_Object: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iRow_Object".</summary>
    ///<summary>In case of an Excel extraction, the row of the Object's cell.</summary>
    function Get_Row_Object: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iCol_Object".</summary>
    ///<summary>In case of an Excel extraction, the column of the Object's cell.</summary>
    procedure Set_Col_Object(const ACol_Object: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iCol_Object".</summary>
    ///<summary>In case of an Excel extraction, the column of the Object's cell.</summary>
    function Get_Col_Object: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sBookmark_Author".</summary>
    ///<summary>In case of a word extraction, the current user's bookmark name(s).</summary>
    procedure Set_Bookmark_Author(const ABookmark_Author: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sBookmark_Author".</summary>
    ///<summary>In case of a word extraction, the current user's bookmark name(s).</summary>
    function Get_Bookmark_Author: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iRow_Author".</summary>
    ///<summary>In case of an Excel extraction, the row of the current user's cell.</summary>
    procedure Set_Row_Author(const ARow_Author: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iRow_Author".</summary>
    ///<summary>In case of an Excel extraction, the row of the current user's cell.</summary>
    function Get_Row_Author: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iCol_Author".</summary>
    ///<summary>In case of an Excel extraction, the column of the current user's cell.</summary>
    procedure Set_Col_Author(const ACol_Author: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iCol_Author".</summary>
    ///<summary>In case of an Excel extraction, the column of the current user's cell.</summary>
    function Get_Col_Author: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sBookmark_Date".</summary>
    ///<summary>In case of a word extraction, the current date's bookmark name(s).</summary>
    procedure Set_Bookmark_Date(const ABookmark_Date: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sBookmark_Date".</summary>
    ///<summary>In case of a word extraction, the current date's bookmark name(s).</summary>
    function Get_Bookmark_Date: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iRow_Date".</summary>
    ///<summary>In case of an Excel extraction, the row of the current date's cell.</summary>
    procedure Set_Row_Date(const ARow_Date: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iRow_Date".</summary>
    ///<summary>In case of an Excel extraction, the row of the current date's cell.</summary>
    function Get_Row_Date: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iCol_Date".</summary>
    ///<summary>In case of an Excel extraction, the column of the current date's cell.</summary>
    procedure Set_Col_Date(const ACol_Date: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iCol_Date".</summary>
    ///<summary>In case of an Excel extraction, the column of the current date's cell.</summary>
    function Get_Col_Date: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sBookmark_RL".</summary>
    ///<summary>In case of a word extraction, the Requirements List bookmark name(s).</summary>
    procedure Set_Bookmark_RL(const ABookmark_RL: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sBookmark_RL".</summary>
    ///<summary>In case of a word extraction, the Requirements List bookmark name(s).</summary>
    function Get_Bookmark_RL: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iRow_RL".</summary>
    ///<summary>In case of an Excel extraction, the row of the Requirements List cell.</summary>
    procedure Set_Row_RL(const ARow_RL: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iRow_RL".</summary>
    ///<summary>In case of an Excel extraction, the row of the Requirements List cell.</summary>
    function Get_Row_RL: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iCol_RL".</summary>
    ///<summary>In case of an Excel extraction, the column of the Requirements List cell.</summary>
    procedure Set_Col_RL(const ACol_RL: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iCol_RL".</summary>
    ///<summary>In case of an Excel extraction, the column of the Requirements List cell.</summary>
    function Get_Col_RL: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iPDF_Conversion_Option".</summary>
    ///<summary>The PDF status.</summary>
    procedure Set_PDF_Conversion_Option(const APDF_Conversion_Option: TPDF_Conversion_Option); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iPDF_Conversion_Option".</summary>
    ///<summary>The PDF status.</summary>
    function Get_PDF_Conversion_Option: TPDF_Conversion_Option; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute_Report".</summary>
    ///<summary>If higher than 0, the identifier of the Attribute where to publish the file extracted.</summary>
    procedure Set_ID_Attribute_Report(const AID_Attribute_Report: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute_Report".</summary>
    ///<summary>If higher than 0, the identifier of the Attribute where to publish the file extracted.</summary>
    function Get_ID_Attribute_Report: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Library_Model(const AID_Library_Model: Integer); virtual; stdcall; abstract;
    function Get_ID_Library_Model: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bVisible".</summary>
    ///<summary>If true, the extraction is visible in the extraction form.</summary>
    procedure Set_Visible(const AVisible: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bVisible".</summary>
    ///<summary>If true, the extraction is visible in the extraction form.</summary>
    function Get_Visible: Boolean; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Bookmark".</summary>
    ///<summary>The list of Attributes bookmarks of the extraction.</summary>
    function Get_OL_Bookmark: TObjectList; virtual; stdcall; abstract;
    function IsExcel: Boolean; virtual; stdcall; abstract;
    function IsWord: Boolean; virtual; stdcall; abstract;
    function Get_TypeName: string; virtual; stdcall; abstract;
    function Get_FileExt: string; virtual; stdcall; abstract;
    procedure Update_SL_Bookmark; overload; virtual; stdcall; abstract;
    procedure Update_SL_Bookmark(const ASL_Bookmark: TStrings); overload; virtual; stdcall; abstract;
    function Get_SL_Bookmark: TStringList; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating and returning a TE_Extraction Object.</summary>
  TCreate_Extraction=function: TE_Extraction; stdcall;
  {$ENDREGION}

  {$REGION 'U_Bookmark'}
  ///<summary>Separator types for links and list data into a word extraction.</summary>
  TExtraction_Link_Separator=(
    ///Line break
    elsLB,
    ///Semicolon
    elsSemiColon);

  ///<summary>Class handling a given Extraction's bookmark. It allows to write it into the database.</summary>
  TE_Bookmark=class(TTree_Object)
  public
    ///<summary>Setter for the variable "iLink_Separator".</summary>
    ///<summary>The link separator type.</summary>
    procedure Set_Link_Separator(const ALink_Separator: TExtraction_Link_Separator); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iLink_Separator".</summary>
    ///<summary>The link separator type.</summary>
    function Get_Link_Separator: TExtraction_Link_Separator; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bInclude_File_Content".</summary>
    ///<summary>If true, the content of certain files like rtf, doc, pictures files is included into the extracted document.</summary>
    procedure Set_Include_File_Content(const AInclude_File_Content: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bInclude_File_Content".</summary>
    ///<summary>If true, the content of certain files like rtf, doc, pictures files is included into the extracted document.</summary>
    function Get_Include_File_Content: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Extraction".</summary>
    ///<summary>The identifier of the Extraction the bookmark belongs to.</summary>
    procedure Set_ID_Extraction(const AID_Extraction: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Extraction".</summary>
    ///<summary>The identifier of the Extraction the bookmark belongs to.</summary>
    function Get_ID_Extraction: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute of the bookmark.</summary>
    procedure Set_ID_Attribute(const AID_Attribute: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute of the bookmark.</summary>
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iRow".</summary>
    ///<summary>In case of an excel extraction, the row of the cell where to extract the attribute's data.</summary>
    procedure Set_Row(const ARow: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iRow".</summary>
    ///<summary>In case of an excel extraction, the row of the cell where to extract the attribute's data.</summary>
    function Get_Row: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iCol".</summary>
    ///<summary>In case of an excel extraction, the column of the cell where to extract the attribute's data.</summary>
    procedure Set_Col(const ACol: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iCol".</summary>
    ///<summary>In case of an excel extraction, the column of the cell where to extract the attribute's data.</summary>
    function Get_Col: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Extraction_Lkd".</summary>
    ///<summary>If higher than 0, the identifier of the linked extraction in case of link Attribute.</summary>
    procedure Set_ID_Extraction_Lkd(const AID_Extraction_Lkd: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Extraction_Lkd".</summary>
    ///<summary>If higher than 0, the identifier of the linked extraction in case of link Attribute.</summary>
    function Get_ID_Extraction_Lkd: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating and returning a TE_Bookmark Object.</summary>
  TCreate_Bookmark=function: TE_Bookmark; stdcall;
  {$ENDREGION}

  {$REGION 'U_Value'}
  ///<summary>Class handling a numerical value(s) for a couple "Object"/"Atribute".</summary>
  TSt_Value=class(TObject)
  public
    ///<summary>Setter for the variable "fValue".</summary>
    ///<summary>The mean value of the couple.</summary>
    procedure Set_Value(const AValue: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fValue".</summary>
    ///<summary>The mean value of the couple.</summary>
    function Get_Value: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object.</summary>
    procedure Set_ID_Object(const AID_Object: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object.</summary>
    function Get_ID_Object: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute.</summary>
    procedure Set_ID_Attribute(const AID_Attribute: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute.</summary>
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iNb_Values".</summary>
    ///<summary>The number of values of the couple.</summary>
    procedure Set_Nb_Values(const ANb_Values: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iNb_Values".</summary>
    ///<summary>The number of values of the couple.</summary>
    function Get_Nb_Values: Integer; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Statistics'}
  ///<summary>Enumeration of the types of evaluations</summary>
  TEvaluation_Method=(
    ///Data are evaluated by correlations.
    emCorrelation,
    ///Data are evaluated by proximities.
    emProximity,
    ///Data are evaluated by both correlations and proximities.
    emMixed);

  ///<summary>Enumeration of the methods of error evaluations.</summary>
  TError_Evaluation_Method=(
    ///The error evaluation is made on a random sub-selection.
    eemSub_Selection,
    ///The error evaluation is made on the whole selection.
    eemWhole_Selection);

  ///<summary>This class allows to calculate statiscal values for a given Attribute and a set of Objects.</summary>
  ///<values>Values calculated: the percentage of filling, the average, various distribution values (decile, median values, aso.).</values>
  TSt_Statistics=class(TObject)
  public
    ///<summary>Function returning the identifier of the Attribute of the Statistics object.</summary>
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the name of the Statistics object.</summary>
    function Get_Name: string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Value".</summary>
    ///List of TSt_Value value object: all the value for preseletion of object and the attribute.
    ///The list is sorted by data value ascending which enables to easily find the various decile values and objects.
    function Get_OL_Value: TObjectList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Value2".</summary>
    ///List of TSt_Value value object sorted by ID_Object.
    function Get_OL_Value2: TObjectList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "SL_ID_Object_With_Data".</summary>
    ///List of identifiers owning data for the Attribute.
    function Get_SL_ID_Object_With_Data: TStringList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "SL_ID_Object_Without_Data".</summary>
    ///List of identifier not owning data for the Attribute.
    function Get_SL_ID_Object_Without_Data: TStringList; virtual; stdcall; abstract;
    ///<summary>Function returning a short description of the Statistics object.</summary>
    function Get_Hint: string; virtual; stdcall; abstract;
    ///<summary>Function returning a long description of the Statistics object.</summary>
    function Get_Long_Hint: string; virtual; stdcall; abstract;
    ///<summary>Function returning the minimum value.</summary>
    function Get_Min: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the lower decile.</summary>
    function Get_Lower_Decile: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the lower quartile.</summary>
    function Get_Lower_Quartile: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the median value.</summary>
    function Get_Median: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the upper quartile.</summary>
    function Get_Upper_Quartile: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the upper decile.</summary>
    function Get_Upper_Decile: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the maximum value.</summary>
    function Get_Max: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the object name owning the minimum value.</summary>
    function Get_Min_Object_Name: string; virtual; stdcall; abstract;
    ///<summary>Function returning the object name owning the lower decile.</summary>
    function Get_Lower_Decile_Object_Name: string; virtual; stdcall; abstract;
    ///<summary>Function returning the object name owning the lower quartile.</summary>
    function Get_Lower_Quartile_Object_Name: string; virtual; stdcall; abstract;
    ///<summary>Function returning the object name owning the median value.</summary>
    function Get_Median_Object_Name: string; virtual; stdcall; abstract;
    ///<summary>Function returning the object name owning the upper quartile.</summary>
    function Get_Upper_Quartile_Object_Name: string; virtual; stdcall; abstract;
    ///<summary>Function returning the object name owning the upper decile.</summary>
    function Get_Upper_Decile_Object_Name: string; virtual; stdcall; abstract;
    ///<summary>Function returning the object name owning the maximum value.</summary>
    function Get_Max_Object_Name: string; virtual; stdcall; abstract;
    ///<summary>Function returning the standard deviation.</summary>
    function Get_Std_Dev: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the variance.</summary>
    function Get_Variance: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the mean value.</summary>
    function Get_Mean: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the percentage of filling (number of Objects filled / global number of Objects).</summary>
    function Get_Percentage_Filling: Double; virtual; stdcall; abstract;
    ///<summary>Function returning the value of a given Object.</summary>
    ///<param name="AID_Object">The identifier of the Object.</param>
    function Get_Object_Value(AID_Object: Integer): Double; virtual; stdcall; abstract;
    ///<summary>Function calculating the distribution of values and saving the result into a given Directory.</summary>
    ///<values>The function returns the path of the text file created.</values>
    ///<param name="ADirectory">The folder where to save the file.</param>
    function Get_Path_File_Distribution(ADirectory: string): string; virtual; stdcall; abstract;
  end;

  ///<summary>Procedure updating given list of correlations and statistics.</summary>
  TUpdate_OL_Statistics_And_Correlation=procedure(ADirectory: string; ASL_ID_Attribute: TStringList; ASL_ID_Object: TStringList; AOL_Statistics: TObjectList; AOL_Correlation: TObjectList); stdcall;
  {$ENDREGION}

  {$REGION 'U_Correlation'}
  ///Class handling a correlation between two Attributes for a preselection of Objects.
  ///Its calculates the mean values, the correlation mark, the linear regresssion, aso.
  ///It is capable of generating graphics "Attribute 1" vs "Attribute 2" and "Attribute 2" vs "Attribute 1".
  TSt_Correlation=class(TObject)
  public
    procedure Set_Stat1(const AStat1: TSt_Statistics); virtual; stdcall; abstract;
    function Get_Stat1: TSt_Statistics; virtual; stdcall; abstract;
    procedure Set_Stat2(const AStat2: TSt_Statistics); virtual; stdcall; abstract;
    function Get_Stat2: TSt_Statistics; virtual; stdcall; abstract;
    function Get_ID_Attribute1: Integer; virtual; stdcall; abstract;
    function Get_ID_Attribute2: Integer; virtual; stdcall; abstract;
    function Get_Name1: string; virtual; stdcall; abstract;
    function Get_Name2: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fCovariance".</summary>
    ///<summary>The covariance between the two Attributes.</summary>
    procedure Set_Covariance(const ACovariance: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fCovariance".</summary>
    ///<summary>The covariance between the two Attributes.</summary>
    function Get_Covariance: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fCorrelation".</summary>
    ///<summary>The correlation between the two Attributes.</summary>
    procedure Set_Correlation(const ACorrelation: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fCorrelation".</summary>
    ///<summary>The correlation between the two Attributes.</summary>
    function Get_Correlation: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fVariance1".</summary>
    ///<summary>The variance value of the Attribute 1 calculated on the objects owning data for both Attributes.</summary>
    procedure Set_Variance1(const AVariance1: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fVariance1".</summary>
    ///<summary>The variance value of the Attribute 1 calculated on the objects owning data for both Attributes.</summary>
    function Get_Variance1: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fVariance2".</summary>
    ///<summary>The variance value of the Attribute 2 calculated on the objects owning data for both Attributes.</summary>
    procedure Set_Variance2(const AVariance2: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fVariance2".</summary>
    ///<summary>The variance value of the Attribute 2 calculated on the objects owning data for both Attributes.</summary>
    function Get_Variance2: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fMean1".</summary>
    ///<summary>The mean value of the Attribute 1 calculated on the objects owning data for both Attributes.</summary>
    procedure Set_Mean1(const AMean1: Double); virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fMean2".</summary>
    ///<summary>The mean value of the Attribute 2 calculated on the objects owning data for both Attributes.</summary>
    procedure Set_Mean2(const AMean2: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMean1".</summary>
    ///<summary>The mean value of the Attribute 1 calculated on the objects owning data for both Attributes.</summary>
    function Get_Mean1: Double; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMean2".</summary>
    ///<summary>The mean value of the Attribute 2 calculated on the objects owning data for both Attributes.</summary>
    function Get_Mean2: Double; virtual; stdcall; abstract;
    function Get_Mark_Global: Double; virtual; stdcall; abstract;
    function Get_Mark_Correlation: Double; virtual; stdcall; abstract;
    function Get_Mark_Revelancy: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fPercentage_Common".</summary>
    ///<summary>The percentage of objects owning data for the two Attributes.</summary>
    procedure Set_Percentage_Common(const APercentage_Common: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fPercentage_Common".</summary>
    ///<summary>The percentage of objects owning data for the two Attributes.</summary>
    function Get_Percentage_Common: Double; virtual; stdcall; abstract;
    ///<summary>Getter for fA</summary>
    ///<summary>If AInverse = false, it returns fA of the linear equation Attribute_2 = fA x Attribute_2 + fB.</summary>
    ///<summary>If AInverse = true, it returns fA of the linear equation Attribute_1 = fA x Attribute_2 +fB.</summary>
    function Get_A(const AInverse: Boolean=False): Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fA".</summary>
    ///<summary>The A value of the linear regression Attribute_2 = fA x Attribute_1 + fB.</summary>
    procedure Set_A(const AA: Double); virtual; stdcall; abstract;
    ///<summary>Getter for fB</summary>
    ///<summary>If not AInverse, it returns fB of the linear equation Attribute_2 = fA x Attribute_2 + fB.</summary>
    ///<summary>If AInverse, it returns fB of the linear equation Attribute_1 = fA x Attribute_2 +fB.</summary>
    function Get_B(const AInverse: Boolean=False): Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fB".</summary>
    ///<summary>The B value of the linear regression Attribute_2 = fA x Attribute_1 + fB.</summary>
    procedure Set_B(const AB: Double); virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPath_File_Small_Pic".</summary>
    ///<summary>The path to the small picture file representing Attribute_2 vs Attribute_1.</summary>
    procedure Set_Path_File_Small_Pic(const APath_File_Small_Pic: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath_File_Small_Pic".</summary>
    ///<summary>The path to the small picture file representing Attribute_2 vs Attribute_1.</summary>
    function Get_Path_File_Small_Pic: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPath_File_Small_Pic_Inverted".</summary>
    ///<summary>The path to the small picture file representing Attribute_1 vs Attribute_2.</summary>
    procedure Set_Path_File_Small_Pic_Inverted(const APath_File_Small_Pic_Inverted: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath_File_Small_Pic_Inverted".</summary>
    ///<summary>The path to the small picture file representing Attribute_1 vs Attribute_2.</summary>
    function Get_Path_File_Small_Pic_Inverted: string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath_File_Big_Pic".</summary>
    ///<summary>The path to the big picture file representing Attribute_2 vs Attribute_1.</summary>
    function Get_Path_File_Big_Pic(ADirectory: string): string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath_File_Big_Pic_Inverted".</summary>
    ///<summary>The path to the big picture file representing Attribute_1 vs Attribute_2.</summary>
    function Get_Path_File_Big_Pic_Inverted(ADirectory: string): string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sHint".</summary>
    ///<summary>A short description of the correlation described as Attribute_2 vs Attribute_1.</summary>
    procedure Set_Hint(const AHint: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sHint".</summary>
    ///<summary>A short description of the correlation described as Attribute_2 vs Attribute_1.</summary>
    function Get_Hint: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sLong_Hint".</summary>
    ///<summary>A long description of the correlation described as Attribute_2 vs Attribute_1.</summary>
    procedure Set_Long_Hint(const ALong_Hint: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sLong_Hint".</summary>
    ///<summary>A long description of the correlation described as Attribute_2 vs Attribute_1.</summary>
    function Get_Long_Hint: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sHint_Inverted".</summary>
    ///<summary>A short description of the correlation described as Attribute_1 vs Attribute_2.</summary>
    procedure Set_Hint_Inverted(const AHint_Inverted: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sHint_Inverted".</summary>
    ///<summary>A short description of the correlation described as Attribute_1 vs Attribute_2.</summary>
    function Get_Hint_Inverted: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sLong_Hint_Inverted".</summary>
    ///<summary>A long description of the correlation described as Attribute_1 vs Attribute_2.</summary>
    procedure Set_Long_Hint_Inverted(const ALong_Hint_Inverted: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sLong_Hint_Inverted".</summary>
    ///<summary>A long description of the correlation described as Attribute_1 vs Attribute_2.</summary>
    function Get_Long_Hint_Inverted: string; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Value_Evaluated'}
  ///<summary>Class handling an evaluated value for a couple "Object"/"Attribute".</summary>
  TSt_Value_Evaluated=class(TSt_Value)
  public
    ///<summary>Procedure adding a evaluated value and its relevancy.</summary>
    ///<param name="AValue">The value.</param>
    ///<param name="ARelevancy">The relevancy.</param>
    procedure Add_Value_And_Revelancy(const AValue: Double; const ARelevancy: Double); virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Evaluation'}
  ///<summary>Class handling the evaluations of a given Attribute for a given list of Objects.</summary>
  TSt_Evaluation=class(TObject)
  public
    ///<summary>Procedure evalulating the values, their error and relevancies.</summary>
    procedure Evaluate; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating and returning a TSt_Evaluation object from a given list of statistics.</summary>
  TCreate_Evaluation=function(AOL_Statistics: TObjectList; AID_Attribute_To_Evaluate: Integer; AMethod: TEvaluation_Method; AEvaluate_Known_Objects: Boolean): TSt_Evaluation; stdcall;
  {$ENDREGION}

  {$REGION 'U_TxTranslation'}
  ///<summary>Class handling a translation.</summary>
  TTxTranslation=class(TTree_Object)
  public
    procedure SetTextToTranslate(const AOriginal: string); virtual; stdcall; abstract;
    function GetTextToTranslate: string; virtual; stdcall; abstract;
    procedure SetTranslation(const ATranslation: string); virtual; stdcall; abstract;
    function GetTranslation: string; virtual; stdcall; abstract;
    procedure SetIdLanguage(const AID_Language: Integer); virtual; stdcall; abstract;
    function GetIdLanguage: Integer; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Translation_Object_Type'}
  ///<summary>Class handling the translation of an Object Type name or description.</summary>
  TObjectTypeTranslationSettings=class(TOTObject)
  public
    procedure SetTranslateAttributes(const ATranslateAttributes: Boolean); virtual; stdcall; abstract;
    function GetTranslateAttributes: Boolean; virtual; stdcall; abstract;
    procedure SetTranslateObjects(const ATranslateObjects: Boolean); virtual; stdcall; abstract;
    function GetTranslateObjects: Boolean; virtual; stdcall; abstract;
    procedure SetIdLanguage(const AIdLanguage: Integer); virtual; stdcall; abstract;
    function GetIdLanguage: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Function returning the Object_Type_Translation object.</summary>
  TCreate_Translation_Object_Type=function: TObjectTypeTranslationSettings; stdcall;
  {$ENDREGION}

  {$REGION 'U_XML'}
  ///<summary>Function creating and returning an object from an XML flow. The class is chosen depending on the TD attribute. The function handles the "list" Nodes and returns a TObjectList in those cases.</summary>
  ///<param name="AXML">The xml string.</param>
  ///<param name="AFilesDir">The absolute directory where the files associated to the various objects are stored.</param>
  ///<returns>Transtype/Cast the returned object into (at least) a TID_Object to get its Data Type.</returns>
  TCreate_Object_From_XML=function(const AXML: string; const AFilesDir: string=''): TObject; stdcall;

  ///<summary>Function creating an object from an XML file. The class is chosen depending on the TD attribute. The function handles the "list" Nodes and returns a TObjectList in those cases.</summary>
  ///<param name="APath_File">The absolute path to the xml file.</param>
  ///<param name="AFilesDir">The root directory in case of objects referencing external files.</param>
  ///<returns>Transtype/Cast the returned object into (at least) a TID_Object to get its Data Type.</returns>
  TCreate_Object_From_XML_File=function(const APath_File: string; const AFilesDir: string=''): TObject; stdcall;

  ///<summary>Function filling a "list" node with a list of Objects in the TObjectList sent as input. The list node may be the parent node or a child node (created on demand). If the list is empty, no "list" node is created. </summary>
  ///<param name="AOL">A list of TID_Object objects (or derivating from).</param>
  ///<param name="AVerbosity">The verbosity of the xml to generate.</param>
  ///<param name="ADocument">The DOM Document.</param>
  ///<param name="AFilesDir">The absolute directory where the files associated to the various objects are stored.</param>
  ///<param name="AUse_RPath">If true, the objects write a relative path of their various files to AFilesDir.</param>
  ///<param name="AParent_Node">The parent DOM node. If nil, the documentElement will be taken.</param>
  ///<param name="AName">The name of the node sent as result. if Empty, the Parent node is used as list node. In the other case, it will be created as child of the Parent node.</param>
  TFill_XML_From_OL=function(const AOL: TObjectList; const AVerbosity: TVerbosity; const ADocument: IInterface; const AFilesDir: string; const AUse_RPath: Boolean; const AParent_Node: IInterface=nil; const AName: string=''): IInterface; stdcall;

  ///<summary>Function returning the xml of a list of objects (inheriting from the TID_Object).</summary>
  ///<param name="AOL">The list of Objects to convert into XML.</param>
  ///<param name="AVerbosity">The verbosity of the xml to generate.</param>
  ///<param name="AFilesDir">The absolute directory where the files associated to the various objects are stored.</param>
  ///<param name="AUse_RPath">If true, the objects write a relative path of their various files to AFilesDir.</param>
  ///<param name="AName">The name of the root node.</param>
  TOLToXML=function(const AOL: TObjectList; const AVerbosity: TVerbosity; const AFilesDir: string=''; const AUse_RPath: Boolean=False; const AName: string=''): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_CG'}
  ///<summary>Virtual Class, parent of all the Choice Guide's classes.</summary>
  TCG=class(TBranch)
  public
    function Get_Default_RL_Name: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bUse_Parent_RL".</summary>
    ///<summary>If true, the object uses the Requirement List of its parent object instead of using it own Requirement list.</summary>
    procedure Set_Use_Parent_RL(const AUse_Parent_RL: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bUse_Parent_RL".</summary>
    ///<summary>If true, the object uses the Requirement List of its parent object instead of using it own Requirement list.</summary>
    function Get_Use_Parent_RL: Boolean; virtual; stdcall; abstract;
    ///<summary>Internal procedure allowing to replace the existing RL by a new one. The previous RL object is freed.</summary>
    ///<param name="ARL">The new Requirement List object.</param>
    procedure Set_RL(const ARL: TMCS_Requirement_List); virtual; stdcall; abstract;
    function Get_RL: TMCS_Requirement_List; virtual; stdcall; abstract;
    procedure Set_ID_OT(const AID_OT: Integer); virtual; stdcall; abstract;
    function Get_ID_OT: Integer; virtual; stdcall; abstract;
    function DoWrite: Boolean; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Choice_Guide'}
  ///<summary>Class handling the informations of a Choice Guide.</summary>
  TCG_Choice_Guide=class(TCG)
  public
    ///<summary>Setter for the variable "sRPath_File_Extraction".</summary>
    ///<summary>A relative path (to the extraction directory) that enables to export the result of a choice guide to a word file.</summary>
    procedure Set_RPath_File_Extraction(const ARPath_File_Extraction: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sRPath_File_Extraction".</summary>
    ///<summary>A relative path (to the extraction directory) that enables to export the result of a choice guide to a word file.</summary>
    function Get_RPath_File_Extraction: string; virtual; stdcall; abstract;
  end;

  ///<summary>Function returning the default name of a Requirement List belonging to a Choice Guide.</summary>
  ///<param name="AChoice_Guide_Name">The name of the Choice Guide.</param>
  TGet_Choice_Guide_Default_RL_Name=function(const AChoice_Guide_Name: string): string; stdcall;

  ///<summary>Function creating a TCG_Choice_Guide object with its default constructor.</summary>
  TCreate_Choice_Guide=function: TCG_Choice_Guide; stdcall;
  {$ENDREGION}

  {$REGION 'U_Answer'}
  ///<summary>Class handling the informations of a Choice Guide Question's Answer.</summary>
  ///<summary>This is an execution class. Nothing is stored into the database.</summary>
  TCG_Answer=class(TTree_Object)
  public
    procedure SetIdQuestion(const AID_Question: Integer); virtual; stdcall; abstract;
    function GetIdQuestion: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bOpened".</summary>
    ///<summary>Variable making sense in case of a Group Question, equals to true if the Group is opened.</summary>
    procedure Set_Opened(const AOpened: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bOpened".</summary>
    ///<summary>Variable making sense in case of a Group Question, equals to true if the Group is opened.</summary>
    function Get_Opened: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sValue".</summary>
    ///<summary>Variable making sense in case of a Text Question, containing the answer to the Text question.</summary>
    procedure Set_Value(const AValue: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sValue".</summary>
    ///<summary>Variable making sense in case of a Text Question, containing the answer to the Text question.</summary>
    function Get_Value: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fMin".</summary>
    ///<summary>Variable making sense in case of a single or range numerical Question, containing the (min) value entered by the User.</summary>
    procedure Set_Min(const AMin: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMin".</summary>
    ///<summary>Variable making sense in case of a single or range numerical Question, containing the (min) value entered by the User.</summary>
    function Get_Min: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fMax".</summary>
    ///<summary>Variable making sense in case of a range numerical Question, containing the max value entered by the User.</summary>
    procedure Set_Max(const AMax: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMax".</summary>
    ///<summary>Variable making sense in case of a range numerical Question, containing the max value entered by the User.</summary>
    function Get_Max: Double; virtual; stdcall; abstract;
    ///<summary>Procedure making sense in case of a single or multiple Question, clearing the list of Questions checked.</summary>
    procedure Clear_IDs_Question_Selected; virtual; stdcall; abstract;
    ///<summary>Procedure making sense in case of a single or multiple Question, adding a Question to the list of children Questions checked.</summary>
    procedure Add_ID_Question_Selected(const AID_Question: Integer); virtual; stdcall; abstract;
    ///<summary>Procedure making sense in case of a single Question, setting the child Question checked.</summary>
    procedure SetIdQuestion_Selected(const AID_Question: Integer); virtual; stdcall; abstract;
    ///<summary>Procedure making sense in case of a multiple Question, setting the list of children Questions checked.</summary>
    procedure Set_IDs_Question_Selected(const ASL_ID_Question: TStringList); virtual; stdcall; abstract;
    ///<summary>Function making sense in case of a multiple Question, returning the list of identifiers of the children Questions checked.</summary>
    function GetSlIdQuestion_Selected: TStringList; virtual; stdcall; abstract;
    ///<summary>Function making sense in case of a single Question, returning the identifier of the Question checked.</summary>
    function GetIdQuestion_Selected: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iBCT".</summary>
    ///<summary>Variable making sense in case of a Boolean Question, containing the value checked by the User.</summary>
    procedure Set_BCT(const AValue: TMCSBooleanCriterionType); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iBCT".</summary>
    ///<summary>Variable making sense in case of a Boolean Question, containing the value checked by the User.</summary>
    function Get_BCT: TMCSBooleanCriterionType; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "Criterion".</summary>
    ///<summary>Variable making sense in case of a Criterion Question.</summary>
    procedure Set_Criterion(const ACriterion: TMCS_Criterion); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "Criterion".</summary>
    ///<summary>Variable making sense in case of a Criterion Question.</summary>
    function Get_Criterion: TMCS_Criterion; virtual; stdcall; abstract;
  end;

  TCreate_Answer=function: TCG_Answer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Answers'}
  ///<summary>Class handling a list of TCG_Answer objects (of the same tree level).</summary>
  ///<summary>This is an execution class. Nothing is stored into the database.</summary>
  TCG_Answers=class(TBranch)
  public
    procedure Remove_Answer(const AID_Question: Integer); virtual; stdcall; abstract;
    function Add_Answer(const AID_Question: Integer): TCG_Answer; overload; virtual; stdcall; abstract;
    function Add_Answer(const AID_Question: Integer; const AValue: string): TCG_Answer; overload; virtual; stdcall; abstract;
    function Add_Answer(const AID_Question: Integer; const bOpened: Boolean): TCG_Answer; overload; virtual; stdcall; abstract;
    function Add_Answer(const AID_Question: Integer; const AValue: Double): TCG_Answer; overload; virtual; stdcall; abstract;
    function Add_Answer(const AID_Question: Integer; const AMin: Double; const AMax: Double): TCG_Answer; overload; virtual; stdcall; abstract;
    function Add_Answer(const AID_Question: Integer; const ACriterion: TMCS_Criterion): TCG_Answer; overload; virtual; stdcall; abstract;
    function Add_Answer(const AID_Question: Integer; const AValue: TMCSBooleanCriterionType): TCG_Answer; overload; virtual; stdcall; abstract;
    function Get_Question_Criterion(const AID_Question: Integer): TMCS_Criterion; virtual; stdcall; abstract;
    function Get_Question_Value(const AID_Question: Integer): string; virtual; stdcall; abstract;
    function Get_Question_Opened(const AID_Question: Integer): Boolean; virtual; stdcall; abstract;
    function Get_Question_BCT(const AID_Question: Integer): TMCSBooleanCriterionType; virtual; stdcall; abstract;
    function Get_Question_SL_ID_Question_Selected(const AID_Question: Integer): TStringList; virtual; stdcall; abstract;
    function Get_Question_ID_Question_Selected(const AID_Question: Integer): Integer; virtual; stdcall; abstract;
    procedure Retrieve_Question_Min_And_Max_Values(const AID_Question: Integer; out AMin: Double; out AMax: Double); virtual; stdcall; abstract;
    procedure SetIdChoiceGuide(const AID_Choice_Guide: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Choice_Guide".</summary>
    ///<summary>The identifier of the Choice Guide the Anwers refer to.</summary>
    function Get_ID_Choice_Guide: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_OT".</summary>
    ///<summary>The identifier of the Object Type of the Choice Guide.</summary>
    procedure Set_ID_OT(const AID_OT: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_OT".</summary>
    ///<summary>The identifier of the Object Type of the Choice Guide.</summary>
    function Get_ID_OT: Integer; virtual; stdcall; abstract;
  end;

  TCreate_Answers2=function: TCG_Answers; stdcall;

  ///<summary>Function returning a TCG_Answers object created from an xml file.</summary>
  ///<param name="APath_File_XML">The path of the XML file to load.</param>
  TCreate_Answers_From_File=function(const APath_File_XML: string): TCG_Answers; stdcall;

  ///<summary>Function returning a TCG_Answers object created using the default constructor.</summary>
  TCreate_Answers=function(const AID_Choice_Guide: Integer; AID_OT: Integer): TCG_Answers; stdcall;
  {$ENDREGION}

  {$REGION 'U_Question'}
  ///<summary>Question Type.</summary>
  TCG_Question_Type=(
    ///A group of questions.
    qtGroup,
    ///Question expecting a single answer from a list of possible answers.
    ///The answers are the children (group) questions of the the question.
    qtUnique_Choice,
    ///Question expecting many answers from a list of possible answers.
    ///The answers are the children (group) questions of the the question.
    qtMultiple_Choice,
    ///Question expecting a single numerical value (and putting it into a defined numerical criterion).
    qtNumerical,
    ///Question expecting a range of numerical values (and putting them into a defined numerical criterion).
    qtNumerical_Range,
    ///Question expecting a string (and putting it into a defined string criterion).
    qtText,
    ///Question displaying an advanced form allowing to fill a crietion.
    ///The type of form depends on the nature of the criteria it must fill.
    qtAdvanced_Question,
    ///Question displaying a comment.
    qtComment,
    ///Question displaying a checkbox.
    qtBoolean,
    ///Undefined!
    qtUndefined);

  ///<summary>The information type (independant or belonging to an Attribute)</summary>
  TCG_Information_Type=(
    ///The question is not linked to any information object.
    itNone,
    ///The question is linked to an Information Object belonging to an Attribute.
    itAttribute,
    ///The question is linked to its own Information Object.
    itIndependant);

  ///<summary>Class handling the informations of a Choice Guide's Question.</summary>
  TCG_Question=class(TCG)
  public
    ///<summary>Function returning the name of the Question's type.</summary>
    function Get_Question_Type_Name: string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iQuestion_Type".</summary>
    ///<summary>The question Type.</summary>
    function Get_Question_Type: TCG_Question_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iQuestion_Type".</summary>
    ///<summary>The question Type.</summary>
    procedure Set_Question_Type(const AQuestion_Type: TCG_Question_Type); virtual; stdcall; abstract;
    function Get_Default_Value: string; virtual; stdcall; abstract;
    procedure Set_Default_Value(const ADefault_Value: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sExtraction_Bookmark".</summary>
    ///<summary>In case the Choice Guide has an extraction template, this string contains the Bookmark where to write the question.</summary>
    function Get_Extraction_Bookmark: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sExtraction_Bookmark".</summary>
    ///<summary>In case the Choice Guide has an extraction template, this string contains the Bookmark where to write the question.</summary>
    procedure Set_Extraction_Bookmark(const AExtraction_Bookmark: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Information".</summary>
    ///<summary>In case of an independant Information, the identifier of Information Object.</summary>
    function Get_ID_Object_Information: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Information".</summary>
    ///<summary>In case of an independant Information, the identifier of Information Object.</summary>
    procedure Set_ID_Object_Information(const AID_Object_Information: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute_Information".</summary>
    ///<summary>In case of an Information belonging to an Attribute, the identifier of the Attribute.</summary>
    function Get_ID_Attribute_Information: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute_Information".</summary>
    ///<summary>In case of an Information belonging to an Attribute, the identifier of the Attribute.</summary>
    procedure Set_ID_Attribute_Information(const AID_Attribute_Information: Integer); virtual; stdcall; abstract;
    function Get_ID_CG: Integer; virtual; stdcall; abstract;
    procedure Set_ID_CG(const AID_CG: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iInformation_Type".</summary>
    ///<summary>The information type.</summary>
    function Get_Information_Type: TCG_Information_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iInformation_Type".</summary>
    ///<summary>The information type.</summary>
    procedure Set_Information_Type(const AInformation_Type: TCG_Information_Type); virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to a given text value.</summary>
    ///<values>This method can be called only for text Question.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="AValue">The text value.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const AValue: string); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to a given child Question.</summary>
    ///<values>This method can be called only for single choice Question.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="AQuestion_Selected">The text value.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const AQuestion_Selected: TCG_Question); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to a given list of children Questions.</summary>
    ///<values>This method can be called only for single and multiple choice Questions.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="AOL_Question_Selected">The list of selected Children Questions selected.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const AOL_Question_Selected: TObjectList); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to a single decimal value.</summary>
    ///<values>This method can be called only for numerical Questions.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="AValue">The decimal value.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const AValue: Double); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to a range of decimal values.</summary>
    ///<values>This method can be called only for numerical and range Questions.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="AMin">The min value.</param>
    ///<param name="AMax">The max value.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const AMin: Double; const AMax: Double); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to a given Criterion.</summary>
    ///<values>This method can be called only for advanced Questions.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="ACriterion">The Criterion object.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const ACriterion: TMCS_Criterion); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to open/close state.</summary>
    ///<values>This method can be called only for "group" Questions.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="AOpened">A boolean indicating if the group is opened or closed.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const AOpened: Boolean); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to boolean state.</summary>
    ///<values>This method can be called only for "boolean" Questions.</values>
    ///<param name="ARL">The Requirement List object to update.</param>
    ///<param name="AValue">The boolean state value.</param>
    procedure Update_RL(const ARL: TMCS_Requirement_List; const AValue: TMCSBooleanCriterionType); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List in case of commentary Question.</summary>
    ///<summary>The Requirement List of the Commentary is always added.</summary>
    procedure Update_RL(const ARL: TMCS_Requirement_List); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given TCG_Answers object thanks to a given text value.</summary>
    ///<values>This method can be called only for text Question.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="AValue">The text value.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const AValue: string); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given TCG_Answers object thanks to a given child Question.</summary>
    ///<values>This method can be called only for single choice Question.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="AQuestion_Selected">The text value.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const AQuestion_Selected: TCG_Question); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given TCG_Answers object thanks to a given list of children Questions.</summary>
    ///<values>This method can be called only for single and multiple choice Questions.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="AOL_Question_Selected">The list of selected Children Questions selected.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const AOL_Question_Selected: TObjectList); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given TCG_Answers object thanks to a single decimal value.</summary>
    ///<values>This method can be called only for numerical Questions.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="AValue">The decimal value.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const AValue: Double); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to a range of decimal values.</summary>
    ///<values>This method can be called only for numerical and range Questions.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="AMin">The min value.</param>
    ///<param name="AMax">The max value.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const AMin: Double; const AMax: Double); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given TCG_Answers object thanks to a given Criterion.</summary>
    ///<values>This method can be called only for advanced Questions.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="ACriterion">The Criterion object.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const ACriterion: TMCS_Criterion); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given Requirement List thanks to open/close state.</summary>
    ///<values>This method can be called only for "group" Questions.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="AOpened">A boolean indicating if the group is opened or closed.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const AOpened: Boolean); overload; virtual; stdcall; abstract;
    ///<summary>Procedure updating a given TCG_Answers object thanks to boolean state.</summary>
    ///<values>This method can be called only for "boolean" Questions.</values>
    ///<param name="AAnswers">The TCG_Answers object to update.</param>
    ///<param name="AValue">The boolean state value.</param>
    procedure Update_Answers(const AAnswers: TCG_Answers; const AValue: TMCSBooleanCriterionType); overload; virtual; stdcall; abstract;
    ///<summary>Function returning true if a Criterion (identified by its Attribute) can be tagged by the Question.</summary>
    ///<values>The search is done is a given Requirement List, not in the Requirement List used by the Question.</values>
    ///<param name="ARL">The Requirement List object where tagged criteria are searched.</param>
    ///<param name="AID_Attribute">The identifier of the Attribute which is related to the Criterion.</param>
    function Check_Attribute_Compatibility(const ARL: TMCS_Requirement_List; const AID_Attribute: Integer): Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning true if a preselection criterion (identified by its Object Type and filtering Object) can be tagged by the Question.</summary>
    ///<values>The search is done is a given Requirement List, not in the Requirement List used by the Question.</values>
    ///<param name="ARL">The Requirement List object where tagged criteria are searched.</param>
    ///<param name="AID_OT">The identifier of the Object Type which is related to the Preselection Criterion.</param>
    ///<param name="AID_Object_Filtering">The identifier of the filtering Object which is related to the Preselection Criterion.</param>
    function Check_Preselection_Compatibility(const ARL: TMCS_Requirement_List; const AID_OT: Integer; const AID_Object_Filtering: Integer): Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning the (Data) Data Type of the Question.</summary>
    function Get_Criteria_Data_Type: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the Table in case of numerical Criteria on Table Attributes.</summary>
    function Get_Criteria_ID_Table_Type: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the Unit in case of numerical Criteria on Decimal Attributes.</summary>
    function Get_Criteria_ID_Unit: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the Object Type in case of Preselection Criteria.</summary>
    function Get_Preselection_ID_OT: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the filtering Object in case of Preselection Criteria.</summary>
    function Get_Preselection_ID_Object_Filtering: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Function returning a short description of a given question type.</summary>
  ///<param name="AQuestion_Type">The type of question.</param>
  TGet_Question_Type_Name=function(const AQuestion_Type: TCG_Question_Type): string; stdcall;

  ///<summary>Function creating a TCG_Question object with its default constructor.</summary>
  TCreate_Question=function: TCG_Question; stdcall;
  {$ENDREGION}

  {$REGION 'U_VACBOA'}
  ///<summary>VACBOA: Virtual Associative Class Between an Object and an Attribute.</summary>
  ///<summary>This class is simply the ancestor of the TD_Data and TMD_Source classes.</summary>
  ///<summary>Its name is complexe on purpose because it should not be used outside of the TxAPI.</summary>
  TVACBOA=class(TID_Object)
  public
    ///<summary>Setter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object.</summary>
    procedure Set_ID_Object(const AID_Object: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object".</summary>
    ///<summary>The identifier of the Object.</summary>
    function Get_ID_Object: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the attribute.</summary>
    procedure Set_ID_Attribute(const AID_Attribute: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the attribute.</summary>
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
  end;

  TCreate_VACBOA=function: TVACBOA; stdcall;
  {$ENDREGION}

  {$REGION 'U_Source'}
  ///<summary>Class handling the source attached to a given couple "Object / Attribute".</summary>
  TMD_Source=class(TVACBOA)
  public
    ///<summary>Getter for the variable "Object_Source".</summary>
    ///<summary>The Object owning the data of in case it is handled by the Source.</summary>
    function Get_Object_Source: TS_Object_Data; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Object_Source".</summary>
    ///<summary>The identifier of the object associated to the source.</summary>
    procedure Set_ID_Object_Source(const AID_Object_Source: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Object_Source".</summary>
    ///<summary>The identifier of the object associated to the source.</summary>
    function Get_ID_Object_Source: Integer; virtual; stdcall; abstract;
    ///<summary>Procedure removing the source from the database if its form is empty (no data) and if their is no tracking data.</summary>
    procedure Delete_If_Necessary; virtual; stdcall; abstract;
  end;

  ///<summary>Fonction Creating the list of TMD_Source objects associated to attributes and objects.</summary>
  ///<param name="AOL_Attribute">the list of Attributes.</param>
  ///<param name="ASL_ID_Object">the list of Objects identifiers.</param>
  ///<param name="ATreat_Inherited_Attributes">if true, sources of the inherited data will be read.</param>
  TCreate_OL_Source=function(const AOL_Attribute: TObjectList; const ASL_ID_Object: TStringList; const ATreat_Inherited_Attributes: Boolean): TObjectList; stdcall;

  ///<summary>Function creating a list of TMD_Source objects associated to attributes and a single object.</summary>
  ///<param name="AOL_Attribute">The list of Attributes.</param>
  ///<param name="AID_Object">The identifier of the Object the sources must be read.</param>
  ///<param name="ATreat_Inherited_Attributes">If true, sources of the inherited data will be read.</param>
  TCreate_OL_Source_From_Object=function(const AOL_Attribute: TObjectList; const AID_Object: Integer; const ATreat_Inherited_Attributes: Boolean): TObjectList; stdcall;

  ///<summary>Function creating a TMD_Source object for a given couple (Object/Attribute).</summary>
  ///<summary>If no source exists in the database, one is created automatically.</summary>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  TCreate_Source=function(const AID_Object: Integer; const AID_Attribute: Integer): TMD_Source; stdcall;

  ///<summary>Function returning a source associated to a given couple (Object/Attribute) from a list.</summary>
  ///<param name="AOL_Source">The list to search into.</param>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  TGet_Source=function(const AOL_Source: TObjectList; const AID_Object: Integer; const AID_Attribute: Integer): TMD_Source; stdcall;

  ///<summary>Function returning the list of data of the source associated to a given couple (Object/attribute).</summary>
  ///<param name="AOL_Source">The list to search into.</param>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  TGet_Source_OL_Data=function(const AOL_Source: TObjectList; const AID_Object: Integer; const AID_Attribute: Integer): TObjectList; stdcall;

  ///<summary>Function creating and returning a sub-list of sources for a given Attribute and a given Object from a given list.</summary>
  ///<param name="AOL_Source">The list to search into.</param>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  ///<param name="ASorted">If true, the list is sorted.</param>
  TCreate_OL_Source_Filtered=function(const AOL_Source: TObjectList; const AID_Attribute: Integer; const AID_Object: Integer; const ASorted: Boolean=True): TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Information'}
  ///<summary>Class storing the informations of a given Information.</summary>
  TMD_Information=class(TID_Object)
  public
    ///<summary>Setter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute of the Information.</summary>
    procedure Set_ID_Attribute(const AID_Attribute: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Attribute".</summary>
    ///<summary>The identifier of the Attribute of the Information.</summary>
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    ///<summary>Procedure removing the information in case it has no data.</summary>
    procedure Delete_If_Necessary; virtual; stdcall; abstract;
  end;

  ///<summary>Function returning a TMD_Information object into a list thanks to its Attribute identifier.</summary>
  ///<param name="AOL_Information">The list of TMD_Information objects to search into.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  TGet_Information=function(const AOL_Information: TObjectList; const AID_Attribute: Integer): TMD_Information; stdcall;

  ///<summary>Function creating a list of TMD_Information objects of the Attributes contained into a given tab.</summary>
  ///<param name="AID_Tab">The identifier of the tab Attribute.</param>
  TCreate_OL_Information_From_Tab=function(const AID_Tab: Integer): TObjectList; stdcall;

  ///<summary>Function creating a list of TMD_Information objects associated to a given list of Attributes.</summary>
  ///<param name="AOL_Attribute">The list of TS_Attribute objects.</param>
  TCreate_OL_Information=function(const AOL_Attribute: TObjectList): TObjectList; stdcall;

  ///<summary>Function creating a TMD_Information object associated to a given Attribute. If the information Object does not exist in the database, it is automatically written and associated to the Attribute.</summary>
  ///<param name="AID_Attribute">The identifier of the Attribute. If nul, the default constructor is called</param>
  TCreate_Information=function(const AID_Attribute: Integer=0): TMD_Information; stdcall;
  {$ENDREGION}

  {$REGION 'U_MCS_Algorithm'}
  ///<summary>Enumeration of the selection mark states.</summary>
  TMCS_Mark_State=(
    ///The mark was not calculated
    msNot_Calculated,
    ///The Object was not preselected
    msNot_Preselected,
    ///The Object was not selected
    msNot_Selected,
    ///The Object hos no data for the current mark
    msNo_Data,
    ///The Object was selected
    msSelected);

  ///<summary>Type permettant de caracteriser l'etat d'une note de comparaison . Par defaut, celle-ci est non calculee.</summary>
  TMCS_Comparison_Mark_State=(
    ///The comparison mark was not calculated
    cmsNot_Calculated,
    ///No data for the calculation
    cmsNo_Data,
    ///The comparison mark was calculated
    cmsCalculated);

  TArr_MCS_Mark_State=array of TMCS_Mark_State;

  ///<summary>Base class for all the "mark" objects.</summary>
  TMCS_Mark=class(TTree_Object)
  public
    ///<summary>Setter for the variable "fMin".</summary>
    ///<summary>The minimum value of the mark.</summary>
    procedure Set_Min(const AMin: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMin".</summary>
    ///<summary>The minimum value of the mark.</summary>
    function Get_Min: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "fMax".</summary>
    ///<summary>The maximum value of the mark.</summary>
    procedure Set_Max(const AMax: Double); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "fMax".</summary>
    ///<summary>The maximum value of the mark.</summary>
    function Get_Max: Double; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iState".</summary>
    ///<summary>The calculation state of the mark.</summary>
    procedure Set_State(const AState: TMCS_Mark_State); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iState".</summary>
    ///<summary>The calculation state of the mark.</summary>
    function Get_State: TMCS_Mark_State; virtual; stdcall; abstract;
    procedure Set_Comparison_Min(const AMin_Comparison: Double); virtual; stdcall; abstract;
    function Get_Comparison_Min: Double; virtual; stdcall; abstract;
    procedure Set_Comparison_Max(const AMax_Comparison: Double); virtual; stdcall; abstract;
    function Get_Comparison_Max: Double; virtual; stdcall; abstract;
    procedure Set_Comparison_State(const AState_Comparison: TMCS_Comparison_Mark_State); virtual; stdcall; abstract;
    function Get_Comparison_State: TMCS_Comparison_Mark_State; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bVisible".</summary>
    ///<summary>If true, the mark must be shown into the table results.</summary>
    procedure Set_Visible(const AVisible: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bVisible".</summary>
    ///<summary>If true, the mark must be shown into the table results.</summary>
    function Get_Visible: Boolean; virtual; stdcall; abstract;
  end;

  TCreate_MCS_Mark=function: TMCS_Mark; stdcall;

  ///<summary>Function returning the list of Objects identifiers with a given boolean value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AValue">The value to find.</param>
  TCreate_SL_ID_Object_From_bValue=function(const AID_Attribute: Integer; const AValue: TMCSBooleanCriterionType): TStringList; stdcall;

  ///<summary>Function returning the list of Objects identifiers with a given string value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AValue">The value to find.</param>
  TCreate_SL_ID_Object_From_sValue=function(const AID_Attribute: Integer; const AValue: string): TStringList; stdcall;

  ///<summary>Function returning the list of Objects identifiers with a given numerical value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AValue">The value to find, defined into the default unit of the Attribute.</param>
  ///<param name="AFuzziness">An acceptable distance from the value, defined into the default unit of the Attribute.</param>
  TCreate_SL_ID_Object_From_fValue=function(const AID_Attribute: Integer; const AValue: Double; const AFuzziness: Double=0): TStringList; stdcall;

  ///<summary>Function returning the list of Objects identifiers with a given range value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AMin">The lower bound of the range.</param>
  ///<param name="AMax">The upper bound of the range.</param>
  ///<param name="AFuzziness">An acceptable distance from the value, defined into the default unit of the Attribute.</param>
  ///<param name="ABounds_Inclusive">If true, the boundaries of the range are inclusive.</param>
  ///<param name="ANCT">The type of numerical Criterion.</param>
  TCreate_SL_ID_Object_From_Range_Value=function(const AID_Attribute: Integer; AMin: Double; AMax: Double; const AFuzziness: Double=0; const ABounds_Inclusive: Boolean=True; const ANCT: TMCS_Numerical_Criterion_Type=nctRange_Max): TStringList; stdcall;

  ///<summary>Function returning the list of Objects identifiers linked to a given Object for a given (link) Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AID_Object_Lkd">The ID of the linked object to find.</param>
  TCreate_SL_ID_Object_From_Linked_Object=function(const AID_Attribute: Integer; const AID_Object_Lkd: Integer): TStringList; stdcall;

  ///<summary>Function returning the identifier of the first object with a given string value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AValue">The value to find.</param>
  ///<returns>The function returns a null value if no Object was found.</returns>
  TGet_ID_Object_From_sValue=function(const AID_Attribute: Integer; const AValue: string): Integer; stdcall;

  ///<summary>Function returning the identifier of the first object with a given numerical value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AValue">The value to find, defined into the default unit of the Attribute.</param>
  ///<param name="AFuzziness">An acceptable distance from the value, defined into the default unit of the Attribute.</param>
  ///<returns>The function returns a null value if no Object was found.</returns>
  TGet_ID_Object_From_fValue=function(const AID_Attribute: Integer; const AValue: Double; const AFuzziness: Double=0): Integer; stdcall;

  ///<summary>Function returning the identifier of the first object with a given boolean value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AValue">The value to find.</param>
  ///<returns>The function returns a null value if no Object was found.</returns>
  TGet_ID_Object_From_bValue=function(const AID_Attribute: Integer; const AValue: TMCSBooleanCriterionType): Integer; stdcall;

  ///<summary>Function returning the identifier of the first object with a given range value for a given Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AMin">The lower bound of the range.</param>
  ///<param name="AMax">The upper bound of the range.</param>
  ///<param name="AFuzziness">An acceptable distance from the value, defined into the default unit of the Attribute.</param>
  ///<param name="ABounds_Inclusive">If true, the boundaries of the range are inclusive.</param>
  ///<param name="ANCT">The type of numerical Criterion.</param>
  ///<returns>The function returns a null value if no Object was found.</returns>
  TGet_ID_Object_From_Range_Value=function(const AID_Attribute: Integer; AMin: Double; AMax: Double; const AFuzziness: Double=0; const ABounds_Inclusive: Boolean=True; const ANCT: TMCS_Numerical_Criterion_Type=nctRange_Max): Integer; stdcall;

  ///<summary>Function returning the identifier of the first object linked to a given Object for a given (link) Attribute.</summary>
  ///<param name="AID_Attribute">The attribute to check.</param>
  ///<param name="AID_Object_Lkd">The ID of the linked object to find.</param>
  ///<returns>The function returns a null value if no Object was found.</returns>
  TGet_ID_Object_From_Linked_Object=function(const AID_Attribute: Integer; const AID_Object_Lkd: Integer): Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Mark_Criterion'}
  ///<summary>Class handling the mark of an Object for a given Criterion.</summary>
  TMCS_Mark_Criterion=class(TMCS_Mark)
  public
    ///<summary>Setter for the variable "ID_Criterion".</summary>
    ///<summary>The identifier of the criterion related to the mark.</summary>
    procedure Set_ID_Criterion(const AID_Criterion: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Criterion".</summary>
    ///<summary>The identifier of the criterion related to the mark.</summary>
    function Get_ID_Criterion: Integer; virtual; stdcall; abstract;
  end;

  TCreate_MCS_Mark_Criterion=function: TMCS_Mark_Criterion; stdcall;
  {$ENDREGION}

  {$REGION 'U_Mark_Object'}
  ///<summary>Class handling the global mark of an Object.</summary>
  TMCS_Mark_Object=class(TMCS_Mark)
  public
    ///<summary>Setter for the variable "ID_RL".</summary>
    ///<summary>The identifier of the Requirement List the mark refers to.</summary>
    procedure Set_ID_RL(const AID_RL: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_RL".</summary>
    ///<summary>The identifier of the Requirement List the mark refers to.</summary>
    function Get_ID_RL: Integer; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_Mark".</summary>
    ///<summary>List of the criteria marks.</summary>
    function Get_OL_Mark: TObjectList; virtual; stdcall; abstract;
  end;

  TCreate_MCS_Mark_Object=function: TMCS_Mark_Object; stdcall;
  {$ENDREGION}

  {$REGION 'U_Results'}
  ///<summary>Class allowing to execute a Requirements List and storing the results.</summary>
  TMCS_Results=class(TID_Object)
  public
    ///<summary>Function returning the list of the Objects marks optimistically sorted.</summary>
    function Get_OL_Mark_Object_Sorted: TObjectList; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of the preselection criterion of the Requirements List.</summary>
    function Get_ID_Criterion_Preselection: Integer; virtual; stdcall; abstract;
    ///<summary>Function launching the multicriteria selection and returning the number of selected Object.</summary>
    ///<param name="ALogAction">If true, the action will be logged (if logs are set to log this kind of event).</param>
    ///<param name="AContext">The context of the selection.</param>
    function MultiSelect(const ALogAction: Boolean=True; const AContext: TLog_Action_Context=lacMCS_Panel): Integer; virtual; stdcall; abstract;
    ///<summary>Function sorting the marks optimistically.</summary>
    procedure Sort_Optimistically; virtual; stdcall; abstract;
    ///<summary>Function returning the number of Objects preselected.</summary>
    function Get_Nb_Objects_Preselected: Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the number of Objects selected.</summary>
    function Get_Nb_Objects_Selected: Integer; virtual; stdcall; abstract;
    ///<summary>Function creating and returning an array containing the minimum mark of a given object.</summary>
    ///<param name="AIdObject">The identifier of the Object.</param>
    ///<param name="AShift">A size allowing to extend the result array. The values are shifted and put at the end of the array.</param>
    function Create_Arr_Min_Mark(const AIdObject: Integer; const AShift: Integer=0): TArr_Double; virtual; stdcall; abstract;
    ///<summary>Function creating and returning an array containing the minimum mark of a given object.</summary>
    ///<param name="AIdObject">The identifier of the Object.</param>
    ///<param name="AShift">A size allowing to extend the result array. The values are shifted and put at the end of the array.</param>
    function Create_Arr_Max_Mark(const AIdObject: Integer; const AShift: Integer=0): TArr_Double; virtual; stdcall; abstract;
    ///<summary>Function creating and returning an array containing the values of the data of a given object. The array may not be complete: only the data needed to evaluate the mark are read.</summary>
    ///<param name="AIdObject">The identifier of the Object.</param>
    ///<param name="AShift">A size allowing to extend the result array. The values are shifted and put at the end of the array.</param>
    function Create_Arr_Data_Value(const AIdObject: Integer; const AShift: Integer=0): TArr_String; virtual; stdcall; abstract;
    function GetDataValue(const AIdObject: Integer; const AIdAttribute: Integer): string; virtual; stdcall; abstract;
    ///<summary>Function creating and returning an array containing the marks states of a given object.</summary>
    ///<param name="AIdObject">The identifier of the Object.</param>
    ///<param name="AShift">A size allowing to extend the result array. The values are shifted and put at the end of the array.</param>
    function Create_Arr_Mark_State(const AIdObject: Integer; const AShift: Integer=0): TArr_MCS_Mark_State; virtual; stdcall; abstract;
    function GetOlCriterion: TObjectList; virtual; stdcall; abstract;
    function GetOlSubRequirementsList: TObjectList; virtual; stdcall; abstract;
    function Get_OL_Child_Result: TObjectList; virtual; stdcall; abstract;
    ///<summary>Function returning the results of a given sub Requirements List.</summary>
    ///<param name="AID_Criterion_Preselection">The identifier of the preselection criterion allowing to identify the sub Requirement Lists.</param>
    function GetChildResult(const AID_Criterion_Preselection: Integer): TMCS_Results; virtual; stdcall; abstract;
    ///<summary>Function creating and returning a list of "Mark" of the linked objects for a given couple "Object"/"Attribute" belonging to a sub Requirements List.</summary>
    ///<param name="AIdObject">The identifier of the Object.</param>
    ///<param name="AIdAttribute">The identifier of the Attribute.</param>
    ///<param name="AID_PreselectionCriterion">The identifier of the preselection criterion allowing to identify the sub Requirement Lists.</param>
    function Create_OL_Mark_Object_Lkd(const AIdObject: Integer; const AIdAttribute: Integer; const AID_PreselectionCriterion: Integer): TObjectList; virtual; stdcall; abstract;
    ///<summary>Function returning the index of the mark object of a given Object.</summary>
    ///<param name="AIdObject">The identifier of the Object.</param>
    function Get_Index_Mark_Object(const AIdObject: Integer): Integer; virtual; stdcall; abstract;
    ///<summary>Function returning the mark object of a given Object</summary>
    ///<param name="AIdObject">The identifier of the Object.</param>
    function Get_Mark_Object(const AIdObject: Integer): TMCS_Mark_Object; virtual; stdcall; abstract;
    function Get_ID_OT: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Fonction creating and returning the TMCS_Result object for a given Requirements List.</summary>
  ///<summary>The function initializes the Objects preselection.</summary>
  ///<param name="ARL">The Requirements List object.</param>
  TCreate_MCS_Results=function(const ARL: TMCS_Requirement_List): TMCS_Results; stdcall;
  {$ENDREGION}

  {$REGION 'U_Structure_Multilingualism'}
  ///<summary>Class handling the informations of the language table.</summary>
  TT_Language=class(TTree_Object)
  public
    function ListObjectTypeTranslationSettings: TObjectDictionary<Integer,TObjectTypeTranslationSettings>; virtual; stdcall; abstract;
    function ListTranslations: TObjectDictionary<string,TTxTranslation>; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sCode".</summary>
    ///<summary>The code of the language (fr, en, aso.).</summary>
    procedure Set_Code(const ACode: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sCode".</summary>
    ///<summary>The code of the language (fr, en, aso.).</summary>
    function Get_Code: string; virtual; stdcall; abstract;
    procedure SetTranslateAttributeSets(const ATranslateAttributeSets: Boolean); virtual; stdcall; abstract;
    function GetTranslateAttributeSets: Boolean; virtual; stdcall; abstract;
    procedure SetTranslateChoiceGuides(const ATranslateChoiceGuides: Boolean); virtual; stdcall; abstract;
    function GetTranslateChoiceGuides: Boolean; virtual; stdcall; abstract;
    procedure SetTranslateUnits(const ATranslateUnits: Boolean); virtual; stdcall; abstract;
    function GetTranslateUnits: Boolean; virtual; stdcall; abstract;
    procedure SetTranslateTableTypes(const ATranslate_Tables: Boolean); virtual; stdcall; abstract;
    function GetTranslateTableTypes: Boolean; virtual; stdcall; abstract;
    procedure SetTranslateBusinessViews(const ATranslate_BusinessViews: Boolean); virtual; stdcall; abstract;
    function GetTranslateBusinessViews: Boolean; virtual; stdcall; abstract;
    procedure SetTranslateExportations(const ATranslate_Exportations: Boolean); virtual; stdcall; abstract;
    function GetTranslateExportations: Boolean; virtual; stdcall; abstract;
    procedure SetTranslateModelApplications(const ATranslateModelApplications: Boolean); virtual; stdcall; abstract;
    function GetTranslateModelApplications: Boolean; virtual; stdcall; abstract;
    ///<summary>Function returning the TTxTranslation associated to the given original text.</summary>
    ///<param name="AText">The text of the translation.</param>
    function Get_Translation(const AText: string): TTxTranslation; virtual; stdcall; abstract;
    ///<summary>Function returning the TT_Object_Type_Translation associated to the given Object Type.</summary>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    function GetObjectTypeTranslationSettings(const AIdObjectType: Integer): TObjectTypeTranslationSettings; virtual; stdcall; abstract;
    ///<summary>Procedure removing an Object_Type_Translation.</summary>
    ///<param name="AIdObjectType">The identifier of the Object_Type_Translation to remove.</param>
    procedure RemoveObjectTypeTranslationSettings(const AIdObjectType: Integer); virtual; stdcall; abstract;
    ///<summary>Procedure importing the translations of the given po file.</summary>
    ///<param name="AFilePath">The path of the po file.</param>
    procedure Import(const AFilePath: string); virtual; stdcall; abstract;
    ///<summary>Procedure purging the translation. Removing unused translations.</summary>
    ///<param name="AFilePath">The path of the po file.</param>
    procedure ResetAndImport(const AFilePath: string); virtual; stdcall; abstract;
    ///<summary>Procedure generating a translation template file.</summary>
    function ToPOFile(const AFilePath: string): string; virtual; stdcall; abstract;
    ///<summary>Function translating a Text into the active language.</summary>
    ///<param name="AText">The text to translate.</param>
    function _Tx(const AText: string): string; virtual; stdcall; abstract;
    ///<summary>Function returning the existing translation of a given text of a given Data Type. </summary>
    ///<summary>This function is to use on elements that depends on the language. </summary>
    ///<param name="ADataType">The Data Type.</param>
    ///<param name="AText">The text to translate.</param>
    ///<param name="AIdObjectType">The identifier Object Type in case of translation depending on more complex settings.</param>
    function Translate(const ADataType: Integer; const AText: string; const AIdObjectType: Integer=0): string; virtual; stdcall; abstract;
    ///<summary>Function checking if a given concept is translatable.</summary>
    ///<param name="ADataType">The TD of the Object.</param>
    ///<param name="AIdObjectType">The identifier Object Type in case of translation depending on more complex settings.</param>
    function IsTranslatable(const ADataType: Integer; const AIdObjectType: Integer=0): Boolean; virtual; stdcall; abstract;
    function UpdateTranslation(const ADataType: Integer; const ALeft: string; const ARight: string; const AIdObjectType: Integer=0): Boolean; virtual; stdcall; abstract;
  end;

  TCreate_Language=function: TT_Language; stdcall;
  {$ENDREGION}

  {$REGION 'U_Language_Manager'}
  ///<summary>Function returning the "translated" filename corresponding to a given filename if existing for the current language code. For example, "extraction.xlt" - "extraction_en.xlt"</summary>
  ///<param name="APath_File">The filename.</param>
  T_Path=function(const APath_File: string): string; stdcall;

  ///<summary>Function returning the list of TT_Language objects loaded.</summary>
  TGet_OL_Language=function: TObjectList; stdcall;

  ///<summary>Function returning a Language object.</summary>
  ///<param name="AID_Language">The identifier of the Language.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Language=function(const AID_Language: Integer; const ARaiseException: Boolean=True): TT_Language; stdcall;

  ///<summary>Function returning the active language object.</summary>
  TGet_Active_Language=function: TT_Language; stdcall;

  ///<summary>Function returning the active language's code.</summary>
  TGet_Active_Language_Code=function: string; stdcall;

  ///<summary>Function returning the active language's identifier.</summary>
  TGet_Active_Language_ID=function: Integer; stdcall;

  ///<summary>Procedure setting the active language.</summary>
  ///<param name="AID_Language">The language identifier.</param>
  TSet_Active_Language=procedure(const AID_Language: Integer); stdcall;

  ///<summary>Function returning the name of a given Language.</summary>
  ///<param name="AID_Language">The identifier of the Language.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Language_Name=function(const AID_Language: Integer; const ARaiseException: Boolean=True): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_IO'}
  ///<summary>Input/Output Types (Input or Output).</summary>
  TIOType=(
    ///Input
    iotInput,
    ///Output
    iotOutput);

  ///<summary>Input/Output natures. The nature is different from the type: text, numerical or undefined).</summary>
  TIONature=(
    ///Yndefined.
    ionUndefined,
    ///Text IO.
    ionText,
    ///Numerical IO (integer or double).
    ionNumerical);

  ///<summary>Class enabling to store information contained into the MA_IO table.</summary>
  TMA_IO=class(TNamed_Object)
  public
    procedure SetIOType(const AIOType: TIOType); virtual; stdcall; abstract;
    function GetIOType: TIOType; virtual; stdcall; abstract;
    procedure SetCell(const ACell: string); virtual; stdcall; abstract;
    function GetCell: string; virtual; stdcall; abstract;
    procedure SetWorksheet(const AWorksheet: string); virtual; stdcall; abstract;
    function GetWorksheet: string; virtual; stdcall; abstract;
    procedure SetIdModel(const AIdModel: Integer); virtual; stdcall; abstract;
    function GetIdModel: Integer; virtual; stdcall; abstract;
    procedure SetIONature(const AIONature: TIONature); virtual; stdcall; abstract;
    function GetIONature: TIONature; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TMA_IO with the default constructor.</summary>
  TCreate_IO=function: TMA_IO; stdcall;
  {$ENDREGION}

  {$REGION 'U_Model'}
  ///<summary>Model's types.</summary>
  TModelType=(
    ///Model calling a dll.
    ///It is mainly defined by a relative file path to the dll and a function to call.
    ///The function must be of type "TDllFunction".
    ///The Inputs are set into the array of const of the TDllFunction function.
    ///The Output are read from the TArr_VarRec array returned by the the TDD_function function.
    mtDll,
    ///Model using an excel file
    ///It is mainly defined by a relative file path to the excel file. A macro can be called (no Inputs, no Output).
    ///The Inputs are written into defined cells.
    ///The Outputs are read from defined cells.
    ///<example>public sub Treat_Model()</example>
    mtExcel,
    ///Model using an executable.
    ///The inputs are written into an xml file.
    ///The outputs are read from an xml file.
    mtExecutable,
    ///ASP WEB model.
    mtASPModel,
    ///Model allowing to show/hide parts of the form.
    mtGroupVisibility);

  ///<summary>Class enabling to store information contained into the MA_Model table.</summary>
  TMA_Model=class(TNamed_Object)
  public
    procedure RetrieveModelDescription; virtual; stdcall; abstract;
    procedure SetRFilePath(const ARFilePath: string); virtual; stdcall; abstract;
    function GetRFilePath: string; virtual; stdcall; abstract;
    function GetFilePath: string; virtual; stdcall; abstract;
    procedure SetFunctionName(const AFunctionName: string); virtual; stdcall; abstract;
    function GetFunctionName: string; virtual; stdcall; abstract;
    procedure SetModelType(const AModelType: TModelType); virtual; stdcall; abstract;
    function GetModelType: TModelType; virtual; stdcall; abstract;
    procedure SetWait(const AWait: Boolean); virtual; stdcall; abstract;
    function GetWait: Boolean; virtual; stdcall; abstract;
    procedure SetInputsFilePath(const APath_File_Inputs: string); virtual; stdcall; abstract;
    function GetInputsFilePath: string; virtual; stdcall; abstract;
    procedure SetOutputsFilePath(const APath_File_Outputs: string); virtual; stdcall; abstract;
    function GetOutputsFilePath: string; virtual; stdcall; abstract;
    function GetOlInput: TObjectList; virtual; stdcall; abstract;
    function GetOlOutput: TObjectList; virtual; stdcall; abstract;
    procedure SetKeepLoaded(const AKeep_Loaded: Boolean); virtual; stdcall; abstract;
    function GetKeepLoaded: Boolean; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TMA_Model object using the default constructor.</summary>
  TCreate_Model=function: TMA_Model; stdcall;
  {$ENDREGION}

  {$REGION 'U_Equivalence'}
  ///<summary>Abstract class for the equivalences.</summary>
  ///<summary>An equivalence can be basically defined as an equality : ID_Left=ID_Right</summary>
  ///<summary>For all equivalence, the left identifier is an integer value.</summary>
  ///<summary>This class defines this left part. It cannot be used since the right idenfier </summary>&gt;
  ///<summary>is not defined yet.</summary>
  ///<summary>An equivalence may be related to an equivalence set.</summary>
  TEq_Equivalence=class(TTree_Object)
  public
    function Get_iAction: TDB_Action; virtual; stdcall; abstract;
    procedure SetIdEquivalencesSet(const AIdEquivalencesSet: Integer); virtual; stdcall; abstract;
    function GetIdEquivalencesSet: Integer; virtual; stdcall; abstract;
    function Get_ID_Left: Integer; virtual; stdcall; abstract;
    procedure Set_ID_Left(const AID_Left: Integer); virtual; stdcall; abstract;
    function Get_sID_Right: string; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_iEquivalence'}
  ///<summary>Equivalence between an integer and an integer.</summary>
  TEq_iEquivalence=class(TEq_Equivalence)
  public
    ///<summary>Setter for the variable "ID_Right".</summary>
    ///<summary>The identifier on the right of the equality ID_Left=ID_Right.</summary>
    procedure Set_ID_Right(const AID_Right: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Right".</summary>
    ///<summary>The identifier on the right of the equality ID_Left=ID_Right.</summary>
    function Get_ID_Right: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>function creating a identifier equivalence beetween Objects or Attributes.</summary>
  TCreate_Eq_iEquivalence=function: TEq_iEquivalence; stdcall;

  ///<summary>Function returning a TEq_iEquivalence thanks to its right identifier.</summary>
  ///<param name="AOL_Equivalences">The list of TEq_iEquivalence objects to search into.</param>
  ///<param name="AID_Right">The right identifier to search.</param>
  ///<param name="ARight_Sorted">If true, the list is supposed to be right sorted. This accelerates the searching process.</param>
  TGet_iEquivalence_From_Right=function(const AOL_Equivalences: TObjectList; const AID_Right: Integer; const ARight_Sorted: Boolean): TEq_iEquivalence; stdcall;

  ///<summary>Function returning a TEq_iEquivalence thanks to its Left identifier.</summary>
  ///<param name="AOL_Equivalences">The list of TEq_iEquivalence objects to search into.</param>
  ///<param name="AID_Left">The left identifier to search.</param>
  ///<param name="ALeft_Sorted">If true, the list is supposed to be left sorted. This accelerates the searching process.</param>
  TGet_iEquivalence_From_Left=function(const AOL_Equivalences: TObjectList; const AID_Left: Integer; const ALeft_Sorted: Boolean): TEq_iEquivalence; stdcall;
  {$ENDREGION}

  {$REGION 'U_sEquivalence'}
  ///<summary>Equivalence between an integer and a string.</summary>
  TEq_sEquivalence=class(TEq_Equivalence)
  public
    ///<summary>Setter for the variable "sID_Right".</summary>
    ///<summary>The identifier on the right of the equality ID_Left=ID_Right.</summary>
    procedure Set_ID_Right(const AID_Right: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sID_Right".</summary>
    ///<summary>The identifier on the right of the equality ID_Left=ID_Right.</summary>
    function Get_ID_Right: string; virtual; stdcall; abstract;
  end;

  TCreate_Eq_sEquivalence=function: TEq_sEquivalence; stdcall;

  ///<summary>Function returning a TEq_sEquivalence thanks to its right identifier.</summary>
  ///<param name="AOL_Equivalences">The list of TEq_sEquivalence objects to to search into.</param>
  ///<param name="AID_Right">The right identifier to search.</param>
  ///<param name="ARight_Sorted">If true, the list is supposed to be right sorted. This accelerates the searching process.</param>
  TGet_sEquivalence_From_Right=function(const AOL_Equivalences: TObjectList; const AID_Right: string; const ARight_Sorted: Boolean): TEq_sEquivalence; stdcall;
  {$ENDREGION}

  {$REGION 'U_Eq_Attribute_ID'}
  ///<summary>Class containing informations of the table "Eq_S_Attribute_ID".</summary>
  ///<summary>It enables to relate a (TEEXMA) Attribute to an other object described by an integer identifier.</summary>
  TEq_Attribute_ID=class(TEq_iEquivalence);

  TCreate_Eq_Attribute_ID=function: TEq_Attribute_ID; stdcall;
  {$ENDREGION}

  {$REGION 'U_Eq_Attribute_sID'}
  ///<summary>Class containing informations of the table "Eq_S_Attribute_sID".</summary>
  ///<summary>It enables to relate a (TEEXMA) Attribute to an other object described by a string identifier.</summary>
  TEq_Attribute_sID=class(TEq_sEquivalence);

  TCreate_Eq_Attribute_sID=function: TEq_Attribute_sID; stdcall;
  {$ENDREGION}

  {$REGION 'U_Eq_Object_Attribute'}
  ///<summary>Class containing informations of the table "Eq_S_Object_S_Attribute".</summary>
  ///<summary>It links a TEEXMA S_Object to an other TEEXMA Attribute identifier.</summary>
  TEq_Object_Attribute=class(TEq_iEquivalence);

  TCreate_Eq_Object_Attribute=function: TEq_Object_Attribute; stdcall;
  {$ENDREGION}

  {$REGION 'U_Eq_Object_ID'}
  ///<summary>Class containing informations of the table "Eq_S_Object_ID".</summary>
  ///<summary>It enables to relate a (TEEXMA) Object to an other object described by an integer identifier.</summary>
  TEq_Object_ID=class(TEq_iEquivalence);

  TCreate_Eq_Object_ID=function: TEq_Object_ID; stdcall;
  {$ENDREGION}

  {$REGION 'U_Eq_Object_sID'}
  ///<summary>Class containing informations of the table "Eq_S_Object_sID".</summary>
  ///<summary>It enables to relate a (TEEXMA) Object to an other object described by a string identifier.</summary>
  TEq_Object_sID=class(TEq_sEquivalence);

  TCreate_Eq_Object_sID=function: TEq_Object_sID; stdcall;
  {$ENDREGION}

  {$REGION 'U_Equivalence_Set'}
  ///<summary>TEquivalence_Set_Type: listing of the different type of Equivalence Sets.</summary>
  TEquivalence_Set_Type=(
    ///TEEXMA Object / integer identifier.
    estObject_ID,
    ///TEEXMA Object / string identifier.
    estObject_sID,
    ///TEEXMA Attribute / integer identifier.
    estAttribute_ID,
    ///TEEXMA Attribute / string identifier.
    estAttribute_sID,
    ///TEEXMA Object / TEEXMA Attribute.
    estObject_Attribute);

  ///<summary>Class containing informations of the table "Eq_Equivalence_Set".</summary>
  ///<summary>It also contains a list of object derived from "TEq_Equivalence".</summary>
  ///<summary>The class of these objects depends on the attribute iEquivalence_Set_Type.</summary>
  ///<summary>(See Create_OL_Equivalence_Set for more details).</summary>
  TEq_Equivalence_Set=class(TTree_Object)
  public
    ///<summary>Getter for the variable "OL_Equivalence".</summary>
    ///<summary>List of Equivalences.</summary>
    function Get_OL_Equivalence: TObjectList; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iEquivalence_Set_Type".</summary>
    ///<summary>Type of Equivalences of the Equivalences Set (See "TEquivalence_Set_Type" for more details).</summary>
    function Get_Equivalence_Set_Type: TEquivalence_Set_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iEquivalence_Set_Type".</summary>
    ///<summary>Type of Equivalences of the Equivalences Set (See "TEquivalence_Set_Type" for more details).</summary>
    procedure Set_Equivalence_Set_Type(AiEquivalence_Set_Type: TEquivalence_Set_Type); virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Applied_IO'}
  ///<summary>indicating the source of data for applied Input and the type of applied Output.</summary>
  TAppliedIOType=(
    ///The applied Input is a constant.
    aiotConst,
    ///The applied Input is the current Object Type.
    aiotObjectType,
    ///The applied Input is the current Object. The applied Output is an Object to display.
    aiotObject,
    ///The applied input or output are data.
    aiotData,
    ///The applied input is an equivalence Set.
    aiotEquivalencesSet,
    ///The applied output is the object's name.
    aiotObjectName,
    ///The applied output is a file path to a banner to display.
    aiotBanner,
    ///The applied input is the current user.
    aiotActiveUser,
    ///The applied input the path to TEEXMA.
    aiotTEEXMAPath,
    ///The applied input is the OUT object of the application (do not use).
    aiotOUT,
    ///The applied input is the identifier of the Model Application.
    aiotMA,
    ///The applied output is an HTML code to incorporate into the web page that triggered the application.
    aiotHTMLFlow,
    ///The applied I/O is an xml flow.
    aiotXMLFlow,
    ///The applied input is a list of triggering Attributes.
    aiotTriggers,
    ///??
    aiotDataAndSources,
    ///The applied I/O is an xml file.
    aiotXMLFile,
    ///The applied output is a message to display.
    aiotMessage,
    ///The applied output is an instruction for reloading the structure.
    aiotReloadStructure);

  ///<summary>Aggregation functions for the TMA_Applied_IO.</summary>
  TDataAggregationFunction=(
    ///No aggregation function defined.
    dafNone,
    ///The data and objects are sent as an xml flow.
    dafXMLFlow,
    ///The data are summed.
    dafSum,
    ///The data are multiplicated (for numerical Attributes only).
    dafProduct,
    ///The mean value is used.
    dafMeanValue,
    ///The standard deviation is used.
    dafStdDev,
    ///The min value is used.
    dafMinValue,
    ///The max value is used.
    dafMaxValue,
    ///The data and object are sent are saved into an xml flow.
    dafXMLFile);

  ///<summary>Class enabling to store information contained into the MA_Applied_IO table.</summary>
  TMA_Applied_IO=class(TTree_Object)
  public
    procedure Set_Attribute_Set(const AAttribute_Set: TS_Attribute_Set); virtual; stdcall; abstract;
    procedure Set_ID_OT(const AID_OT: Integer); virtual; stdcall; abstract;
    function Get_ID_Attribute_Set: Integer; virtual; stdcall; abstract;
    procedure SetIdIO(const AIdIO: Integer); virtual; stdcall; abstract;
    function GetIdIO: Integer; virtual; stdcall; abstract;
    procedure SetIdModelApplication(const AIdModelApplication: Integer); virtual; stdcall; abstract;
    function GetIdModelApplication: Integer; virtual; stdcall; abstract;
    procedure SetDefaultValue(const ADefaultValue: string); virtual; stdcall; abstract;
    function GetDefaultValue: string; virtual; stdcall; abstract;
    procedure SetAggregationFunction(const AAggregation_Function: TDataAggregationFunction); virtual; stdcall; abstract;
    function GetAggregationFunction: TDataAggregationFunction; virtual; stdcall; abstract;
    procedure SetAppliedIOType(const AAppliedIOType: TAppliedIOType); virtual; stdcall; abstract;
    function GetAppliedIOType: TAppliedIOType; virtual; stdcall; abstract;
    procedure SetIdEquivalencesSet(const AIdEquivalencesSet: Integer); virtual; stdcall; abstract;
    function GetIdEquivalencesSet: Integer; virtual; stdcall; abstract;
    procedure SetTrigger(const ATrigger: Boolean); virtual; stdcall; abstract;
    function GetTrigger: Boolean; virtual; stdcall; abstract;
    function Get_Attribute_Set: TS_Attribute_Set; virtual; stdcall; abstract;
    function GetSourceFilePath: string; virtual; stdcall; abstract;
    procedure SetSourceFilePath(const ASourceFilePath: string); virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TMA_Applied_IO with the default constructor.</summary>
  TCreate_Applied_IO=function: TMA_Applied_IO; stdcall;
  {$ENDREGION}

  {$REGION 'U_Model_Application'}
  ///<summary>Read/write modes.</summary>
  TReadWriteMode=(
    ///Read mode.
    rwmRead,
    ///Write mode.
    rwmWrite,
    ///Read or write mode.
    rwmBoth,
    ///The read or write
    rwmUndefined);

  ///<summary>Event triggering the execution of a model application.</summary>
  TMAEvent=(
    ///None defined.
    eUndefined,
    ///The application is displayed into the main application menu.
    eModelApplicationMenu,
    ///The application is triggered on the modification of one of its "Attribute" inputs or one of its triggering inputs.
    eOnDataChange,
    ///The application is displayed into the Object Popup Menu.
    eObjectContextMenu,
    ///The application is display into th main application toolbar.
    eToolBar,
    ///The appliation is triggered when the object is shown.
    eOnShowObject,
    ///The application is triggered after the user connection into TEEXMA.
    eAfterAuthentication,
    ///The application is triggered after an object creation.
    eAfterObjectCreation,
    ///The application is triggered after an object is moved.
    eOnObjectMoved,
    ///The application is triggered when a special tab is shown.
    eOnTabDisplay,
    ///The application is triggered after an checking event into a link form.
    eOnObjectChecked,
    ///The application is triggered when an object is removed.
    eOnObjectDeletion,
    ///System Application.
    eSystem,
    ///The application is triggered after an advanced duplication.
    eOnAdvancedDuplication,
    ///The application is triggered after an advanced creation.
    eOnAdvancedCreation);

  TMAEvents=set of TMAEvent;

  ///<summary>Model's display types. If defined, it prevails on the application settings.</summary>
  TModelDisplayMode=(
    ///No visibility defined: the application settin is used.
    mdmUndefined,
    ///The model is always visible.
    mdmVisible,
    ///The model is always hidden.
    mdmHidden);

  ///<summary>Compatibility modes of a model application.</summary>
  TModelCompatibilityMode=(
    ///The application is compatible with both the windows and web version.
    mcmBoth,
    ///The application is compatible with the windows version only.
    mcmWindows,
    ///The application is compatible with the web version only.
    mcmWEB);

  TObjectTypeDependency=(
    otdOne,
    otdNone,
    otdAll);

  TObjectDependency=(
    odASingleOne,
    odNone,
    odZeroToOne,
    odMany);

  ///<summary>Class enabling to store information contained into the MA_Model_Application table.</summary>
  TMA_Model_Application=class(TOTObject)
  public
    procedure AssignModel(const AModel: TMA_Model); virtual; stdcall; abstract;
    procedure SetIdModel(const AIdModel: Integer); virtual; stdcall; abstract;
    function GetIdModel: Integer; virtual; stdcall; abstract;
    procedure SetEvent(const AEvent: TMAEvent); virtual; stdcall; abstract;
    function GetEvent: TMAEvent; virtual; stdcall; abstract;
    procedure SetDisplayMode(const ADisplayMode: TModelDisplayMode); virtual; stdcall; abstract;
    function GetDisplayMode: TModelDisplayMode; virtual; stdcall; abstract;
    procedure SetCompatibilityMode(const ACompatibilityMode: TModelCompatibilityMode); virtual; stdcall; abstract;
    function GetCompatibilityMode: TModelCompatibilityMode; virtual; stdcall; abstract;
    procedure SetIconRFilePath(const AIconRFilePath: string); virtual; stdcall; abstract;
    function GetIconRFilePath: string; virtual; stdcall; abstract;
    function GetIconFilePath: string; virtual; stdcall; abstract;
    function GetOlAppliedInput: TObjectList; virtual; stdcall; abstract;
    function GetOlAppliedOutput: TObjectList; virtual; stdcall; abstract;
    function GetAppliedInput(const AOrder: Integer): TMA_Applied_IO; virtual; stdcall; abstract;
    function GetAppliedOutput(const AOrder: Integer): TMA_Applied_IO; virtual; stdcall; abstract;
    function GetAppliedInputDefaultValue(const AOrder: Integer): string; virtual; stdcall; abstract;
    function GetTriggersInput(const ACreateIfNeeeded: Boolean=False): TMA_Applied_IO; virtual; stdcall; abstract;
    procedure RemoveTriggersInput; virtual; stdcall; abstract;
    procedure SetReadWriteMode(const AReadWriteMode: TReadWriteMode); virtual; stdcall; abstract;
    function GetReadWriteMode: TReadWriteMode; virtual; stdcall; abstract;
    procedure SetAllowCascade(const AAllowCascade: Boolean); virtual; stdcall; abstract;
    function GetAllowCascade: Boolean; virtual; stdcall; abstract;
    procedure SetEnabled(const AEnabled: Boolean); virtual; stdcall; abstract;
    function GetEnabled: Boolean; virtual; stdcall; abstract;
    procedure SetObjectDependency(const AObjectDependency: TObjectDependency); virtual; stdcall; abstract;
    function GetObjectDependency: TObjectDependency; virtual; stdcall; abstract;
    procedure SetObjectTypeDependency(const AObjectTypeDependency: TObjectTypeDependency); virtual; stdcall; abstract;
    function GetObjectTypeDependency: TObjectTypeDependency; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TMA_Model_Application object using the default constructor.</summary>
  TCreate_Model_Application=function: TMA_Model_Application; stdcall;
  {$ENDREGION}

  {$REGION 'U_Exportation'}
  ///<summary>Exportation types.</summary>
  TExportation_Type=(
    ///Word exportation.
    extWord,
    ///Excel exportation.
    extExcel,
    ///Text exportation.
    extText,
    ///XML exportation.
    extXML,
    ///File exportation (only files are exportated).
    extFile);

  ///<summary>Object preselection types.</summary>
  TObject_Preselection_Type=(
    ///Manual preselection.
    optManual,
    ///A result of multicriteria selection.
    optMCS,
    ///Objects modified since the last exportation.
    optLog);

  ///<summary>Class handling an Exportation. It allows to write settings into the database and to execute it.</summary>
  TE_Exportation=class(TOTObject)
  public
    function Get_CompleteName: string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTranspose".</summary>
    ///<summary>If true, the "table" of data is transposed (specific to the csv and excel exportations).</summary>
    function Get_Transpose: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "Attribute_Set".</summary>
    ///<summary>The attribute set associated to the exportation.</summary>
    procedure Set_Attribute_Set(const AAttribute_Set: TS_Attribute_Set); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "Attribute_Set".</summary>
    ///<summary>The attribute set associated to the exportation.</summary>
    function Get_Attribute_Set: TS_Attribute_Set; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "RL".</summary>
    ///<summary>The Requirement list associated to the exportation (in case of a preselection of object based on a multicriteria selection).</summary>
    procedure Set_RL(const ARL: TMCS_Requirement_List); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "RL".</summary>
    ///<summary>The Requirement list associated to the exportation (in case of a preselection of object based on a multicriteria selection).</summary>
    function Get_RL: TMCS_Requirement_List; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bInclude_Object_Name".</summary>
    ///<summary>If false, the objects names are not exportated (specific to the csv and excel exportations). It is usefull for some specific table exportation.</summary>
    procedure Set_Include_Object_Name(const AInclude_Object_Name: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bInclude_Object_Name".</summary>
    ///<summary>If false, the objects names are not exportated (specific to the csv and excel exportations). It is usefull for some specific table exportation.</summary>
    function Get_Include_Object_Name: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bFormat_Data".</summary>
    ///<summary>If true, data are formated before beeing exportated (specific to the word exportation).</summary>
    procedure Set_Format_Data(const AFormat_Data: Boolean); virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sXltFilename".</summary>
    ///<summary>In case of an xml exportation, an xlt file to apply.</summary>
    procedure Set_XLTFilename(const AXLTFilename: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sXltFilename".</summary>
    ///<summary>In case of an xml exportation, an xlt file to apply.</summary>
    function Get_XLTFileName: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iType".</summary>
    ///<summary>The type of exportation (xml, excel, aso).</summary>
    procedure Set_Type(const AType: TExportation_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iType".</summary>
    ///<summary>The type of exportation (xml, excel, aso).</summary>
    function Get_Type: TExportation_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bZip".</summary>
    ///<summary>If true, the exported file is zipped (7z format).</summary>
    procedure Set_Zip(const AZip: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bZip".</summary>
    ///<summary>If true, the exported file is zipped (7z format).</summary>
    function Get_Zip: Boolean; virtual; stdcall; abstract;
    procedure Set_Base_Filename(const ABase_Filename: string); virtual; stdcall; abstract;
    function Get_Base_Filename: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sDir".</summary>
    ///<summary>The directory where to save the file.</summary>
    procedure Set_Dir(const ADir: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sDir".</summary>
    ///<summary>The directory where to save the file.</summary>
    function Get_Dir: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bVisible".</summary>
    ///<summary>If true, the exportation is visible for the user into the exportation function.</summary>
    procedure Set_Visible(const AVisible: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bVisible".</summary>
    ///<summary>If true, the exportation is visible for the user into the exportation function.</summary>
    function Get_Visible: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bModifiable".</summary>
    ///<summary>If true, the preeselection of Attribute and Objects is modifiable by the use.</summary>
    procedure Set_Modifiable(const AModifiable: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bModifiable".</summary>
    ///<summary>If true, the preeselection of Attribute and Objects is modifiable by the use.</summary>
    function Get_Modifiable: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bInclude_Header".</summary>
    ///<summary>If true, a header must be added to the file exportated (specific to the excel, csv and xml exportations).</summary>
    procedure Set_Include_Header(const AInclude_Header: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bInclude_Header".</summary>
    ///<summary>If true, a header must be added to the file exportated (specific to the excel, csv and xml exportations).</summary>
    function Get_Include_Header: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iXML_Verbosity".</summary>
    ///<summary>The xml verbosity (specific to the xml exportation).</summary>
    procedure Set_XML_Verbosity(const AXML_Verbosity: TVerbosity); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iXML_Verbosity".</summary>
    ///<summary>The xml verbosity (specific to the xml exportation).</summary>
    function Get_XML_Verbosity: TVerbosity; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bInclude_Sources".</summary>
    ///<summary>If true, source and their data are exportated (specific to the xml exportation).</summary>
    procedure Set_Include_Sources(const AInclude_Sources: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bInclude_Sources".</summary>
    ///<summary>If true, source and their data are exportated (specific to the xml exportation).</summary>
    function Get_Include_Sources: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iOPT".</summary>
    ///<summary>The object preselection type (multicriteria selection, db logs, manual).</summary>
    procedure Set_OPT(const AOPT: TObject_Preselection_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iOPT".</summary>
    ///<summary>The object preselection type (multicriteria selection, db logs, manual).</summary>
    function Get_OPT: TObject_Preselection_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bInclude_Date".</summary>
    ///<summary>If true, the date is included into the filename of the exportated file.</summary>
    procedure Set_Include_Date(const AInclude_Date: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bInclude_Date".</summary>
    ///<summary>If true, the date is included into the filename of the exportated file.</summary>
    function Get_Include_Date: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Log".</summary>
    ///<summary>The identifier of db log to use (specific to the preselection based on db logs).</summary>
    procedure Set_ID_Log(const AID_Log: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Log".</summary>
    ///<summary>The identifier of db log to use (specific to the preselection based on db logs).</summary>
    function Get_ID_Log: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sSeparator_Column".</summary>
    ///<summary>The column separator (specific to the csv exportation).</summary>
    procedure Set_Separator_Column(const ASeparator_Column: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sSeparator_Column".</summary>
    ///<summary>The column separator (specific to the csv exportation).</summary>
    function Get_Separator_Column: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sSeparator_Data".</summary>
    ///<summary>The data separator (specific to the csv exportation).</summary>
    procedure Set_Separator_Data(const ASeparator_Data: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sSeparator_Data".</summary>
    ///<summary>The data separator (specific to the csv exportation).</summary>
    function Get_Separator_Data: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDefault".</summary>
    ///<summary>If true, the exportation is selected by default into the exportation function (for the relevant Object Type).</summary>
    procedure Set_Default(const ADefault: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDefault".</summary>
    ///<summary>If true, the exportation is selected by default into the exportation function (for the relevant Object Type).</summary>
    function Get_Default: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iTag".</summary>
    ///<summary>A Tag equal to 0 in case of a user defined export.</summary>
    procedure Set_Tag(const ATag: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iTag".</summary>
    ///<summary>A Tag equal to 0 in case of a user defined export.</summary>
    function Get_Tag: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "ID_Action_Last_Treated".</summary>
    ///<summary>The identifier of the last log line treated (specific to the preselection based on db logs).</summary>
    procedure Set_ID_Action_Last_Treated(const AID_Action_Last_Treated: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "ID_Action_Last_Treated".</summary>
    ///<summary>The identifier of the last log line treated (specific to the preselection based on db logs).</summary>
    function Get_ID_Action_Last_Treated: Integer; virtual; stdcall; abstract;
    procedure Preselect_Objects(const ASL_ID_Object: TStringList=nil); overload; virtual; stdcall; abstract;
    procedure Preselect_Objects(const AID_Object: Integer); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(const AID_Attribute: Integer; const AInclude_Associative_Attributes: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(const AAttribute: TS_Attribute; const AInclude_Associative_Attributes: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(const AOL_Attribute: TObjectList; const AInclude_Associative_Attributes: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(const AAttribute_Set: TS_Attribute_Set); overload; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "SL_ID_Object".</summary>
    ///<summary>The object preselection.</summary>
    function Get_SL_ID_Object: TStringList; virtual; stdcall; abstract;
    function Get_FilePathTemplate: string; virtual; stdcall; abstract;
    function InitializeExecution: string; virtual; stdcall; abstract;
    procedure FinalizeExecution; virtual; stdcall; abstract;
    ///<summary>Function returning the path to the file to export.</summary>
    function Get_FilePathToSave(const AConsiderZipSettings: Boolean; const AInterpret: Boolean): string; virtual; stdcall; abstract;
    function Get_FileDirToSave(const AInterpret: Boolean): string; virtual; stdcall; abstract;
    function GetLinearize: Boolean; virtual; stdcall; abstract;
    procedure SetLinearize(const ALinearize: Boolean); virtual; stdcall; abstract;
  end;

  TExportationTypeToStr=function(const AType: TExportation_Type): string; stdcall;

  ///<summary>Function creating a TE_Exportation object with the default constructor.</summary>
  TCreate_Exportation=function(const AType: TExportation_Type): TE_Exportation; stdcall;
  {$ENDREGION}

  {$REGION 'U_SolRExternalServer'}
  TSolRExternalServer=class(TTree_Object)
  public
    procedure Set_WinDir(const AWinDir: string); virtual; stdcall; abstract;
    function Get_WinDir: string; virtual; stdcall; abstract;
    procedure Set_SolRDir(const ASolRDir: string); virtual; stdcall; abstract;
    function Get_SolRDir: string; virtual; stdcall; abstract;
    procedure Set_WebUrl(const AWebUrl: string); virtual; stdcall; abstract;
    function Get_WebUrl: string; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Connection_Settings'}
  ///<summary>Class storing the connection settings to the various databases (including directories).</summary>
  TA_Connection_Settings=class(TNamed_Object)
  public
    ///<summary>Setter for the variable "iDB_Type".</summary>
    ///<summary>The type of database.</summary>
    procedure Set_DB_Type(const ADB_Type: TDB_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iDB_Type".</summary>
    ///<summary>The type of database.</summary>
    function Get_DB_Type: TDB_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPath".</summary>
    ///<summary>The path to the database (this path may be only a relative path in case of a directory).</summary>
    procedure Set_Path(const APath: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPath".</summary>
    ///<summary>The path to the database (this path may be only a relative path in case of a directory).</summary>
    function Get_Path: string; virtual; stdcall; abstract;
    function Get_Path_Completed: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sLogin".</summary>
    ///<summary>The login to connect to the database.</summary>
    procedure Set_Login(const ALogin: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sLogin".</summary>
    ///<summary>The login to connect to the database.</summary>
    function Get_Login: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPassword".</summary>
    ///<summary>The password associated to the login of the database.</summary>
    procedure Set_Password(const APassword: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPassword".</summary>
    ///<summary>The password associated to the login of the database.</summary>
    function Get_Password: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iPort".</summary>
    ///<summary>The port of the database.</summary>
    procedure Set_Port(const APort: Integer); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iPort".</summary>
    ///<summary>The port of the database.</summary>
    function Get_Port: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iSQLServerAuthenticationType".</summary>
    ///<summary>The type of SQLServer authentication.</summary>
    procedure Set_SQLServerAuthenticationType(const ASQLServerAuthenticationType: TSQLServerAuthentication_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iSQLServerAuthenticationType".</summary>
    ///<summary>The type of SQLServer authentication.</summary>
    function Get_SQLServerAuthenticationType: TSQLServerAuthentication_Type; virtual; stdcall; abstract;
    ///<summary>Function returning the connection string to the database.</summary>
    ///<values>In case of a directory database, it returns the absolute path of the directory.</values>
    ///<values>In other cases, it returns the connection string using the "default" driver of the TxAPI.</values>
    function Get_ConnectionString: string; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TA_Connection_Settings object.</summary>
  TCreate_Connection_Settings=function: TA_Connection_Settings; stdcall;
  {$ENDREGION}

  {$REGION 'U_TEEXMA_Connection_Settings'}
  ///<summary>The authentification type (Internal or LDAP).</summary>
  TA_Authentification_Type=(
    ///Users are stored into the TEEXMA database.
    atTEEXMA,
    ///Users are stored into an LDAP database.
    atLDAP);

  TA_Automated_Connection_Type=(
    ///Manual connection: the login and password must be entered manually.
    actManual,
    ///A defaut user is connected.
    actDefault_User,
    ///The connection is tried to be done using the windows login.
    actWindows_Login);

  ///<summary>The LDAP authentification type.</summary>
  TA_LDAP_Authentification_Type=(
    ///Only the bind between login and password is done.
    latLogin,
    ///Besides login and password, the bind between the login and its Users Groups are also read from the LDAP directory.
    latLogin_And_Users_Groups);

  ///<summary>Class containing the informations of connection to the various databases of TEEXMA, the authentification type, language, aso.</summary>
  TA_TEEXMA_Connection_Settings=class(TObject)
  public
    ///<summary>Getter for the variable "sDir_CR_Completed".</summary>
    ///<summary>The absolute path to the customer resources.</summary>
    function Get_Dir_CR_Completed: string; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "Connection_Settings_DB".</summary>
    ///<summary>The connection settings for TEEXMA database.</summary>
    function Get_Connection_Settings_DB: TA_Connection_Settings; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "Connection_Settings_Archived_Files".</summary>
    ///<summary>The connection settings for the Archived Files database.</summary>
    function Get_Connection_Settings_Archived_Files: TA_Connection_Settings; virtual; stdcall; abstract;
    procedure Set_Dir_Customer_Resources(const ADir_CR: string); virtual; stdcall; abstract;
    function Get_Dir_Customer_Resources: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iAuthentification_Type".</summary>
    ///<summary>The authentification type (TEEXMA or LDAP).</summary>
    procedure Set_Authentification_Type(const AAuthentification_Type: TA_Authentification_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iAuthentification_Type".</summary>
    ///<summary>The authentification type (TEEXMA or LDAP).</summary>
    function Get_Authentification_Type: TA_Authentification_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iAutomated_Connection_Type".</summary>
    ///<summary>The automatated connection type.</summary>
    procedure Set_Automated_Connection_Type(const AAutomated_Connection_Type: TA_Automated_Connection_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iAutomated_Connection_Type".</summary>
    ///<summary>The automatated connection type.</summary>
    function Get_Automated_Connection_Type: TA_Automated_Connection_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sDefault_Login".</summary>
    ///<summary>In case of a automated connection with a default user: the login of the user.</summary>
    procedure Set_Default_Login(const ADefault_Login: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sDefault_Login".</summary>
    ///<summary>In case of a automated connection with a default user: the login of the user.</summary>
    function Get_Default_Login: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sPassword_Default_Login".</summary>
    ///<summary>The password associated to the default login.</summary>
    procedure Set_Password_Default_Login(const APassword_Default_Login: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sPassword_Default_Login".</summary>
    ///<summary>The password associated to the default login.</summary>
    function Get_Password_Default_Login: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bProhibit_Manual_Connection".</summary>
    ///<summary>If true, the manual connection will not be allowed.</summary>
    procedure Set_Prohibit_Manual_Connection(const AProhibit_Manual_Connection: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bProhibit_Manual_Connection".</summary>
    ///<summary>If true, the manual connection will not be allowed.</summary>
    function Get_Prohibit_Manual_Connection: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bStrong_Password".</summary>
    ///<summary>If true, the user password must respect somes rules.</summary>
    procedure Set_Strong_Password(const AStrong_Password: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bStrong_Password".</summary>
    ///<summary>If true, the user password must respect somes rules.</summary>
    function Get_Strong_Password: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bDisplay_Users_List".</summary>
    ///<summary>If true, the whole list of available users is displayed.</summary>
    procedure Set_Display_Users_List(const ADisplay_Users_List: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bDisplay_Users_List".</summary>
    ///<summary>If true, the whole list of available users is displayed.</summary>
    function Get_Display_Users_List: Boolean; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "OL_LDAP_Connection_Settings".</summary>
    ///<summary>Ordered list of LDAP connections settings.</summary>
    function Get_OL_LDAP_Connection_Settings: TObjectList; virtual; stdcall; abstract;
    function Get_OL_ExternalServersToIndex: TObjectList; virtual; stdcall; abstract;
    function Get_ExternalServersToIndex_Count: Integer; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sCode_Language".</summary>
    ///<summary>The code of the language. Example: en, fr, fi, zh.</summary>
    procedure Set_Code_Language(const ACode_Language: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sCode_Language".</summary>
    ///<summary>The code of the language. Example: en, fr, fi, zh.</summary>
    function Get_Code_Language: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sSolRUrl".</summary>
    ///<summary>The url to the SolR collection for the TEEXMA files.</summary>
    procedure Set_SolRUrl(const ASolRUrl: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sSolRUrl".</summary>
    ///<summary>The url to the SolR collection for the TEEXMA files.</summary>
    function Get_SolRUrl: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sSolRDir".</summary>
    ///<summary>The path to the documents as indicated into the SolR collection in case of files stored into a directory.</summary>
    procedure Set_SolRDir(const ASolrDir: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sSolRDir".</summary>
    ///<summary>The path to the documents as indicated into the SolR collection in case of files stored into a directory.</summary>
    function Get_SolRDir: string; virtual; stdcall; abstract;
    procedure Set_UrlSolRForExternalServers(const AUrlSolRForExternalServers: string); virtual; stdcall; abstract;
    function Get_UrlSolRForExternalServers: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iLDAP_Authentification_Type".</summary>
    ///<summary>A simple bind login/password or a full returning of the Users Groups.</summary>
    procedure Set_LDAP_Authentification_Type(const ALDAP_Authentification_Type: TA_LDAP_Authentification_Type); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iLDAP_Authentification_Type".</summary>
    ///<summary>A simple bind login/password or a full returning of the Users Groups.</summary>
    function Get_LDAP_Authentification_Type: TA_LDAP_Authentification_Type; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iAction".</summary>
    ///<summary>The action (adding, modification or deletion)</summary>
    procedure Set_Action(const AAction: TDB_Action); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "iAction".</summary>
    ///<summary>The action (adding, modification or deletion)</summary>
    function Get_Action: TDB_Action; virtual; stdcall; abstract;
    ///<summary>Procedure testing the connection sets.</summary>
    procedure Test_Connections; virtual; stdcall; abstract;
    procedure Write; virtual; stdcall; abstract;
  end;

  ///<summary>Funtion creating a TA_TEEXMA_Connection_Settings and filling it from the TEEXMA.exml file.</summary>
  ///<param name="AEdit_Mode">If true, no error is raised if the settings file is missing.</param>
  TCreate_TEEXMA_Connection_Settings=function(const AEdit_Mode: Boolean=True): TA_TEEXMA_Connection_Settings; stdcall;
  {$ENDREGION}

  {$REGION 'U_CS_LDAP'}
  ///<summary>Class containing the connection settings to an LDAP.</summary>
  TA_CS_LDAP=class(TA_Connection_Settings)
  public
    ///<summary>Setter for the variable "bActive_Directory".</summary>
    ///<summary>If true, the LDAP is an active directory.</summary>
    procedure Set_Active_Directory(const AActive_Directory: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bActive_Directory".</summary>
    ///<summary>If true, the LDAP is an active directory.</summary>
    function Get_Active_Directory: Boolean; virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sDNS_Domain".</summary>
    ///<summary>The DNS of the domain.</summary>
    function Get_DNS_Domain: string; virtual; stdcall; abstract;
    procedure Set_Root(const ARoot: string); virtual; stdcall; abstract;
    function Get_Root: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sField_Login".</summary>
    ///<summary>The field to use as "Login".</summary>
    procedure Set_Field_Login(const AField_Login: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sField_Login".</summary>
    ///<summary>The field to use as "Login".</summary>
    function Get_Field_Login: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sField_Name".</summary>
    ///<summary>The field to use as "Name".</summary>
    procedure Set_Field_Name(const AField_Name: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sField_Name".</summary>
    ///<summary>The field to use as "Name".</summary>
    function Get_Field_Name: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sField_Member_Of".</summary>
    ///<summary>The field to use as "Member of".</summary>
    procedure Set_Field_Member_Of(const AField_Member_Of: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sField_Member_Of".</summary>
    ///<summary>The field to use as "Member of".</summary>
    function Get_Field_Member_Of: string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sField_EMail".</summary>
    ///<summary>The field to use as "E-mail".</summary>
    procedure Set_Field_EMail(const AField_EMail: string); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "sField_EMail".</summary>
    ///<summary>The field to use as "E-mail".</summary>
    function Get_Field_EMail: string; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TA_CS_LDAP object using its default constructor.</summary>
  TCreate_CS_LDAP=function: TA_CS_LDAP; stdcall;
  {$ENDREGION}

  {$REGION 'U_Connection'}
  ///<summary>List of data may be numbered into the read or write form.</summary>
  TData_Numbering_Type=(
    ///Lists are not numbered.
    dntNone,
    ///Lists are numerically numbered.
    dntNumerical,
    ///Lists are alphabetically numbered.
    dntAlphabetical);

  ///<summary>Function returning the database's connection object.</summary>
  ///<param name="ARaise_Exception">If true, the function raises an ETxAPI_Connection_Not_Defined error if the connection object is not initialized.</param>
  TGet_TxAPIConnection=function(const ARaise_Exception: Boolean=True): TObject; stdcall;

  ///<summary>Procedure enabling to set the TxAPI rExcel_Retrieve_Results that enables to know if the user desires to retrieve the results.</summary>
  ///<param name="AExcel_Retrieve_Results">The reference to the method.</param>
  TSet_Excel_Retrieve_Results=procedure(const AExcel_Retrieve_Results: TM_Get_Boolean); stdcall;

  ///<summary>Function returning the TEEXMA Temporary folder created into the windows user temp folder.</summary>
  ///<param name="ACreateAUniqueSubFolder">If true,the function creates a unique sub folder into the TEEXMA TEMP folder.</param>
  TGet_Dir_TEEXMA_Temp=function(const ACreateAUniqueSubFolder: Boolean=False): string; stdcall;

  ///<summary>Function returning the TEEXMA directory.</summary>
  TGet_Dir_TEEXMA=function: string; stdcall;

  ///<summary>Function retuning the direction of the Administration folder.</summary>
  TGet_Dir_Administration=function: string; stdcall;

  ///<summary>Function returning the path of the file "&lt;Administration.exe"</summary>
  TGet_Path_File_Administration_EXE=function: string; stdcall;

  ///<summary>Function returning the folder of the archived files.</summary>
  TGet_Dir_Archived_Files=function: string; stdcall;

  ///<summary>Function returning the path to the customer resources folder.</summary>
  TGet_Dir_Customer_Resources=function: string; stdcall;

  ///<summary>Function returning the path to resources folder.</summary>
  TGet_Dir_Resources=function: string; stdcall;

  ///<summary>Function returning the path to the folder "Exportations" of the resources.</summary>
  TGet_Dir_Exportations=function: string; stdcall;

  ///<summary>Function returning the path to the picture file "24x24_No_Model.bmp".</summary>
  TGet_Path_File_No_Model_BMP=function: string; stdcall;

  ///<summary>Function returning the HTML folder of the resources.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_HTML=function: string; stdcall;

  ///<summary>Function returning the Graphs folder of the resources.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Graphs=function: string; stdcall;

  ///<summary>Function returning the path of the folder containing the Excel models for the tables.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Lib_Graphs=function: string; stdcall;

  ///<summary>Function returning the path of the file "Home.html".</summary>
  ///<values>It tries to find it first a file into the customer resources. If not found, it returns the default file located into the resources.</values>
  TGet_Path_File_Home_HTML=function: string; stdcall;

  ///<summary>Function returning the path of the folder "Pictures".</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Pictures=function: string; stdcall;

  ///<summary>Function returning the path of the folder for the buttons pictures.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Pictures_Buttons=function: string; stdcall;

  ///<summary>Function returning the path of the folder for the icons pictures.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Icons=function: string; stdcall;

  ///<summary>Function returning the path of the folder for the web icons pictures.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Icons_Web=function: string; stdcall;

  ///<summary>Function returning the path of the folder for the old icons pictures.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Icons_Old=function: string; stdcall;

  ///<summary>Function returning the path of the illustrations folder in the resources.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Illustrations=function: string; stdcall;

  ///<summary>Function returning the path of the file "Default.jpg" for the banner.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_File_Path_Banner_Default_JPG=function: string; stdcall;

  ///<summary>Function returning the path of the helps folder in the resources.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Helps=function: string; stdcall;

  ///<summary>Function returning the path of the extractions folder in the resources.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Dir_Extractions=function: string; stdcall;

  ///<summary>Function returning the path to the "Translations" folder into to the customer resources.</summary>
  TGet_Dir_CR_Translations=function: string; stdcall;

  ///<summary>Function returning the path of the file "TEEXMA.xsd".</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Path_File_TEEXMA_XSD=function: string; stdcall;

  ///<summary>Function returning the path to the "Extractions" folder into to the customer resources.</summary>
  TGet_Dir_CR_Extractions=function: string; stdcall;

  ///<summary>Function returning the path to the "Graphs" folder into to the customer resources.</summary>
  TGet_Dir_CR_Graphs=function: string; stdcall;

  ///<summary>Function returning the path to the "Models" folder into to the customer resources.</summary>
  TGet_Dir_CR_Models=function: string; stdcall;

  ///<summary>Function returning the path to the "Illustrations" folder into to the customer resources.</summary>
  TGet_Dir_CR_Illustrations=function: string; stdcall;

  ///<summary>Function returning the path to the "HTML" folder into to the customer resources.</summary>
  TGet_Dir_CR_HTML=function: string; stdcall;

  ///<summary>Function returning the path of the file "Folder.html" displaying the folder picture.</summary>
  ///<values>See the function Get_Dir_Resources for more details.</values>
  TGet_Path_File_Folder_HTML=function: string; stdcall;

  ///<summary>Function returning the path to the "Banners" folder into to the customer resources.</summary>
  TGet_Dir_CR_Banners=function: string; stdcall;

  ///<summary>Function returning the path to the "Portals" folder into to the customer resources.</summary>
  TGet_Dir_CR_Portals=function: string; stdcall;

  ///<summary>Function returning the path to the "Icons" folder into to the customer resources.</summary>
  TGet_Dir_CR_Icons=function: string; stdcall;

  ///<summary>Function returning the path to the web "Icons" folder into to the customer resources.</summary>
  TGet_Dir_CR_Icons_Web=function: string; stdcall;

  ///<summary>Function returning the path to the "Exportations" folder into to the customer resources.</summary>
  TGet_Dir_CR_Exportations=function: string; stdcall;

  ///<summary>Function returning true if files are stored into a database, false if they are stored onto a physical drive.</summary>
  TGet_Archived_File_Stored_In_DB=function: Boolean; stdcall;

  ///<summary>Function returning the connection string of the TEEXMA database.</summary>
  TGet_TEEXMA_ConnectionString=function: string; stdcall;

  ///<summary>Function returning the connection string of the TEEXMA file database.</summary>
  TGet_TEEXMA_Archived_File_ConnectionString=function: string; stdcall;

  ///<summary>Function returning the authentification type (internal or using an LDAP directory).</summary>
  TGet_Authentification_Type=function: TA_Authentification_Type; stdcall;

  ///<summary>Function returning the type of automated connection (automatic, automatic+manual, manual).</summary>
  TGet_Automated_Connection_Type=function: TA_Automated_Connection_Type; stdcall;

  ///<summary>Function returning true if the manual connection is forbidden.</summary>
  TGet_Prohibit_Manual_Connection=function: Boolean; stdcall;

  ///<summary>Function returning true if the users passwords must be "strong".</summary>
  TGet_Strong_Password=function: Boolean; stdcall;

  ///<summary>Function returning true if the connection form shows the list of existing users and false if it only displays a login field.</summary>
  TGet_Display_Users_List=function: Boolean; stdcall;

  ///<summary>Function returning the path to the offline help.</summary>
  TGet_Path_File_Help_PDF=function: string; stdcall;

  ///<summary>Function returning the name of the TEEXMA database.</summary>
  TGet_Name_DB=function: string; stdcall;

  ///<summary>Function returning the url of the TEEXMA database.</summary>
  TGet_Server_URL=function: string; stdcall;

  ///<summary>Function returning true if the current user logged using its windows ID.</summary>
  TGet_Logged_With_WSession=function: Boolean; stdcall;

  ///<summary>Function returning the default language code of the application.</summary>
  ///<returns>The function returns "fr" if no default code is defined into the connection settings.</returns>
  TGet_Default_Language_Code=function: string; stdcall;

  ///<summary>Function returning the path to the file "Preferences.ini".</summary>
  TGet_Path_File_Preferences_INI=function: string; stdcall;

  ///<summary>Function returning the built revision of the TxAPI.</summary>
  TGet_TxRevision=function: Integer; stdcall;

  ///<summary>Function returning the built revision of the TEEXMA Database for the TxAPI.</summary>
  ///<param name="ADev">If not empty, the query filters on the given devellopment.</param>
  TGet_DB_Revision=function(const ADev: string): Integer; stdcall;

  ///<summary>Function returning the built revision of the TEEXMA Database for the TxAPI.</summary>
  ///<param name="ARefresh">If true, the revision is read directly from the database. If not, the previously read value is sent.</param>
  TGet_TxDB_Revision=function(const ARefresh: Boolean=False): Integer; stdcall;

  ///<summary>Procedure setting the TxAPI IOut object. This object is used to log the TxAPI actions.</summary>
  ///<param name="AOut_Object">The IOut Object.</param>
  TSet_TxOut_Object=procedure(const AOut_Object: IOut); stdcall;

  ///<summary>Function returning the TxAPI IOut object.</summary>
  TGet_TxOut_Object=function: IOut; stdcall;

  ///<summary>Function to call before exiting a program. It releases the dll loaded and specifics to the current TEEXMA project.</summary>
  TFinalizeTxAPI=procedure; stdcall;

  ///<summary>Procedure initializing the TxAPI for an external dev. It uses the major, minor and release numbers instead of the revision number.</summary>
  ///<param name="AMajor">The major version number of the TEEXMA used.</param>
  ///<param name="AMinor">The minor version number of the TEEXMA used.</param>
  ///<param name="ARelease">The release number of the TEEXMA used.</param>
  ///<param name="ALoad_OT_Pictures">If true, pictures of the Object Types are loaded.</param>
  TInitializeTxAPIForExternalDevs=procedure(const AMajor: Integer; const AMinor: Integer; const ARelease: Integer; const ALoad_OT_Pictures: Boolean=False); stdcall;

  ///<summary>Function reinitializing the TxAPI connections.</summary>
  TReinit_Connections=procedure; stdcall;

  ///<summary>Procedure adding an allowed thread for the translation into jvgnugettext.</summary>
  ///<param name="AThread">The thread to add.</param>
  TAdd_Allowed_Thread_For_TXAPI_Translation=procedure(const AThread: Integer); stdcall;

  ///<summary>Procedure initializing the TxAPI. It should be the first procedure called after the TxAPI is loaded.</summary>
  ///<param name="AExecutableRevision">The revision number of the executable or dll using the TxAPI.</param>
  ///<param name="AIgnoreDBRevision">If false, the procedure compares AExecutable_Revision to the TxAPI revision number and raises an exception if they are different.</param>
  ///<param name="ALoadOTPictures">If true, pictures of the Object Types are loaded.</param>
  ///<param name="AContext">The context of the use of the TxAPI (TEEXMA win, web, external executable).</param>
  TInitializeTxAPI=procedure(const AExecutableRevision: Integer; const AIgnoreDBRevision: Boolean=False; const ALoadOTPictures: Boolean=False; const AContext: TLog_Action_Context=lacTEEXMA_Win); stdcall;

  ///<summary>Function returning the list numbering type.</summary>
  TGet_Data_Numbering_Type=function: TData_Numbering_Type; stdcall;

  ///<summary>Function returning the list ordering type.</summary>
  TGet_List_Ordering_Type=function: TObject_Ordering_Type; stdcall;

  ///<summary>Function returning true if the banner is visible by default into TEEXMA.</summary>
  TGet_Banner_Visible_By_Default=function: Boolean; stdcall;

  ///<summary>Function returning true if the path to the object must be displayed into the banner.</summary>
  TGet_Display_Object_Path_In_Banner=function: Boolean; stdcall;

  ///<summary>Function returning true if the Resources.7z file must be copied and unzipped into a temporary folder.</summary>
  TGet_Copy_Resources=function: Boolean; stdcall;

  ///<summary>Function returning the short date format as set into the preference file.</summary>
  TGet_Date_Format=function: string; stdcall;

  ///<summary>Function returning the long date format as set into the preference file.</summary>
  TGet_Date_and_Time_Format=function: string; stdcall;

  ///<summary>Function returning true if unit must be displayed after the decimal values into the word extractions.</summary>
  TGet_Display_Unit_In_Extractions=function: Boolean; stdcall;

  ///<summary>Function returning true if the splashscreen must be closed automatically after the loading step.</summary>
  TGet_Close_Splashscreen=function: Boolean; stdcall;

  ///<summary>Function returning true in case of a secure mode. If true, login and passwords are not sent into the various command line.</summary>
  TGet_Secured_Mode=function: Boolean; stdcall;

  ///<summary>Function converting a given date to a string, using the date format defined into the connection settings.</summary>
  ///<param name="AValue">The date to convert.</param>
  TDateToTXStr=function(const AValue: Double): string; stdcall;

  ///<summary>Function converting a given datetime to a string, using the datetime format defined into the connection settings.</summary>
  ///<param name="AValue">The date to convert.</param>
  TDateTimeToTXStr=function(const AValue: Double): string; stdcall;

  ///<summary>Function returning the maximum number of paths to open into a business view after a text search.</summary>
  TGet_Nb_Max_Paths=function: Integer; stdcall;

  ///<summary>Function returning the maximum number of links to display by default into the read form.</summary>
  TGet_Nb_Max_Links_Displayed=function: Integer; stdcall;

  ///<summary>Function returning the maximum number of data to display into a cell of the table view.</summary>
  TGet_Nb_Max_Data_Displayed=function: Integer; stdcall;

  ///<summary>Procedure setting the visibility of the Excel models during their execution.</summary>
  TSet_XLS_Models_Displayed=procedure(const AXLS_Models_Displayed: Boolean); stdcall;

  ///<summary>Procedure returning the visibility of the Excel models during their execution.</summary>
  TGet_XLS_Models_Displayed=function: Boolean; stdcall;

  ///<summary>Procedure returning true if Rich text must be used for long text form (into the web version atm).</summary>
  TGet_Use_RichText=function: Boolean; stdcall;

  ///<summary>Procedure setting the visibility of the Excel and word extraction during their execution.</summary>
  TSet_Extractions_Displayed=procedure(AExtractions_Displayed: Boolean); stdcall;

  ///<summary>Procedure returning the visibility of the Excel and word extraction during their execution.</summary>
  TGet_Extraction_Displayed=function: Boolean; stdcall;

  ///<summary>Procedure setting the type of web extraction: if true, the extraction is executed on the server, if false, it is executed on the client.</summary>
  TSetForceCriterion_Win_Exportation=procedure(AForce_Win_Exportation: Boolean); stdcall;

  ///<summary>Procedure returning the type of web extraction: if true, the extraction is executed on the server, if false, it is executed on the client.</summary>
  TGetForceCriterion_Win_Exportation=function: Boolean; stdcall;

  ///<summary>Procedure enabling to start (if possible) a transaction on the database.</summary>
  ///<summary>Each call increment iNb_Transactions.</summary>
  TTxBeginTrans=procedure; stdcall;

  ///<summary>Procedure enabling to commit (if possible) a transaction on the database.</summary>
  ///<summary>Each call desincrement iNb_Transactions.</summary>
  TTxCommitTrans=procedure; stdcall;

  ///<summary>Procedure enabling to roll back (if possible) the database.</summary>
  ///<summary>Each call desincrement iNb_Transactions.</summary>
  TTxRollbackTrans=procedure; stdcall;

  ///<summary>Function extracting a given icon into a temporary folder and returning the path of this icon.</summary>
  ///<param name="AIndex">The index of the icon.</param>
  TExtract_Icon=function(const AIndex: Integer): string; stdcall;

  ///<summary>Function retrieving the "TImageList" object containing the Object Types pictures.</summary>
  ///<summary>It is sent as TObject in order to slim the U_Abstract.pas unit (no reference to Controls).</summary>
  ///<returns>The TImageList is returned as a TObject to avoid declarations of controls units into the U_Abstract.</returns>
  TGet_IL_OT=function: TObject; stdcall;

  ///<summary>Procedure loading the structure objects lists (Object Types, Attributes, aso.)</summary>
  TLoad_Structure=procedure; stdcall;

  ///<summary>Procedure initializing the structure variables and lists.</summary>
  ///<summary>It must NOT be called except if loaded structure objects are manually modified.</summary>
  TInitialize_Structure_Variables=procedure; stdcall;

  ///<summary>Function returning true if the structure was loaded.</summary>
  TGet_Structure_Loaded=function: Boolean; stdcall;

  ///<summary>Function returning true if the trash mode must be handled.</summary>
  TGet_Trash_Mode=function: Boolean; stdcall;

  ///<summary>Function returning the log action context set into the TxAPI.</summary>
  TGetTxAPIContextOfUse=function: TLog_Action_Context; stdcall;

  ///<summary>Function returning the IP on the network of the client computer.</summary>
  ///<summary>In case of the web version, the IP returned is the client IP.</summary>
  TGet_IP_Client=function: string; stdcall;

  TDisconnectActiveUser=procedure; stdcall;

  TIsActiveUserAdministrator=function: Boolean; stdcall;

  ///<summary>Procedure initializing the user of the TxAPI.</summary>
  ///<param name="AID_User">The identifier of the user of the TxAPI.</param>
  TSetActiveUser=procedure(const AID_User: Integer); stdcall;

  ///<summary>Function returning the name of the active User.</summary>
  TGet_Active_User_Name=function: string; stdcall;

  ///<summary>Function returning the identifier of the active User.</summary>
  TGet_Active_User_ID=function: Integer; stdcall;

  ///<summary>Function returning the login of the active User.</summary>
  TGet_Active_User_Login=function: string; stdcall;

  ///<summary>Function returning the last connectin date of the active User.</summary>
  TGet_Active_User_Last_Connection_Date=function: Double; stdcall;

  ///<summary>Function returning the associated object's identifier of the active User.</summary>
  TGet_Active_User_ID_Object=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the Users Group associated to the active User.</summary>
  ///<values>The function reads it only once and keep it into memory for future uses.</values>
  TGet_Active_User_ID_Users_Group=function: Integer; stdcall;

  ///<summary>Function returning the URL of the online help.</summary>
  TGet_URL_Online_Help=function: string; stdcall;

  ///<summary>Function verifying the user's right for a given function and the active User.</summary>
  ///<param name="AFunction_Right">The function to test.</param>
  TGet_Active_User_Function_Right=function(const AFunction_Right: TFunction_Right): Boolean; stdcall;

  ///<summary>Function returning the password of the active user.</summary>
  TGet_Active_User_Password=function: string; stdcall;

  ///<summary>Procedure enabling to update the password of the current user logued.</summary>
  ///<param name="AOld_Password">The old passord.</param>
  ///<param name="ANew_Password">The new passord.</param>
  ///<param name="ANew_Password_Confirmation">The new passord confirmation.</param>
  TUpdate_Active_User_Password=procedure(const AOld_Password: string; const ANew_Password: string; const ANew_Password_Confirmation: string); stdcall;

  ///<summary>Function returning true if a login could be binded to a given password.</summary>
  ///<values>The function creates the user and its associated Object if necessary. It also binds the User to the list of User Groups retrieved from the LDAP directory.</values>
  ///<param name="ALogin">The login.</param>
  ///<param name="APassword">The password.</param>
  ///<param name="AID_User">If binding was successful, this variable contains the User identifier.</param>
  ///<param name="AMessage">A message to display (an error or an information message).</param>
  ///<param name="AID_Language">The identifier of the language to use.</param>
  ///<param name="ASimple_Test">If false, the user correctly identified will be set as the active user of the TxAPI. For this reason, Authenticate should not be called twice with ASimple_Test=true in case of a successful connection.</param>
  TAuthenticate=function(const ALogin: string; const APassword: string; var AID_User: Integer; var AMessage: string; const AID_Language: Integer; const ASimple_Test: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the text field max size. This size depends on the database type.</summary>
  TGet_TxStrFieldMaxSize=function: Integer; stdcall;

  ///<summary>Function returning the database type of the TEEXMA file database.</summary>
  TGet_Archived_File_DB_Type=function: TDB_Type; stdcall;

  TGet_Nbre_Licences_Administration=function: Integer; stdcall;

  TGet_Nbre_Licences_Modification=function: Integer; stdcall;

  ///<summary>Function returning the database type of the TEEXMA database.</summary>
  TGet_DB_Type=function: TDB_Type; stdcall;

  TGet_Nbre_Licences_Lecture=function: Integer; stdcall;

  TGet_Licence_Extraction=function: Boolean; stdcall;

  TGet_Licence_FullTextSearch=function: Boolean; stdcall;

  TGet_Licence_Selection=function: Boolean; stdcall;

  TGet_Licence_Calculs=function: Boolean; stdcall;

  TGet_Licence_Traitements_Statistiques=function: Boolean; stdcall;

  TGet_Licence_Authentification_Windows=function: Boolean; stdcall;

  TGet_Licence_API=function: Boolean; stdcall;

  TGet_Licence_Multilinguisme=function: Boolean; stdcall;

  ///<summary>Function returning the path to the file "TxWebComponents.dll".</summary>
  TGet_Path_File_TxWebComponents_DLL=function: string; stdcall;

  ///<summary>Function returning the path to the file "TxWebForm.dll".</summary>
  TGet_Path_File_TxWebForm_DLL=function: string; stdcall;

  ///<summary>Function returning the path to the file "TxWebExportation.dll".</summary>
  TGet_Path_File_TxWebExportation_DLL=function: string; stdcall;

  ///<summary>Function returning the path to the file "TxContextVariables.dll".</summary>
  TGet_Path_File_TxContextVariables_DLL=function: string; stdcall;

  ///<summary>Function returning the path to the file "TxLogin.dll".</summary>
  TGetTxLogFilePathin_DLL=function: string; stdcall;

  TGet_TEEXMA_Title=function: string; stdcall;

  TGet_Administration_Title=function: string; stdcall;

  TGet_Short_Description=function: string; stdcall;

  ///<summary>Function returning the path to the win directory.</summary>
  TGet_Dir_Win=function: string; stdcall;

  ///<summary>Function returning the path to the web directory.</summary>
  TGet_Dir_Web=function: string; stdcall;

  ///<summary>Function returning the path to the pictures files (for rich texts) into the web directory.</summary>
  TGet_Dir_WebPictures=function: string; stdcall;
  {$ENDREGION}

  {$REGION 'U_Browsing_History'}
  ///<summary>Class storing the informations concerning a given browsing state: the object browsed and the tab browsed.</summary>
  ///<summary>It owns the next browsing state and has a reference to the previous browsing state.</summary>
  TBrowsing_History=class(TObject);

  ///<summary>Procedure returning the informations of the next browsing state.</summary>
  ///<param name="AID_Object">The Object's identifier.</param>
  ///<param name="AID_Tab">The Tab identifier.</param>
  TRetrieve_Next_Browsing_History=procedure(out AID_Object: Integer; out AID_Tab: Integer); stdcall;

  ///<summary>Procedure returning the informations of the previous browsing state.</summary>
  ///<param name="AID_Object">The Object's identifier.</param>
  ///<param name="AID_Tab">The Tab identifier.</param>
  TRetrieve_Prev_Browsing_History=procedure(out AID_Object: Integer; out AID_Tab: Integer); stdcall;

  ///<summary>Procedure updating of current browsing state.</summary>
  ///<param name="AID_Object">The Object's identifier.</param>
  ///<param name="AID_Tab">The Tab identifier.</param>
  TUpdate_Browsing_History=procedure(const AID_Object: Integer; const AID_Tab: Integer); stdcall;

  ///<summary>Function returning true if there is a next browsing history.</summary>
  TCheck_Next_Browsing_History=function: Boolean; stdcall;

  ///<summary>Function returning true if there is a previous browsing history.</summary>
  TCheck_Prev_Browsing_History=function: Boolean; stdcall;

  ///<summary>Procedure reseting the browsing history into the API.</summary>
  TReset_Browsing_History=procedure; stdcall;
  {$ENDREGION}

  {$REGION 'U_Tmp_Table'}
  ///<summary>Enumeration of the table type.</summary>
  TTmpTableType=(
    ///An Objects preselection table.
    tttObject,
    ///An Attributes preselection table.
    tttAttribute,
    ///A link table.
    tttLink,
    ///An objects preselection table with iRight.
    tttObjectRM,
    tttSearchResults);

  ///<summary>Class handling a temporary table.</summary>
  TTmp_Table=class(TObject);

  TTmpTableHelper=class(TObject)
  public
    ///<summary>Function allowing a given function to "rent" an Object table.</summary>
    ///<param name="AFunction">The name of the function renting the table.</param>
    ///<returns>The function returns the name of the table "rented".</returns>
    function RentObjectTable(const AFunction: string): string; virtual; stdcall; abstract;
    ///<summary>Function allowing a function to "free" a given Object table.</summary>
    ///<param name="AFunction">The name of the function freeing the table.</param>
    ///<param name="AObjectTable">The temporary object table to free.</param>
    procedure FreeObjectTable(const AFunction: string; var AObjectTable: string); virtual; stdcall; abstract;
    ///<summary>Function allowing a given function to "rent" an SearchResults table.</summary>
    ///<param name="AFunction">The name of the function renting the table.</param>
    ///<returns>The function returns the name of the table "rented".</returns>
    function RentSearchResultsTable(const AFunction: string): string; virtual; stdcall; abstract;
    ///<summary>Function allowing a function to "free" a given SearchResults table.</summary>
    ///<param name="AFunction">The name of the function freeing the table.</param>
    ///<param name="ASearchResultsTable">The temporary object table to free.</param>
    procedure FreeSearchResultsTable(const AFunction: string; var ASearchResultsTable: string); virtual; stdcall; abstract;
    ///<summary>Function filling an Object temporary table with a given preselection.</summary>
    ///<param name="ATable">The name of the existing temporary table. It is assumed to be an Object temporary table.</param>
    ///<param name="ASlIdObject">The list of Objects identifiers (as string).</param>
    ///<param name="ARespectRights">If true, the query respects the rights of the connected user.</param>
    ///<returns>The function returns the number of rows inserted into the table.</returns>
    function FillObjectTableWithPreselection(const ATable: string; const ASlIdObject: TStringList; const ARespectRights: Boolean=False): Integer; virtual; stdcall; abstract;
    ///<summary>Function adding an identifier to a given Object temporary table.</summary>
    ///<param name="ATable">The name of the existing temporary table. It is assumed to be an Object temporary table.</param>
    ///<param name="AIdObject">The identifier of the Object to add.</param>
    ///<param name="AClear">If true, the table will be cleared before inserting the identifier.</param>
    ///<returns>The function returns the number of rows inserted into the table.</returns>
    function FillObjectTableWithSingleObject(const ATable: string; const AIdObject: Integer; const AClear: Boolean=False): Integer; virtual; stdcall; abstract;
    ///<summary>Function filling an Object temporary table with the children of a given parent Object or a list of parent Objects.</summary>
    ///<param name="ATable">The name of the existing temporary table. It is assumed to be an Object temporary table.</param>
    ///<param name="AIdParent">The identifier of the parent Object.</param>
    ///<param name="ARecursivity">If true, the whole branch will be added.</param>
    ///<param name="AIdObjectType">The identifier of the Object Type of the parent Object. This identifier is needed if the parent Object is the trash.</param>
    ///<param name="ASlIdParent">If different from nil, the list will be used instead of the single parent identifier.</param>
    ///<returns>The function returns the number of rows inserted into the table.</returns>
    function FillObjectTableWithParent(const ATable: string; const AIdParent: Integer; const ARecursivity: Boolean; const AIdObjectType: Integer=0; const ASlIdParent: TStringList=nil): Integer; virtual; stdcall; abstract;
    ///<summary>Function filling an Object temporary table thanks to one or more Object Types identifiers. It returns the number of rows inserted.</summary>
    ///<param name="ATable">The name of the existing temporary table. It is assumed to be an Object temporary table.</param>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    ///<param name="ARecursivity">If true, the whole branch will be added.</param>
    ///<param name="AIncludeFolders">If false, folder will not be included.</param>
    ///<param name="AIdObjectType">The identifier of the Object Type of the parent Object. This identifier is necessary if the parent Object is the trash.</param>
    ///<param name="ASlIdObjectType">If different from nil, the list will be used instead of the single Object Type identifier.</param>
    ///<param name="ARespectRights">If true, the query respects the rights of the connected user.</param>
    function FillObjectTableWithObjectType(const ATable: string; const AIdObjectType: Integer; const ARecursivity: Boolean; const AIncludeFolders: Boolean; const ASlIdObjectType: TStringList=nil; const ARespectRights: Boolean=False): Integer; virtual; stdcall; abstract;
  end;

  T_TmpTable=function: TTmpTableHelper; stdcall;
  {$ENDREGION}

  {$REGION 'U_Log_TXAPI'}
  ///<summary>Test function. Do not use.</summary>
  TTest_TxExcept=procedure; stdcall;

  TGetTxLogFilePath=function: string; stdcall;

  ///<summary>Function returning true if a log is needed for a given dll (working for teexma).</summary>
  ///<param name="ADllName">The name of the dll.</param>
  TIsTxLogNeeded=function(const ADllName: string): Boolean; stdcall;

  ///<summary>Function returning the directory where to write the log files of a given dll (working for teexma).</summary>
  ///<summary>If the dll name is empty, the function returns the path of log directory.</summary>
  ///<param name="ADllOrExeName">The name of the dll.</param>
  TGetTxLogDir=function(const ADllOrExeName: string): string; stdcall;

  ///<summary>Function returning the directory where to write the errors log.</summary>
  TGetTxLogErrorsDir=function: string; stdcall;
  {$ENDREGION}

  {$REGION 'U_Web'}
  ///<summary>Function returning true if the API is used into a web context.</summary>
  TIsWeb=function: Boolean; stdcall;

  ///<summary>Procedure usefull for the web version only. It defines other web client settings.</summary>
  ///<param name="AStandardDate_Month">The month corresponding to the return to the standard date.</param>
  ///<param name="AStandardDate_Day">The number of occurences of the day of the week corresponding to the return of the standard date.</param>
  ///<param name="AStandardDate_DayOfWeek">The day of the week corresponding to the return to the standard date.</param>
  ///<param name="AStandardDate_Hour">The hour corresponding to the return to the standard date.</param>
  ///<param name="ABias">The bias (in hour).</param>
  ///<param name="ADaylightDate_Month">The month corresponding to the change for the daylight date.</param>
  ///<param name="ADaylightDate_Day">The number of occurences of the day of the week corresponding to the change for the daylight date.</param>
  ///<param name="ADaylightDate_DayOfWeek">The day of the week corresponding to the change for the daylight date.</param>
  ///<param name="ADaylightDate_Hour">The hour corresponding to the change for the daylight date.</param>
  ///<param name="ADaylightBias">The bias (in hour) during the period using the daylight date.</param>
  ///<param name="ADate_Format">The client short date format.</param>
  ///<param name="ADateTime_Format">The client datetime format.</param>
  TInitialize_WEBClient_Settings=procedure(const AStandardDate_Month: Integer; const AStandardDate_Day: Integer; const AStandardDate_DayOfWeek: Integer; const AStandardDate_Hour: Integer; const ABias: Integer; const ADaylightDate_Month: Integer; const ADaylightDate_Day: Integer; const ADaylightDate_DayOfWeek: Integer; const ADaylightDate_Hour: Integer; const ADaylightBias: Integer; const ADate_Format: string; const ADateTime_Format: string); stdcall;

  ///<summary>Procedure usefull for the web version only. It defines early web client settings.</summary>
  ///<values>This procedure is usefull for automatic connection via the active directory.</values>
  ///<param name="AURL_TEEXMA">The web URL to the TEEXMA directory.</param>
  ///<param name="ALogin_WSession">The windows login session on the client computer.</param>
  ///<param name="AIP_Computer">The IP of the client computer.</param>
  TInitialize_WEB_Settings=procedure(const AURL_TEEXMA: string; const ALogin_WSession: string; const AIP_Computer: string); stdcall;

  TGet_URL_TEEXMA=function: string; stdcall;

  TGet_IISApplicationName=function: string; stdcall;

  ///<summary>Function returning the relative URL to the temporary directory for the web version.</summary>
  TGet_RUrl_Tmp=function: string; stdcall;

  ///<summary>Function returning the URL to the temporary directory for the web version.</summary>
  TGet_Url_Tmp=function: string; stdcall;

  ///<summary>Deprecated. Use Get_Url_Tmp</summary>
  TGet_URL_Web_Interface_Temp=function: string; stdcall;

  ///<summary>Function returning the User session number.</summary>
  TGet_User_Session_ID=function: Integer; stdcall;

  TGet_Max_Size_Upload=function: Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_UTC'}
  ///<summary>Function returning the "Now" value for the client timezone.</summary>
  TTxNow=function: Double; stdcall;

  ///<summary>Function converting a given UTC datetime into the datetime at client timezone.</summary>
  TTxUTCToDateTime=function(const D: Double): Double; stdcall;

  ///<summary>Function converting a given datetime at the client timezone into the UTC datetime.</summary>
  TTxDateTimeToUTC=function(const D: Double): Double; stdcall;
  {$ENDREGION}

  {$REGION 'U_Attribute_Set_Manager'}
  ///<summary>Function returning a list of Attribute whose first and only root level uses a given (link) Attribute.</summary>
  ///<summary>The function is usefull for form.</summary>
  TCreate_OL_Attribute_Set_Filtered_On_Link_Attribute=function(const AID_Attribute: Integer): TObjectList; stdcall;

  ///<summary>Function creating a filtered TObjectList of Attribute Set with a given Object Type as "root".</summary>
  ///<param name="AOL_Attribute_Set">The list of Attribute Sets to filter on.</param>
  ///<param name="AID_OT">The identifier of a filtering Object Type.</param>
  ///<param name="AOnly_Default">If true, only default advanced creations are returned.</param>
  TCreate_OL_Attribute_Set_Filtered=function(const AOL_Attribute_Set: TObjectList; const AID_OT: Integer; const AOnly_Default: Boolean=False): TObjectList; stdcall;

  ///<summary>Function returning a TS_Attribute_Set_Level object from its attribute's identifier and parent level identifier.</summary>
  ///<param name="AOL_Level">The list of levels to search into.</param>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  ///<param name="AID_Parent_Level">The identifier of the Parent Level to filter on.</param>
  ///<param name="ARaiseException">The identifier of the Parent Level to filter on.</param>
  TGet_Attribute_Set_Level_From_Attribute=function(const AOL_Level: TObjectList; const AID_Attribute: Integer; const AID_Parent_Level: Integer; const ARaiseException: Boolean=False): TS_Attribute_Set_Level; stdcall;

  ///<summary>Function creating a list of Attributes from a list of Attribute Sets Levels.</summary>
  ///<values>The list is sorted in the same order as the list of levels.</values>
  ///<param name="AOL_Level">The List of TS_Attribute_Set_Level objects.</param>
  TCreate_OL_Attribute_From_OL_Level=function(const AOL_Level: TObjectList): TObjectList; stdcall;

  ///<summary>Procedure loading the structure objects lists only for attributes sets</summary>
  TLoad_Attributes_Sets=procedure; stdcall;

  ///<summary>Function returning the list of attribute set.</summary>
  TGet_OL_Attribute_Set=function: TObjectList; stdcall;

  ///<summary>Function returning the list of duplication settings.</summary>
  TGet_OL_Duplication_Settings=function: TObjectList; stdcall;

  ///<summary>Function returning the list of deletion settings.</summary>
  TGet_OL_Deletion_Settings=function: TObjectList; stdcall;

  ///<summary>Function returning the list of advanced creations.</summary>
  TGet_OL_Advanced_Creation=function: TObjectList; stdcall;

  ///<summary>Function returning the list of advanced comparison.</summary>
  TGet_OL_Advanced_Comparison=function: TObjectList; stdcall;

  ///<summary>Function returning the Object Type identifier of a given Advanced creation.</summary>
  ///<param name="AID_Advanced_Creation">The identifier of the Advanced Creation.</param>
  TGet_Advanced_Creation_Settings_ID_OT=function(const AID_Advanced_Creation: Integer): Integer; stdcall;

  ///<summary>Function returning an TS_Attribute_Set object dedicated to an advanced comparison from its identifier.</summary>
  ///<param name="AID_Advanced_Comparison">The identifier of the Advanced comparison.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Advanced_Comparison_Settings=function(const AID_Advanced_Comparison: Integer; const ARaiseException: Boolean=True): TS_Attribute_Set; stdcall;

  TGetDefaultIdAdvancedCreation=function(const AIdObjectType: Integer): Integer; stdcall;

  ///<summary>Function checking the existence of a given Attribute Set.</summary>
  ///<param name="AID_Attribute_Set">the identifier of the Attribute Set.</param>
  ///<param name="AIgnore_Rights">If true, rights are ignored.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TCheck_Attribute_Set_Existence=function(const AID_Attribute_Set: Integer; const AIgnore_Rights: Boolean=False; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function returning an Attribute Set from its identifier.</summary>
  ///<param name="AID_Attribute_Set">The identifier of the attribute set.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Attribute_Set=function(const AID_Attribute_Set: Integer; const ARaiseException: Boolean=True): TS_Attribute_Set; stdcall;

  ///<summary>Function returning the name of a given Attributes Set.</summary>
  ///<summary>The function does not care about the sub-types and searches into the standard Attributes Sets, the Business views, the advanced functionalities (creation, duplication, deletion) and the advanced comparisons.</summary>
  ///<param name="AID_Attribute_Set">The identifier of the attribute set.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Attribute_Set_Name=function(const AID_Attribute_Set: Integer; const ARaiseException: Boolean=True): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_Objects_Manager'}
  ///<summary>Listing defining how the Object Manager must treat the various queries.</summary>
  TObject_Reading_Mode=(
    ///No object reading mode defined,
    ormUndefined,
    ///When a object is queried, all the Objects of the same Object Type are read: this mode is usefull for massive objects manipulations.
    ormAll_Objects,
    ///Objects are read one by one.
    ormOne_by_One,
    ///For enumerations, the Objects are read massively, for standard Objects Types, the Objects are read one by one: this is an intermediate mode.
    ormMixed);

  ///<summary>Listing defining what to do in case of a conflict between an existing Object in TEEXMA at a given path and a query on an object with the same name (but not necessarily at the right path).</summary>
  TPath_Conflict_Management=(
    pcmUse_Existing_Object,
    pcmMove_Object,
    pcmForce_Creation,
    pcmIgnore_Name);

  ///<summary>Listing describing the action done by the called method.</summary>
  TImport_Object_Action=(
    ioaObject_Recognized,
    ioaObject_Created,
    ioaObject_Moved,
    ioaObject_Not_Moved,
    ioaObject_Not_Created,
    ioaOther_Object_Existing,
    ioaNot_Enough_Right_For_Action);

  ///<summary>Basic class for Object management. It gives functionality such as :</summary>
  ///<summary>- Complete Object Type loading.</summary>
  ///<summary>- Object recognizing thanks to their name or path.</summary>
  ///<summary>- Object creation.</summary>
  TObject_Manager=class(TObject)
  public
    ///<summary>Setter for the variable "bIgnore_Accents".</summary>
    ///<summary>If true, accents do not matter while searching for an Object.</summary>
    procedure Set_Ignore_Accents(const AIgnore_Accents: Boolean); virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bIgnore_Case".</summary>
    ///<summary>If true, name case does not matter while searching for an Object.</summary>
    procedure Set_Ignore_Case(const AIgnore_Case: Boolean); virtual; stdcall; abstract;
    procedure Set_Handle_Rights(const AHandle_Rights: Boolean); virtual; stdcall; abstract;
    function Get_OL_Object(const AID_OT: Integer): TObjectList; virtual; stdcall; abstract;
    function Get_Object(const AID_OT: Integer; const AID_Object: Integer): TS_Object; virtual; stdcall; abstract;
    function Check_Path(const AID_OT: Integer; const AID_Object: Integer; const ANew_Kinship: string; const AConflict_Rule: TPath_Conflict_Management): TImport_Object_Action; overload; virtual; stdcall; abstract;
    function Check_Path(const AID_OT: Integer; const AID_Object: Integer; const AID_Parent_Object: Integer; const AConflict_Rule: TPath_Conflict_Management; const ARecursivity: Boolean=False): TImport_Object_Action; overload; virtual; stdcall; abstract;
    procedure Clear; virtual; stdcall; abstract;
    ///<summary>Function enabling to retrieve the identifier of an object thanks to its name and object type idenifier. If needed, the function can create the object.</summary>
    ///<param name="AID_OT">integer - identifier of the object type.</param>
    ///<param name="AName">string - name of the object to search or create. It is a variable: the function may change the name (for Object Type with unique name).</param>
    ///<param name="ACreate_Object">boolean - if true and no object is found, an object with AName is created, an unfound object is created.</param>
    ///<param name="AImport_Object_Action">TImport_Object_Conflict - indicates what to do in case the object is not found (or even indicates if the object has to be searched).</param>
    ///<param name="AAction_Done">TImport_Object_Action - variable indicating what was done by the function.</param>
    ///<param name="AID_Parent">integer=0 - identifier of the parent object of the searched object.</param>
    ///<param name="AFolder">boolean=false - if true and in case of object creation, the object will be a folder.</param>
    function Get_ID_Object_from_Name(const AID_OT: Integer; var AName: string; const ACreate_Object: Boolean; const AImport_Object_Action: TPath_Conflict_Management; var AAction_Done: TImport_Object_Action; const AID_Parent: Integer=0; const AFolder: Boolean=False): Integer; virtual; stdcall; abstract;
    function Get_ID_Object_from_Path(const AID_OT: Integer; const AKinship: string; var AName: string; const ACreate_Object: Boolean; const AConflict_Rule: TPath_Conflict_Management; var AAction_Done: TImport_Object_Action; const AFolder: Boolean=False): Integer; virtual; stdcall; abstract;
    function Get_Object_Name(const AID_OT: Integer; const AID_Object: Integer): string; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bTrigger_MA".</summary>
    ///<summary>If false, Models Applications normally triggering while creating or modifying object are not executed.</summary>
    procedure Set_Trigger_MA(const ATrigger_MA: Boolean); virtual; stdcall; abstract;
    ///<summary>Getter for the variable "bTrigger_MA".</summary>
    ///<summary>If false, Models Applications normally triggering while creating or modifying object are not executed.</summary>
    function Get_Trigger_MA: Boolean; virtual; stdcall; abstract;
    ///<summary>Setter for the variable "iORM".</summary>
    ///<summary>The Objects Reading Mode: massive, one by one or ...</summary>
    procedure Set_ORM(const AORM: TObject_Reading_Mode); virtual; stdcall; abstract;
    ///<summary>Function returning the number of Object of a given Object Type, including folder or not.</summary>
    function Get_OT_Nb_Objects(const AID_OT: Integer; const AInclude_Folders: Boolean=True): Integer; virtual; stdcall; abstract;
    ///<summary>Function filling a given list with the objects identifiers of a given Object Type.</summary>
    procedure Fill_SL_ID_Object(const AID_OT: Integer; const ASL_ID_Object: TStringList; const AInclude_Folders: Boolean=True); virtual; stdcall; abstract;
    ///<summary>Function creating and returining a list with the objects identifiers of a given Object Type.</summary>
    function Create_SL_ID_Object(const AID_OT: Integer; const AInclude_Folders: Boolean): TStringList; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TObject_Manager object.</summary>
  ///<param name="AORM">An optimization settings for the importation. See the TObject_Reading_Mode listing documentation for more informations.</param>
  TCreate_Object_Manager=function(const AORM: TObject_Reading_Mode): TObject_Manager; stdcall;
  {$ENDREGION}

  {$REGION 'U_Importation'}
  ///<summary>Error raising if "expected" object could not be found.</summary>
  EImport_Object_OT_Mismatch=class(ECoded_Error);

  ///<summary>Error raising if the Object Type of the Object was not defined.</summary>
  EImport_Object_OT_Undefined=class(ECoded_Error);

  ///<summary>Error raising if the Object could not be created by the importation (for a reason or an other).</summary>
  EImport_Object_Not_Written=class(ECoded_Error);

  ///<summary>Class allowing to import data, sources and objects into the Database.</summary>
  TImport=class(TObject)
  public
    procedure Set_PCM(const APCM: TPath_Conflict_Management); virtual; stdcall; abstract;
    procedure Set_ORM(const AORM: TObject_Reading_Mode); virtual; stdcall; abstract;
    procedure Set_Trigger_MA(const ATrigger_MA: Boolean); virtual; stdcall; abstract;
    procedure Set_Handle_Tracking(const AHandle_Tracking: Boolean); virtual; stdcall; abstract;
    ///<summary>Setter for the variable "bHandle_Rights".</summary>
    ///<summary>If true, rights are respected. If not... Who cares about rights?</summary>
    procedure Set_Handle_Rights(const AHandle_Rights: Boolean); virtual; stdcall; abstract;
    function Import_Data(const AOL_Data: TObjectList; const ANew_Object: Boolean=False): string; overload; virtual; stdcall; abstract;
  end;

  TImport_XML_File=function(const APath_File: string; const AID_Object: Integer; const AORM: TObject_Reading_Mode; const ATrigger_MA: Boolean; const AFilesDir: string=''): string; stdcall;

  ///<summary>Function importing the content of a TEEXMA xml flow.</summary>
  ///<param name="AXML">The xml flow to import.</param>
  ///<param name="AID_Object">The identifier of the root object in case of an object (and data) importation. If the object identifier is filled into the xml flow, this identifier is not taken into account.</param>
  ///<param name="AORM">An optimization settings for the importation. See the TObject_Reading_Mode listing documentation for more informations.</param>
  ///<param name="ATrigger_MA">If true, the object creation and data writing trigger the model applications.</param>
  ///<param name="AFilesDir">The path to the folder where the files associated to the file data are stored.</param>
  ///<return>The function returns a model application command string.</return>
  TImport_XML_Flow=function(const AXML: string; const AID_Object: Integer; const AORM: TObject_Reading_Mode; const ATrigger_MA: Boolean=True; const AFilesDir: string=''): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_Manager'}
  ///<summary>Listing defining the type of preselection for both attributes and Objects.</summary>
  ///<summary>Concerning the attributes, the type is defined automatically by the read method of the TData_Manager.</summary>
  ///<summary>Concerning the Objects, the developper can define it before starting to set the preselection.</summary>
  TQuery_Condition_Type=(
    ///The preselection condition will be defined by the TData_Manager itself.
    qctUndefined,
    ///The preselection is an entire Object Type. You cannot add other objects nor object types.
    qctObject_Type,
    ///The preselection is a single object.
    qctSingle_Object,
    ///The preselection is made of many object.
    qctMany_Objects,
    ///The preselection is a preselection table.
    qctTable);

  ///<summary>Listing defining which data to put in a list (and how to put them in shape).</summary>
  TData_Formating_Type=(
    ///Linked data will be added into TS_Object_Data data of their inheritage link.
    dftTree,
    ///The data will be put into a single list (no tree).
    dftLinear,
    ///Only the last inherited data will be put into the list (not all their inheritage links).
    dftDeepest,
    ///Only the last inheritage links data will be put into the list (but not their inherited data).
    dftBefore_Deepest);

  ///<summary>Query mode for the data Manage: data, source or source+their data.</summary>
  TDM_Query=(
    ///Data if the Objects
    dmqData,
    ///Source if the Objects
    dmqSource,
    ///Source + their data of the Objects
    dmqData_Source);

  ///<summary>A set of queries type for the Data Manager.</summary>
  TDM_Querys=set of TDM_Query;

  ///<summary>Class allowing to read massively data, source and linked objects.</summary>
  ///<summary>It also enables to organize the data as follow: objects containing data containing linked objects containing data aso.</summary>
  ///<summary>The class accepts many type of objets or attributes preselections.</summary>
  ///<summary>For attribute, the easiest way is to use an Attribute Sets to define the data to read and to put them in shape after.</summary>
  TData_Manager=class(TObject)
  public
    procedure Add_To_DMQs(ADMQ: TDM_Query); virtual; stdcall; abstract;
    ///<summary>Procedure reading (recursively) the data, the source, the linked objects, aso.</summary>
    procedure Read; virtual; stdcall; abstract;
    ///<summary>Procedure clearing the Settings and stored informations of the Data Manager.</summary>
    procedure Clear; virtual; stdcall; abstract;
    ///<summary>Setter for preselection Object Type. It MUST be called just after its creation.</summary>
    ///<param name="AIdObjectType">The identifier of the Object Type.</param>
    procedure Set_ID_OT(const AIdObjectType: Integer); virtual; stdcall; abstract;
    ///<summary>Setter for the variable "sObjectsTable".</summary>
    ///<summary>The preselection table in case of a "table" preselection type.</summary>
    procedure Set_ObjectsTable(const ATable: string); virtual; stdcall; abstract;
    procedure Add_To_Preselection(const ASlIdObject: TStringList); overload; virtual; stdcall; abstract;
    procedure Add_To_Preselection(const AOlObject: TObjectList); overload; virtual; stdcall; abstract;
    procedure Add_To_Preselection(const AIdObject: Integer); overload; virtual; stdcall; abstract;
    procedure Add_To_Preselection(const ATag: string); overload; virtual; stdcall; abstract;
    procedure Add_To_Preselection(const AArrTag: array of string); overload; virtual; stdcall; abstract;
    procedure Add_to_Preselection(const AObject: TS_Object); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(AAttribute: TS_Attribute; AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(AIdAttribute: Integer; AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(AOlAttribute: TObjectList; AArrDataType: array of Integer; AIgnoreInheritedAttributes: Boolean=False; AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(ASlIdAttribute: TStringList; AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(AInheritageLnkAtt: TS_Attribute; InheritageAtt: TS_Attribute; AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(AIdObjectType: Integer; AArr_TD: array of Integer; AIgnoreInheritedAttributes: Boolean=False; AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(AAttributesSet: TS_Attribute_Set; ARecursivity: Boolean; AReadSources: Boolean=False; ALDTs_Forbiden: TLevel_Types=[]); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(AOlLevel: TObjectList; AIdParentLevel: Integer; ARecursivity: Boolean; AReadSources: Boolean=False; ALDTs_Forbiden: TLevel_Types=[]); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(const ATag: string; const AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Add_To_Attributes(const AArrTag: array of string; const AReadSources: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Update_OL_Data(AOlData: TObjectList; AIdAttribute: Integer; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_OL_Source(AOlSource: TObjectList; AIdAttribute: Integer; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_OL_Data_And_Source(AOlData: TObjectList; AOlSource: TObjectList; AIdAttribute: Integer; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_OL_Data(AOlData: TObjectList; AOlAttribute: TObjectList; AIdObject: Integer=0; ADuplicate: Boolean=True; const AAddInheritageLnkData: Boolean=False); overload; virtual; stdcall; abstract;
    procedure Update_OL_Source(AOlSource: TObjectList; AOlAttribute: TObjectList; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_OL_Data_And_Source(AOlData: TObjectList; AOlSource: TObjectList; AOlAttribute: TObjectList; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_OL_Data(AOlData: TObjectList; AAttributesSet: TS_Attribute_Set; ADFT: TData_Formating_Type; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_OL_Source(AOlSource: TObjectList; AAttributesSet: TS_Attribute_Set; ADFT: TData_Formating_Type; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_OL_Data_And_Source(AOlData: TObjectList; AOlSource: TObjectList; AAttributesSet: TS_Attribute_Set; ADFT: TData_Formating_Type; AIdObject: Integer=0; ADuplicate: Boolean=True); overload; virtual; stdcall; abstract;
    procedure Update_Object(AObject: TS_Object_Data; AAttributesSet: TS_Attribute_Set); overload; virtual; stdcall; abstract;
    procedure Update_OL_Object(AOlObject: TObjectList; AAttributesSet: TS_Attribute_Set); overload; virtual; stdcall; abstract;
    ///<summary>Function returning the list of data associated to a given attribute. This function is not callable with an inherited Attribute.</summary>
    function Get_OL_Data(AIdAttribute: Integer): TObjectList; virtual; stdcall; abstract;
    function Get_Data(AIdAttribute: Integer): TD_Data; overload; virtual; stdcall; abstract;
    function Get_Data(AIdAttribute: Integer; AIdObject: Integer): TD_Data; overload; virtual; stdcall; abstract;
    ///<summary>Function creating a globale list of the linked objects into TDM object and its children.</summary>
    ///<summary>The object are sorted by id ascending.</summary>
    ///<summary>The list does NOT own its objects.</summary>
    function Create_OL_Object_Lkd: TObjectList; virtual; stdcall; abstract;
    function Get_DM_Child: TData_Manager; virtual; stdcall; abstract;
  end;

  TCreate_Data_Manager=function(AARM: TAssociativity_Reading_Mode; AReadLkdObjectsNames: Boolean; ADMQs: TDM_Querys; APreselectionType: TQuery_Condition_Type=qctUndefined): TData_Manager; stdcall;
  {$ENDREGION}

  {$REGION 'U_Extraction_Manager'}
  ///<summary>Class allowing to read massively the extraction data.</summary>
  TExtraction_Manager=class(TObject)
  public
    function Initialize(const AOL_Object: TObjectList; const AOL_Bookmark: TObjectList; const AOL_Attribute: TObjectList): TObjectList; overload; virtual; stdcall; abstract;
    function Initialize(const ASL_ID_Object: TStringList; const AOL_Bookmark: TObjectList; const AOL_Attribute: TObjectList): TObjectList; overload; virtual; stdcall; abstract;
    function Get_Document(const AWordOrExcel: OleVariant): OleVariant; virtual; stdcall; abstract;
    procedure Update_Excel_Quick_Mode(const AID_Extraction: Integer; const AWorksheet: string; const ARow: Integer; const ACol: Integer; const AText: string; const AID_Sub_Extraction: Integer=-1; const AID_Sub_Extraction_Document: Integer=-1); virtual; stdcall; abstract;
  end;

  ///<summary>Function returning the name of a given Extraction Type.</summary>
  ///<param name="AType">The Extraction Type.</param>
  TGet_Extraction_Type_Name=function(const AType: TExtraction_Type): string; stdcall;

  TExtract_Objects=function(const AID_Extraction: Integer; const AOL_Object: TObjectList; const ASL_ID_Object: TStringList; const AID_RL: Integer; const APath_File: string=''): OleVariant; stdcall;

  ///<summary>Procedure converting a word document into a PDF file.</summary>
  ///<param name="ADocument">The word (Ole) document to convert into PDF.</param>
  ///<param name="APath_File_PDF">The path to the pdf file to write.</param>
  TWordDocumentToPDF=procedure(const ADocument: OleVariant; const APath_File_PDF: string); stdcall;

  ///<summary>Function returning true if a word document can be printer into the PDF format after being extracted.</summary>
  TCheck_PDFPrinter_Availability=function: Boolean; stdcall;

  ///<summary>Function returning the whole list of extraction documents</summary>
  TGet_OL_Extraction=function: TObjectList; stdcall;

  ///<summary>Function creating a the list of TE_Extraction objects belonging to a given Object Type. The list is sorted thanks to the Object order.</summary>
  ///<param name="AID_OT">The identifier of the filtering Object Type.</param>
  ///<param name="AInclude_Invisible">If true, invisible Extractions are not filtered.</param>
  TCreate_OL_Extraction=function(const AID_OT: Integer; const AInclude_Invisible: Boolean): TObjectList; stdcall;

  ///<summary>Function returning the name of a given extraction.</summary>
  ///<param name="AID_Extraction">identifier of the Extraction.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Extraction_Name=function(const AID_Extraction: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning an Extraction object from its identifier.</summary>
  ///<param name="AID_Extraction">identifier of the Extraction.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Extraction=function(const AID_Extraction: Integer; const ARaiseException: Boolean=True): TE_Extraction; stdcall;
  {$ENDREGION}

  {$REGION 'U_Log_Manager'}
  ///<summary>Class allowing to export parts of a given logs thanks to given criteria.</summary>
  TLog_Manager=class(TObject)
  public
    procedure Set_Date_Start(const ADate: Double); virtual; stdcall; abstract;
    procedure Set_Date_End(const ADate: Double); virtual; stdcall; abstract;
    procedure Set_ID_Action_Start(const AID_Action_Start: Integer); virtual; stdcall; abstract;
    procedure Set_ID_Log(const AID_Log: Integer); virtual; stdcall; abstract;
    procedure Set_ID_OT_Filtering(const AID_OT_Filtering: Integer); virtual; stdcall; abstract;
    procedure Add_TD_Object(const ADataType: Integer); virtual; stdcall; abstract;
    procedure Add_Type(const AType: TLog_Action_Type); virtual; stdcall; abstract;
    procedure Add_Context(const AContext: TLog_Action_Context); virtual; stdcall; abstract;
    function Create_OL_Action(const ATreat_Comments: Boolean): TObjectList; virtual; stdcall; abstract;
    function Create_SL_ID_Object: TStringList; virtual; stdcall; abstract;
    procedure Export_As_TextFile(const APath_File: string; const ASeparator: string); virtual; stdcall; abstract;
    function Get_ID_Action_Last_Read: Integer; virtual; stdcall; abstract;
  end;

  ///<summary>Function creating a TMD_Action_Exportater object using the default constructor.</summary>
  TCreate_Log_Manager=function: TLog_Manager; stdcall;

  ///<summary>Procedure writing action(s) if needed.</summary>
  ///<param name="AType">the log action type (open, click, execution, aso).</param>
  ///<param name="ADataType">The data type of the object concerned with the action.</param>
  ///<param name="AID_Object">The identifier of the object concerned with the action.</param>
  ///<param name="AContext">The context of the action (a click "from the table view").</param>
  ///<param name="AComments">A comment.</param>
  TlogAction=procedure(const AType: TLog_Action_Type; const ADataType: Integer; const AID_Object: Integer; const AContext: TLog_Action_Context; const AComments: string=''); stdcall;

  ///<summary>Function returning the number of action of a given log.</summary>
  ///<param name="AID_Log">The identifier of the log.</param>
  TGet_DBLog_Nb_Actions=function(const AID_Log: Integer): Integer; stdcall;

  ///<summary>Procedure partially cleaning a given log using various conditions.</summary>
  ///<param name="AID_Log">The identifier of the log to clean.</param>
  ///<param name="AID_Action_Filtering">All actions with identifier higher than this identifier (included) are kept. If nul, no condition is put on this field.</param>
  ///<param name="AFilteringDate">All actions with date higher than this date are kept. If NaN, no condition is put on this field.</param>
  TClean_DBLog=procedure(const AID_Log: Integer; const AID_Action_Filtering: Integer; const AFilteringDate: Double); stdcall;

  TLoad_DBLogs=procedure; stdcall;

  ///<summary>Function returning the list of Logs.</summary>
  TGet_OL_DBLog=function: TObjectList; stdcall;

  TInitialize_DBLogs=procedure; stdcall;

  ///<summary>Function returning the name of a given log object.</summary>
  ///<param name="AID_Log">The identifier of the object.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_DBLog_Name=function(const AID_Log: Integer; const ARaiseException: Boolean=True): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_Equivalence_Manager'}
  ///<summary>Function creating a sublist of TEq_Equivalence with the same ID_TEEXMA. The main list must be sorted (by ID_TEEXMA).</summary>
  ///<param name="AOL_Equivalence">The list of equivalences.</param>
  ///<param name="AID_TEEXMA">The identifier of the TEEXMA object.</param>
  TCreate_OL_Sub_Equivalence=function(const AOL_Equivalence: TObjectList; const AID_TEEXMA: Integer): TObjectList; stdcall;

  ///<summary>Function returning a TEq_Equivalence thanks to its right identifier.</summary>
  ///<param name="AOL_Equivalences">The list of TEq_Equivalence objects to search into.</param>
  ///<param name="AID_Left">The left identifier to search.</param>
  ///<param name="ALeft_Sorted">If true, the list is supposed to be left sorted. This accelerates the searching process.</param>
  TGet_Equivalence_From_Left=function(const AOL_Equivalences: TObjectList; const AID_Left: Integer; const ALeft_Sorted: Boolean): TEq_Equivalence; stdcall;

  ///<summary>Function returning the name of a given Equivalence Set.</summary>
  ///<param name="AID_Equivalence_Set">The identifier of the equivalence set.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Equivalence_Set_Name=function(const AID_Equivalence_Set: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning a TEq_Equivalence_Set objet thanks to its identifier. If the object is not found into the loaded list of the TxAPI, it may be read from the database.</summary>
  ///<param name="AID_Equivalence_Set">The identifier of the object.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Equivalence_Set=function(const AID_Equivalence_Set: Integer; const ARaiseException: Boolean=True): TEq_Equivalence_Set; stdcall;

  ///<summary>Function checking the existing of a given Equivalences Set.</summary>
  ///<param name="AID_Equivalence_Set">The identifier of the object.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TCheck_Equivalence_Set_Existence=function(const AID_Equivalence_Set: Integer; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function creating a TEq_Equivalence_Set object read from the database.</summary>
  ///<param name="AID_Equivalence_Set">The identifier of the object. If lower than 1, no reading is done.</param>
  TCreate_Equivalence_Set=function(const AID_Equivalence_Set: Integer=0): TEq_Equivalence_Set; stdcall;

  ///<summary>Function creating a TObjectList of TEq_Equivalence_Set read from the database. Their equivalences lists are also read.</summary>
  ///<param name="AID_Equivalence_Set">The identifier of a precise object. If lower than 1, all entry of the database are read.</param>
  TCreate_OL_Equivalence_Set=function(const AID_Equivalence_Set: Integer=0): TObjectList; stdcall;

  ///<summary>Function returning the list of equivalences  of a given Equivalences Sets.</summary>
  ///<param name="AID_Equivalence_Set">The identifier of the object.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Equivalences_Set_OL_Equivalence=function(const AID_Equivalence_Set: Integer; const ARaiseException: Boolean=True): TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Data_File_Functions'}
  ///<summary>Function Function creating and returning a data file object for a given couple Attribute/Object. It is initialized with a given Archived File. .</summary>
  TCreate_Data_File_For_Reference=function(const AIdAttribute: Integer; const AIdObject: Integer; const AID_Archived_File: Integer): TD_Data_File; stdcall;

  ///<summary>Function returning the identifier of the archived file used by a given data for a given couple Attribute/Object. The function assumes the Attribute is not used as a list Attribute.</summary>
  TGet_Data_ID_Archived_File=function(const AOlData: TObjectList; const AIdAttribute: Integer; const AIdObject: Integer; const ADefaultIdArchivedFile: Integer=0; const ASorted: Boolean=False): Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Objects_Functions'}
  ///<summary>Function creating a TS_Object Object (or from a class derivating from TS_Object).</summary>
  ///<param name="AIdObject">If not nul, the object is initialized from the database.</param>
  ///<param name="ADataType">The data type corresponding to the class of the object to create.</param>
  ///<param name="ARespectRights">If false, rights are ignored.</param>
  TCreate_Object=function(const AIdObject: Integer=0; const ADataType: Integer=-3; const ARespectRights: Boolean=True): TS_Object; stdcall;
  {$ENDREGION}

  {$REGION 'U_Tag_Manager'}
  TReset_TaggedTxConcepts=procedure(const ADataType: Integer; const AOL: TObjectList=nil); stdcall;

  ///<summary>Function returning the name of a tagged Object.</summary>
  ///<param name="ATag">The tag of the object.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  ///<returns>The function returns an empty value if no object is found.</returns>
  TGet_Object_Name_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the identifier of a tagged Object.</summary>
  ///<param name="ATag">The value of the tag.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  ///<returns>If not found, the function returns 0.</returns>
  TGet_ID_Object_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the tags of a given object.</summary>
  ///<param name="AID_Object">The identifier of the object.</param>
  TGet_Object_FirstTag=function(const AID_Object: Integer): string; stdcall;

  TCheckIf_Object_Tagged=function(const AID_Object: Integer; const ATag: string): Boolean; stdcall;

  ///<summary>Function returning a tagged Attribute.</summary>
  ///<param name="ATag">The tag of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Attribute_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Attribute; stdcall;

  ///<summary>Function returning the identifier of a tagged Attribute.</summary>
  ///<param name="ATag">The tag of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Attribute_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Object Type.</summary>
  ///<param name="ATag">The tag of the Object Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Object_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Attribute.</summary>
  ///<param name="ATag">The tag of the Attributes Set.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Attribute_Set_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Attribute_Set; stdcall;

  ///<summary>Function returning the tags of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_OT_Tags=function(const AID_OT: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning a tagged Advanced Creation.</summary>
  ///<param name="ATag">The tag of the advanced creation.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Advanced_Creation_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Attribute_Set; stdcall;

  ///<summary>Function returning a tagged Advanced Duplication.</summary>
  ///<param name="ATag">The tag of the Advanced Duplication.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Advanced_Duplication_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Attribute_Set; stdcall;

  ///<summary>Function returning a tagged Advanced Comparison.</summary>
  ///<param name="ATag">The tag of the Advanced Comparison.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Advanced_Comparison_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Attribute_Set; stdcall;

  ///<summary>Function returning a tagged Advanced Deletion.</summary>
  ///<param name="ATag">The tag of the Advanced Deletion.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Advanced_Deletion_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Attribute_Set; stdcall;

  ///<summary>Function returning the identifier of a tagged Advanced Creation.</summary>
  ///<param name="ATag">The tag of the Advanced Creation.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Advanced_Creation_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Advanced Comparison.</summary>
  ///<param name="ATag">The tag of the Advanced Comparison.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Advanced_Comparison_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Advanced Duplication.</summary>
  ///<param name="ATag">The tag of the Advanced Duplication.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Advanced_Duplication_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Advanced Deletion.</summary>
  ///<param name="ATag">The tag of the Advanced Deletion.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Advanced_Deletion_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Unit.</summary>
  ///<param name="ATag">The tag of the Unit.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Unit_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Unit; stdcall;

  ///<summary>Function returning a tagged Exportation.</summary>
  ///<param name="ATag">The tag of the Exportation.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Exportation_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TE_Exportation; stdcall;

  ///<summary>Function returning a tagged Extraction.</summary>
  ///<param name="ATag">The tag of the Extraction.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Extraction_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TE_Extraction; stdcall;

  ///<summary>Function returning a tagged Object Type.</summary>
  ///<param name="ATag">The tag of the Object Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Object_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Object_Type; stdcall;

  ///<summary>Function returning a tagged Table Type.</summary>
  ///<param name="ATag">The tag of the Table Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Table_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Table_Type; stdcall;

  ///<summary>Function returning the identifier of a tagged Table Type.</summary>
  ///<param name="ATag">The tag of the Table Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Table_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Unit.</summary>
  ///<param name="ATag">The tag of the Unit.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Unit_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Attributes Set.</summary>
  ///<param name="ATag">The tag of the Attributes Set.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Attribute_Set_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Exportation.</summary>
  ///<param name="ATag">The tag of the Exportation.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Exportation_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of a tagged Extraction.</summary>
  ///<param name="ATag">The tag of the Extraction.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_ID_Extraction_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  TGet_TaggedTxConceptID=function(const AOL: TObjectList; const ATag: string): Integer; stdcall;

  TTagToID=function(const ADataType: Integer; const ATag: string; const AReadIfNeeded: Boolean; const AIgnoreLoadedObjects: Boolean; const ARaiseException: Boolean): Integer; stdcall;

  TTag_TxConcept=function(const ATxObj: TNamed_Object; const ADataType: Integer; const AOlExisting: TObjectList=nil): Boolean; stdcall;

  TCheckIf_Tag_Available=function(const ADataType: Integer; const ATag: string; const AOlExisting: TObjectList=nil): Boolean; stdcall;

  ///<summary>Function returning the identifier of a tagged Choices Guide.</summary>
  ///<param name="ATag">The tag of the Choices Guide.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Requirements List.</param>
  TGet_ID_Choice_Guide_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Choices Guide.</summary>
  ///<param name="ATag">The tag of the Choices Guide.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Choice_Guide_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TCG_Choice_Guide; stdcall;

  ///<summary>Function returning the identifier of a tagged Series Type.</summary>
  ///<param name="ATag">The tag of the Series Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Requirements List.</param>
  TGet_ID_Series_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Series Type.</summary>
  ///<param name="ATag">The tag of the Series Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Series_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Series_Type; stdcall;

  ///<summary>Function returning the identifier of a tagged Users Group.</summary>
  ///<param name="ATag">The tag of the Users Group.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Requirements List.</param>
  TGet_ID_Users_Group_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Users Group.</summary>
  ///<param name="ATag">The tag of the Users Group.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Users_Group_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TRM_Users_Group; stdcall;

  ///<summary>Function returning the identifier of a tagged Equivalences Set.</summary>
  ///<param name="ATag">The tag of the Equivalences Set.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Requirements List.</param>
  TGet_ID_Equivalences_Set_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Equivalences Set.</summary>
  ///<param name="ATag">The tag of the Equivalences Set.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Equivalences_Set_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TEq_Equivalence_Set; stdcall;

  ///<summary>Function returning the identifier of a tagged Files Type.</summary>
  ///<param name="ATag">The tag of the Files Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no File Type.</param>
  TGet_ID_File_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Files Type.</summary>
  ///<param name="ATag">The tag of the Files Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_File_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_File_Type; stdcall;

  ///<summary>Function returning the identifier of a tagged Link Type.</summary>
  ///<param name="ATag">The tag of the Link Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Link Type.</param>
  TGet_ID_Link_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Link Type.</summary>
  ///<param name="ATag">The tag of the Files Type.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Link_Type_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TS_Link_Type; stdcall;

  ///<summary>Function returning the identifier of a tagged Language.</summary>
  ///<param name="ATag">The tag of the Language.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Language.</param>
  TGet_ID_Language_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Language.</summary>
  ///<param name="ATag">The tag of the Language.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Language_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TT_Language; stdcall;

  ///<summary>Function returning the identifier of a tagged Log.</summary>
  ///<param name="ATag">The tag of the Log.</param>
  ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Requirements List.</param>
  TGet_ID_Log_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a tagged Log.</summary>
  ///<param name="ATag">The tag of the Log.</param>
  ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
  TGet_Log_From_Tag=function(const ATag: string; const ARaiseException: Boolean=True): TMD_Log; stdcall;
  {$ENDREGION}

  {$REGION 'U_Object_Data_Functions'}
  ///<summary>Function creating a TS_Object_Data object.</summary>
  ///<param name="AObject">If not nil, it is used to initialize the TS_Object_Data object.</param>
  TCreate_Object_Data_From_Object=function(const AObject: TS_Object): TS_Object_Data; stdcall;

  ///<summary>Function creating and returning a TS_Object_Data object with the data corresponding to a given tab.</summary>
  ///<param name="AID_Tab">The identifier of the tab.</param>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="ARead_Object_Lkd_Names">If true, the linked Objects names are read.</param>
  ///<param name="ADMQs">The "data" (as a larger concept) to read: data, sources, sources data.</param>
  TCreate_Object_Data_From_Tab=function(const AID_Object: Integer; const AID_Tab: Integer; const ARead_Object_Lkd_Names: Boolean=False; const ADMQs: TDM_Querys=[dmqData]): TS_Object_Data; stdcall;

  ///<summary>Procedure reading the data of a single TS_Object_Data objects and a list of Attributes.</summary>
  ///<param name="AObject">The object to update.</param>
  ///<param name="AOL_Attribute">The list of Attributes.</param>
  ///<param name="ARead_Object_Lkd_Names">If true, linked objects names will be read. This action slowers the function.</param>
  ///<param name="AARM">The associtivity reading mode (right links,...).</param>
  TUpdate_Object_Data=procedure(const AObject: TS_Object_Data; const AOL_Attribute: TObjectList; const ARead_Object_Lkd_Names: Boolean; const AARM: TAssociativity_Reading_Mode); stdcall;

  ///<summary>Function creating a TS_Object_Data object from a given Attribute Set (for the Attributes) and a given preselection of Objects.</summary>
  ///<param name="AID_Attribute_Set">The identifier of the Attribute Set.</param>
  ///<param name="AID_Object">The identifier of the Object.</param>
  ///<param name="ARead_Object_Lkd_Names">If true, the linked Objects names are read.</param>
  ///<param name="ADMQs">The "data" (as a larger concept) to read: data, sources, sources data.</param>
  TCreate_Object_Data_From_Attribute_Set=function(const AID_Attribute_Set: Integer; const AID_Object: Integer; const ARead_Object_Lkd_Names: Boolean=False; const ADMQs: TDM_Querys=[dmqData]): TS_Object_Data; stdcall;

  ///<summary>Function creating a list of TS_Object_Data object from a given path. The objects read may be different depending on the path read mode parameter.</summary>
  ///<param name="APath">The path object.</param>
  ///<param name="AOL_Attribute">A list of Attribute to read.</param>
  ///<param name="ARead_Links_Names">If true, linked objects names are read. This slows the function.</param>
  ///<param name="APRM">The path reading mode: the function may read the whole branch, only the objects in the path, aso.</param>
  ///<param name="AARM">The associativity reading mode.</param>
  ///<param name="AOOT">The objects sorting mode. In this function, the default sorting mode is by ascending parents identifiers.</param>
  TCreate_OL_Object_Data_From_Path=function(const APath: TPath; const AOL_Attribute: TObjectList; const APRM: TPath_Read_Mode; const ARead_Links_Names: Boolean=False; const AARM: TAssociativity_Reading_Mode=armLeft_Link; const AOOT: TObject_Ordering_Type=ootParent_Ascending): TObjectList; stdcall;

  ///<summary>Function creating a list of TS_Object_Data objects from a given attribute and a given preselection of Objects.</summary>
  ///<param name="AID_Attribute">The identifier of the attribute.</param>
  ///<param name="ASL_ID_Object">The preselection of Objects identifiers. If nil, the whole object Type (without the folders) is taken.</param>
  ///<param name="AExclude_Empty_Objects">If true, object without data for the given Attribute are not added.</param>
  ///<param name="AOOT">The ordering type of the result list.</param>
  TCreate_OL_Object_Data_From_Attribute=function(const AID_Attribute: Integer; const ASL_ID_Object: TStringList=nil; const AExclude_Empty_Objects: Boolean=False; const AOOT: TObject_Ordering_Type=ootID_Ascending): TObjectList; stdcall;

  ///<summary>Procedure sorting a list of TS_Object_Data objects thanks to a given numerical attribute.</summary>
  ///<param name="AOL_Object_Data">A list of the TS_Object_Data objects to sort.</param>
  ///<param name="AID_Attribute">The identifier of the attribute.</param>
  ///<param name="AAscending">If true then ascending, else descending.</param>
  TSort_OL_Object_Data=procedure(const AOL_Object_Data: TObjectList; const AID_Attribute: Integer; const AAscending: Boolean=True); stdcall;

  ///<summary>Function creating a list of TS_Object_Data objects from a given Attribute Set (for the Attributes) and a given preselection of Objects.</summary>
  ///<param name="AID_Attribute_Set">The identifier of the Attribute Set.</param>
  ///<param name="ASL_ID_Object">A list of Objects identifiers. If nil, the whole list of Objects of the Objects Types is used.</param>
  ///<param name="ARead_Object_Lkd_Names">If true, the linked Objects names are read.</param>
  ///<param name="AOOT">The sorting type of the list.</param>
  TCreate_OL_Object_Data_From_Attribute_Set=function(const AID_Attribute_Set: Integer; const ASL_ID_Object: TStringList=nil; const ARead_Object_Lkd_Names: Boolean=False; const AOOT: TObject_Ordering_Type=ootID_Ascending): TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Lockings_Manager'}
  ///<summary>Function checking if a given document object has a work file.</summary>
  ///<summary>This function may only be called for unlocked object.</summary>
  ///<param name="AID_Document">The identifier of the document object.</param>
  ///<param name="AFileName">If existing, the filename is returned as "out" parameter.</param>
  ///<returns>The function returns true if a work files exists and must be handled.</returns>
  TPrepare_CheckOut=function(const AID_Document: Integer; out AFileName: string): Boolean; stdcall;

  ///<summary>Function locking a given document and extracting its work file if required.</summary>
  ///<param name="AID_Document">The identifier of the document object.</param>
  ///<param name="APath_File">The path where to extract the work file.</param>
  ///<returns>The function returns an information message.</returns>
  TCheckOut=function(const AID_Document: Integer; const APath_File: string): string; stdcall;

  ///<summary>Function returning the path of the work file as saved during a checkout step.</summary>
  ///<param name="AID_Document">The identifier of the document object.</param>
  ///<param name="AFilename">If existing, the filename is returned as "out" parameter.</param>
  ///<param name="APath_File">The path where the file was previously saved during the checkin step.</param>
  TPrepare_CheckIn=function(const AID_Document: Integer; out AFilename: string; out APath_File: string): Boolean; stdcall;

  ///<summary>Function unlocking a document object and updating the work file is needed.</summary>
  ///<param name="AID_Document">The identifier of the document object.</param>
  ///<param name="APath_File">A new version of the work file.</param>
  TCheckIn=function(const AID_Document: Integer; const APath_File: string): string; stdcall;

  ///<summary>Function removing the unrelevant lockings: the locking with an expiracy data lower than the current time.</summary>
  ///<returns>The function returns the number of lockings removed.</returns>
  TRemove_Unrelevant_Lockings=function: Integer; stdcall;

  ///<summary>Function returning true if a given Object is locked.</summary>
  ///<summary>The function also returns two other informations: if the current user is the "locker" and a message if the object is locked by another user.</summary>
  ///<param name="AID_Object">The identifier of the object to check.</param>
  ///<param name="AUserIsLocker">If true the user is the locker.</param>
  ///<param name="AMessage">A message to show as hint for example, explaining who locked the object.</param>
  TCheckIf_Object_Locked=function(const AID_Object: Integer; out AUserIsLocker: Boolean; out AMessage: string): Boolean; stdcall;

  ///<summary>Function returning the label of a given locking type.</summary>
  ///<param name="ALocking_Type">The locking type.</param>
  TLocking_TypeToStr=function(const ALocking_Type: TLocking_Type): string; stdcall;

  ///<summary>Function locking a given object.</summary>
  ///<param name="AID_Object">The identifier of the object to lock.</param>
  TLock_Object=function(const AID_Object: Integer): string; stdcall;

  ///<summary>Function handling the automatic unlocking of a given object if needed (and allowed).</summary>
  ///<summary>To be unlocked, the object must have been locked by the active user.</summary>
  ///<param name="AIDObjectType">The identifier of the object type the object belongs to. If unknown, set it to 0.</param>
  ///<param name="AID_Object">The identifier of the object to unlock.</param>
  THandle_Automatic_Unlocking=procedure(const AIDObjectType: Integer; const AID_Object: Integer); stdcall;

  ///<summary>Function unlocking a given object.</summary>
  ///<param name="AID_Object">The identifier of the object to unlock.</param>
  TUnlock_Object=function(const AID_Object: Integer): string; stdcall;

  ///<summary>Function returning the list of lockings for a given Object Type.</summary>
  ///<param name="AIDObjectType">The identifier of the object type.</param>
  TCreate_OL_Locking=function(const AIDObjectType: Integer): TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Attribute_Filter'}
  TAttribute_Filter=class(TObject)
  public
    procedure Set_ID_Object(const AID_Object: Integer; const AForceRefresh: Boolean=False); virtual; stdcall; abstract;
    procedure Uninitialize; virtual; stdcall; abstract;
    function IsRootAttribute(const AID_Attribute: Integer): Boolean; virtual; stdcall; abstract;
    function Get_ID_Attribute: Integer; virtual; stdcall; abstract;
    function Set_Root_Objects(const AID_Root_Attribute: Integer; const ASL_ID_Root_Object: TStringList): Boolean; overload; virtual; stdcall; abstract;
    function Set_Root_Objects(const AID_Root_Attribute: Integer; const AIDs_Root_Objects: string): Boolean; overload; virtual; stdcall; abstract;
    function Create_OL_Leaf_Object(out AFullOT: Boolean): TObjectList; virtual; stdcall; abstract;
  end;
  {$ENDREGION}

  {$REGION 'U_Attribute_Filters_Manager'}
  TGet_Attribute_Filter=function(const AID_Attribute: Integer): TAttribute_Filter; stdcall;
  {$ENDREGION}

  {$REGION 'U_SolR'}
  TGet_ExternalServersToIndexCount=function: Integer; stdcall;

  TGet_OL_ExternalServersToIndex=function: TObjectList; stdcall;

  TIsTextSearchInFilesActive=function: Boolean; stdcall;

  TGet_SolRUrl=function: string; stdcall;

  TGet_SolRDir=function: string; stdcall;

  TIsTextSearchInExternalServersActive=function: Boolean; stdcall;

  TGet_UrlSolRForExternalServers=function: string; stdcall;
  {$ENDREGION}

  {$REGION 'U_Units_Manager'}
  ///<summary>Function converting a value from a unit (Source) to another (Dest).</summary>
  ///<param name="AValue">The value to convert.</param>
  ///<param name="AID_Unit_From">The identifier of the source unit.</param>
  ///<param name="AID_Unit_To">The identifier of the destination unit.</param>
  TConvert_Value=function(const AValue: Double; const AID_Unit_From: Integer; const AID_Unit_To: Integer): Double; stdcall;

  ///<summary>Function converting a "delta" value from a unit (Source) to another (Dest). The B translation is not taken into account.</summary>
  ///<param name="ADelta">The value to convert.</param>
  ///<param name="AID_Unit_From">The identifier of the source unit.</param>
  ///<param name="AID_Unit_To">The identifier of the destination unit.</param>
  TConvert_DValue=function(const ADelta: Double; const AID_Unit_From: Integer; const AID_Unit_To: Integer): Double; stdcall;

  ///<summary>Function creating a filtered list of conversion for a given unit.</summary>
  ///<param name="AID_Unit">The identifier of the unit.</param>
  ///<param name="AOL_Conversion">If nil, the conversions are searched into the loaded objects.</param>
  TCreate_OL_Conversion_From_Unit=function(const AID_Unit: Integer; const AOL_Conversion: TObjectList=nil): TObjectList; stdcall;

  ///<summary>Function returning the conversion between two units.</summary>
  ///<param name="AID_Unit1">The identifier of the first unit.</param>
  ///<param name="AID_Unit2">The identifier of the second unit.</param>
  ///<param name="AOL_Conversion">If nil, the conversion is searched into the loaded TS_Conversion objects. If not, is it searched into the given list.</param>
  ///<returns>The function returns a nil value if no conversion object could be found.</returns>
  TGet_Conversion=function(const AID_Unit1: Integer; const AID_Unit2: Integer; const AOL_Conversion: TObjectList=nil): TS_Conversion; stdcall;

  ///<summary>Function returning the name of a given unit.</summary>
  ///<param name="AID_Unit">The identifier of the unit.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Unit_Name=function(const AID_Unit: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the name of a given conversion between two units.</summary>
  ///<param name="AID_Conversion">The identifier of the conversion.</param>
  ///<param name="ARaiseException">If true, an error is raised if the object could not found.</param>
  TGet_Conversion_Name=function(const AID_Conversion: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the list of units.</summary>
  TGet_OL_Unit=function: TObjectList; stdcall;

  ///<summary>Function returning the list of conversions between units.</summary>
  TGet_OL_Conversion=function: TObjectList; stdcall;

  ///<summary>Function returning a Unit Object from its name.</summary>
  ///<param name="AID_Unit">the identifier of the unit.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Unit=function(const AID_Unit: Integer; const ARaiseException: Boolean=True): TS_Unit; stdcall;

  ///<summary>Function returning the identifier of a Unit from its name.</summary>
  ///<param name="AName">The name of the unit.</param>
  TGet_ID_Unit_From_Name=function(const AName: string): Integer; stdcall;

  ///<summary>Function returning the number of Attributes using a given Unit.</summary>
  ///<param name="AID_Unit">The identifier of the Unit.</param>
  TGet_Unit_Nb_Attributes=function(const AID_Unit: Integer): Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Files_Types_Manager'}
  ///<summary>Function returning the list of File Types.</summary>
  TGet_OL_File_Type=function: TObjectList; stdcall;

  ///<summary>Function returning a given Files Type.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_File_Type=function(const AID_File_Type: Integer; const ARaiseException: Boolean=True): TS_File_Type; stdcall;

  ///<summary>Function returning the Index Type of a File Type.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  TGet_File_Type_FIT=function(const AID_File_Type: Integer): TFile_Index_Type; stdcall;

  ///<summary>Function returning the name of a given File Type.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_File_Type_Name=function(const AID_File_Type: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the relative directory of a given File Type.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  TGet_File_Type_RDir=function(const AID_File_Type: Integer): string; stdcall;

  ///<summary>Function returning true if the files of a given File Type are read-Only.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  TGet_File_Type_Read_Only=function(const AID_File_Type: Integer): Boolean; stdcall;

  ///<summary>Function returning a File Type associated to an attribute.</summary>
  ///<param name="AID_Attribute">The identifier of the Attribute.</param>
  TGet_Attribute_File_Type=function(const AID_Attribute: Integer): TS_File_Type; stdcall;

  ///<summary>Function returning the number of Attributes using a given File Type.</summary>
  ///<param name="AID_File_Type">The identifier of the File Type.</param>
  TGet_File_Type_Nb_Attributes=function(const AID_File_Type: Integer): Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Tables_Types_Manager'}
  ///<summary>Function returning the list of Tables Types.</summary>
  TGet_OL_Table_Type=function: TObjectList; stdcall;

  ///<summary>Function returning a TS_Series_Type object from its identifier.</summary>
  ///<param name="AID_Series_Type">The identifier of the Series Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Series_Type=function(const AID_Series_Type: Integer; const ARaiseException: Boolean=True): TS_Series_Type; stdcall;

  ///<summary>Function returning the complete name of a given Series Type.</summary>
  ///<param name="AID_Series_Type">The identifier of the Series Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Series_Type_Name_Complete=function(const AID_Series_Type: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the name of a given Series Type.</summary>
  ///<param name="AID_Series_Type">The identifier of the Series Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Series_Type_Name=function(const AID_Series_Type: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the identifier of the Table Type of a given Series Type.</summary>
  ///<param name="AID_Series_Type">The identifier of the Series Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Series_Type_ID_Table_Type=function(const AID_Series_Type: Integer; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of the Unit of a given Series Type.</summary>
  ///<param name="AID_Series_Type">The identifier of the Series Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Series_Type_ID_Unit=function(const AID_Series_Type: Integer; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning a TS_Table_Type object from its identifier.</summary>
  ///<param name="AID_Table_Type">The identifier of the table type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Table_Type=function(const AID_Table_Type: Integer; const ARaiseException: Boolean=True): TS_Table_Type; stdcall;

  ///<summary>Function returning the list of Series Type associated to a given Table Type.</summary>
  ///<param name="AID_Table_Type">The identifier of the table type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Table_Type_OL_Series_Type=function(const AID_Table_Type: Integer; const ARaiseException: Boolean=True): TObjectList; stdcall;

  ///<summary>Function returning the name of a given Table Type.</summary>
  ///<param name="AID_Table_Type">The identifier of the table type.</param>
  ///<returns>The function returns an empty string if the Table Type could not be found.</returns>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Table_Type_Name=function(const AID_Table_Type: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the number of Attributes using a given Table Type.</summary>
  ///<param name="AID_Table_Type">The identifier of the Table Type.</param>
  TGet_Table_Type_Nb_Attributes=function(const AID_Table_Type: Integer): Integer; stdcall;
  {$ENDREGION}

  {$REGION 'U_Objects_Types_Manager'}
  ///<summary>Function returning the whole list of Objects Types.</summary>
  TGet_OL_OT=function: TObjectList; stdcall;

  ///<summary>Function returing the Source Object Type.</summary>
  TGet_OT_Source=function: TS_Object_Type; stdcall;

  ///<summary>Function returing the Event Object Type.</summary>
  TGet_OT_Task=function: TS_Object_Type; stdcall;

  ///<summary>Function returing the Event Type Object Type.</summary>
  TGet_OT_Task_Notification_Type=function: TS_Object_Type; stdcall;

  ///<summary>Function returing the library Type Object Type.</summary>
  TGet_OT_Library=function: TS_Object_Type; stdcall;

  ///<summary>Function returing the Information Object Type.</summary>
  TGet_OT_Information=function: TS_Object_Type; stdcall;

  ///<summary>Function returing the Portal Object Type.</summary>
  TGet_OT_Portal=function: TS_Object_Type; stdcall;

  ///<summary>Function returing the Users Object Type.</summary>
  TGet_OT_User=function: TS_Object_Type; stdcall;

  ///<summary>Function returning the whole list of standard Objects Types (visible or not).</summary>
  TGet_OL_OT_Standard=function: TObjectList; stdcall;

  ///<summary>Function returning the list of standard and invisible Objects Types.</summary>
  TGet_OL_OT_Standard_Invisible=function: TObjectList; stdcall;

  ///<summary>Function returning the list of standard and visible Objects Types.</summary>
  TGet_OL_OT_Standard_Visible=function: TObjectList; stdcall;

  ///<summary>Function returning the list of associative Objects Types.</summary>
  TGet_OL_OT_Associative=function: TObjectList; stdcall;

  ///<summary>Function returning the list of listing Objects Types.</summary>
  TGet_OL_OT_Listing=function: TObjectList; stdcall;

  ///<summary>Function returning true if an Object Type is associative.</summary>
  ///<param name="AID_OT">the identifier of the Object Type.</param>
  TGet_OT_Associativity=function(const AID_OT: Integer): Boolean; stdcall;

  ///<summary>Function returning the locking type.</summary>
  ///<param name="AID_OT">the identifier of the Object Type.</param>
  TGet_OT_Locking_Type=function(const AID_OT: Integer): TLocking_Type; stdcall;

  ///<summary>Function returning the icon index of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_OT_Icon=function(const AID_OT: Integer; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning an TS_Object_Type object from its identifier.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if the Object Type could not be found.</param>
  TGet_OT=function(const AID_OT: Integer; const ARaiseException: Boolean=True): TS_Object_Type; stdcall;

  ///<summary>Function checking if a given Object Type exists. The fucntion may return a false value or raise an EObject_Type_Not_Found error if the Object could not be found.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="AIgnore_Rights">If true, rights are ignored.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TCheck_OT_Existence=function(const AID_OT: Integer; const AIgnore_Rights: Boolean=False; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function returning the identifier of the Source Object Type.</summary>
  TGet_ID_OT_Source=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the Information Object Type.</summary>
  TGet_ID_OT_Information=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the User Object Type.</summary>
  TGet_ID_OT_User=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the Portal Object Type.</summary>
  TGet_ID_OT_Portal=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the Event Object Type.</summary>
  TGet_ID_OT_Project=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the Event Object Type.</summary>
  TGet_ID_OT_Task=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the Event type Object Type.</summary>
  TGet_ID_OT_Task_Notification_Type=function: Integer; stdcall;

  ///<summary>Function returning the identifier of the Library type Object Type.</summary>
  TGet_ID_OT_Library=function: Integer; stdcall;

  ///<summary>Function returning the list of Tab Attribute of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TGet_OT_OL_Tab=function(AID_OT: Integer): TObjectList; stdcall;

  ///<summary>Function returning the list of Attribute of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TGet_OT_OL_Attribute=function(const AID_OT: Integer): TObjectList; stdcall;

  ///<summary>Function returning the number of visible Attributes of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TGet_OT_Nb_Attributes=function(const AID_OT: Integer): Integer; stdcall;

  ///<summary>Function returning the right of a given Object Type for the current user.</summary>
  ///<param name="AID_OT">The identifier of the Object Type</param>
  ///<returns>The right of the Object Type. The function returns a "none" right if the Object Type is not found.</returns>
  TGet_OT_Right=function(const AID_OT: Integer): TDB_Right; stdcall;

  ///<summary>Function returning the type of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TGet_OT_Type=function(const AID_OT: Integer): Integer; stdcall;

  ///<summary>Function returning the hint of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<returns>The hint text. The function returns an empty string if the Object Type was not found.</returns>
  TGet_OT_Hint=function(const AID_OT: Integer): string; stdcall;

  ///<summary>Function returning the name of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_OT_Name=function(const AID_OT: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the numbers of objects of a given Object Type.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  ///<param name="AInclude_Folders">If false, folders objects are not included.</param>
  TGet_OT_Nb_Objects=function(const AID_OT: Integer; const AInclude_Folders: Boolean=True): Integer; stdcall;

  ///<summary>Function returning true if a given Object Type has at least one active and visible extraction.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TCheckIf_OT_Extractable=function(const AID_OT: Integer): Boolean; stdcall;

  ///<summary>Function returning true if a given Object Type is a folder.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TGet_OT_Folder=function(const AID_OT: Integer): Boolean; stdcall;
  {$ENDREGION}

  {$REGION 'U_Attributes_Manager'}
  ///<summary>Function returning true if a given Attribute is a clickable link.</summary>
  ///<summary>The function handles associative links.</summary>
  TGet_Attribute_Clickability=function(const AIdAttribute: Integer): Boolean; stdcall;

  ///<summary>Procedure returning, for a link Attribute, the filtering type, its destination Object Type, its parent filtering.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  ///<param name="AFilter_Type">The filtering type of the link Attribute.</param>
  ///<param name="AID_OT_Destination">The identifier of the Object Type.</param>
  ///<param name="AID_Parent">The identifier of the Parent Object used as filter.</param>
  ///<param name="AStrongFilter">If the filtering type is strong or not.</param>
  TRetrieve_Link_Attribute_Informations=procedure(const AIdAttribute: Integer; out AFilter_Type: TLink_Attribute_Filtering_Type; out AID_OT_Destination: Integer; out AID_Parent: Integer; out AStrongFilter: Boolean; const ARaiseException: Boolean=True); stdcall;

  ///<summary>Function returning an attribute from its ID_S_Object_Information attribute.</summary>
  ///<param name="AID_Object_Information">The identifier of the information object.</param>
  TGet_Attribute_From_ID_Object_Information=function(const AID_Object_Information: Integer): TS_Attribute; stdcall;

  ///<summary>Function returning an attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): TS_Attribute; stdcall;

  ///<summary>Function returning true if a given Attribute is a link Attribute.</summary>
  ///<param name="AIdAttribute">The Attribute to check.</param>
  ///<param name="ARaiseException">If true, the function may raise an EAttribute_Not_Link or an EAttribute_Not_Link error instead of returning a false statement.</param>
  TCheckIf_Link_Attribute=function(const AIdAttribute: Integer; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function returning true if a given Attribute is a boolean Attribute.</summary>
  ///<param name="AIdAttribute">The Attribute to check.</param>
  ///<param name="ARaiseException">If true, the function may raise an EAttribute_Not_File or an EAttribute_Not_Boolean error instead of returning a false statement.</param>
  TCheckIf_File_Attribute=function(const AIdAttribute: Integer; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function returning true if a given Attribute is a numerical Attribute.</summary>
  ///<summary>Date and table Attributes are considered as numerical Attributes.</summary>
  ///<param name="AIdAttribute">The Attribute to check.</param>
  ///<param name="ARaiseException">If true, the function may raise an EAttribute_Not_Numerical or an EAttribute_Not_Numerical error instead of returning a false statement.</param>
  TCheckIf_Numerical_Attribute=function(const AIdAttribute: Integer; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function returning true if a given Attribute is a string Attribute.</summary>
  ///<param name="AIdAttribute">The Attribute to check.</param>
  ///<param name="ARaiseException">If true, the function may raise an EAttribute_Not_String or an EAttribute_Not_String error instead of returning a false statement.</param>
  TCheckIf_String_Attribute=function(const AIdAttribute: Integer; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function returning true if a given Attribute has its data type present into a given list.</summary>
  ///<param name="AIdAttribute">The Attribute to check.</param>
  ///<param name="AArr_TD_Allowed">The list of allowed data types.</param>
  ///<param name="ARaiseException">If true, the function may raise an EAttribute_With_Wrong_TD or an EAttribute_With_Wrong_TD error instead of returning a false statement.</param>
  TCheck_Attribute_Data_Type=function(const AIdAttribute: Integer; const AArr_TD_Allowed: array of Integer; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function checking the existence of a given Attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="AIgnore_Rights">If true, rights are ignored.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error in case the Attribute is not found.</param>
  ///<param name="AName">The name of the Attribute supposed to exist. It is only used in the error message.</param>
  TCheck_Attribute_Existence=function(const AIdAttribute: Integer; const AIgnore_Rights: Boolean=False; const ARaiseException: Boolean=True; const AName: string=''): Boolean; stdcall;

  ///<summary>Function returning the data type of an attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_TD=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the name of an attribute from its identifier.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_Name=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): string; stdcall;

  ///<summary>Function returning the hint of a given Attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  ///<returns>The hint text. The function returns an empty string if the Attribute was not found.</returns>
  TGet_Attribute_Hint=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): string; stdcall;

  ///<summary>Function returning true if the Attribute is a list Attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_List=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Boolean; stdcall;

  ///<summary>Function returning the identifier of the tab attribute of a given Attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_Tab=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the identifier of the File Type associated to an attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_File_Type=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the identifier of the Main Unit of an attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_Unit=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the identifier of the Table Type associated to an attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_Table_Type=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the Table Type associated to an attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_Table_Type=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): TS_Table_Type; stdcall;

  ///<summary>Function returning the Table Type associated to an attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_OL_Series_Type=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): TObjectList; stdcall;

  ///<summary>Function returning the identifier of the destination Object Type for a link Attribute.</summary>
  ///<values>In case of an inherited Attribute, the functions first looks for the "inheritage" Attribute.</values>
  ///<param name="AIdAttribute">The identifier of the attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_OT_Destination=function(const AIdAttribute: Integer; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of the right associative Link Type of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Ass_Attribute_ID_Right_Link_Type=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of the left associative Link Type of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Ass_Attribute_ID_Left_Link_Type=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of the right associative attribute of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Ass_Attribute_ID_Right_Attribute=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of the left associative attribute of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Ass_Attribute_ID_Left_Attribute=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the associative Object Type identifier of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Ass_Attribute_ID_OT_Associative=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the list of attribute of the associative Object Type of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_OL_Associative_Attribute=function(const AIdAttribute: Integer): TObjectList; stdcall;

  ///<summary>Function returning the identifier of the left Object Type of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Ass_Attribute_ID_OT_Left=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of the right Object Type of an associative attribute from its identifier.</summary>
  ///<param name="AIdAttribute">The identifier of the attribute.</param>
  TGet_Ass_Attribute_ID_OT_Right=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the absolute order of a given Attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_Absolute_Order=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the identifier of the Information's Object of a given Attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_Object_Information=function(AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the list of Table Attributes of a given Object Type using Excel to generate the graphics.</summary>
  ///<param name="AID_OT">The identifier of the Object Type.</param>
  TGet_OL_Attribute_Table_Using_Excel=function(const AID_OT: Integer): TObjectList; stdcall;

  ///<summary>Function returning the identifier of the Attribute Set filtering a given link Attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<returns>The function returns a nul value if the Attribute Set is empty.</returns>
  TGet_Attribute_ID_Attribute_Set_Filtering=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning theAttribute Set filtering a given link Attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  TGet_Attribute_Attribute_Set_Filtering=function(const AIdAttribute: Integer): TS_Attribute_Set; stdcall;

  ///<summary>Function returning the identifier of the source Object Type for a link Attribute.</summary>
  ///<values>In case of an inherited Attribute, the functions first looks for the "inheritage" Attribute.</values>
  ///<param name="AIdAttribute">The identifier of the attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_OT_Source=function(const AIdAttribute: Integer; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning the identifier of the Object Type for a link Attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_ID_OT=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Integer; stdcall;

  ///<summary>Function returning the identifier of the Link Type for a link Attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_ID_LT=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the multiplicity for a link Attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_Multiplicity=function(const AIdAttribute: Integer): Boolean; stdcall;

  ///Function returning true if the inverse link do not exist or has a N multiplicity.
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  TGet_Attribute_Multiplicity_Inverse_Link=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): Boolean; stdcall;

  ///<summary>Function returning true if a link Attribute is an inverse link.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_Inverse=function(const AIdAttribute: Integer): Boolean; stdcall;

  ///<summary>Function returning the identifier of the filtering object for a link Attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_ID_Object_Filtering=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning true if a link Attribute has its inherited data table tranposed.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_Transpose=function(const AIdAttribute: Integer): Boolean; stdcall;

  ///<summary>Function returning true if a given attribute is inherited.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_Inherited=function(const AIdAttribute: Integer): Boolean; stdcall;

  ///<summary>Function returning the identifier of the inheritage link Attribute of a given (inherited) attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_ID_Attribute_Lnk_Inheritage=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of the inheritage Attribute of a given (inherited) attribute.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_ID_Attribute_Inheritage=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function returning true if a link Attribute is an associative link.</summary>
  ///<summary>An associative link does NOT belong to an associative Object Type.</summary>
  ///<param name="AIdAttribute">the identifier of the Attribute.</param>
  TGet_Attribute_Associativity=function(const AIdAttribute: Integer): Boolean; stdcall;

  ///<summary>Function returning the whole list of attributes.</summary>
  TGet_OL_Attribute_Complete=function: TObjectList; stdcall;

  ///<summary>Function returning the identifier of the parent Attribute of a given Attribute.</summary>
  ///<param name="AIdAttribute">The identifier of the attribute.</param>
  ///<param name="ARaiseException">If true, the function raises an EAttribute_Not_Found error if no Attribute could be found.</param>
  ///<returns>The function returns -1 if no Attribute could be found (and no exception is being raised).</returns>
  TGet_Attribute_ID_Parent=function(const AIdAttribute: Integer; const ARaiseException: Boolean=True): Integer; stdcall;

  ///<summary>Function returning if a given Attribute belongs to a given Object Type.</summary>
  ///<param name="AIdAttribute">The Attribute to check.</param>
  ///<param name="AID_OT_Expected">The Object Type the Attribute should belong to.</param>
  ///<param name="ARaiseException">If true, the function may raise an EAttribute_Not_Found or an EAttribute_With_Wrong_TD error instead of returning a false statement.</param>
  TCheck_Attribute_Object_Type=function(const AIdAttribute: Integer; const AID_OT_Expected: Integer; const ARaiseException: Boolean=True): Boolean; stdcall;

  ///<summary>Function returning the list of units of a given Attribute.</summary>
  TGet_Attribute_SL_ID_Unit=function(const AIdAttribute: Integer; const ARaiseException: Boolean=False): TStringList; stdcall;

  TRetrieveNumericalAttributeValues=procedure(const AIdAttribute: Integer; out ANbData: Integer; out AMinValue: Double; out AMaxValue: Double); stdcall;

  ///<summary>Function returning the min value accessible to the active User for a given numerical Attribute.</summary>
  ///<summary>The function raises an E_Attribute_Not_Numerical error if the Attribute is not numerical.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<returns>The function returns NaN is no value is found.</returns>
  TGet_Attribute_Min_Value=function(const AIdAttribute: Integer): Double; stdcall;

  ///<summary>Function returning the max value accessible to the active User for a given numerical Attribute.</summary>
  ///<summary>The function raises an E_Attribute_Not_Numerical error if the Attribute is not numerical.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  ///<returns>The function returns NaN is no value is found.</returns>
  TGet_Attribute_Max_Value=function(const AIdAttribute: Integer): Double; stdcall;

  ///<summary>Function returning the number of data accessible to the Active User.</summary>
  ///<summary>The function is not compatible with links.</summary>
  ///<param name="AIdAttribute">The identifier of the Attribute.</param>
  TGet_Attribute_Nb_Data=function(const AIdAttribute: Integer): Integer; stdcall;

  ///<summary>Function creating a list of children Attributes.</summary>
  ///<param name="AID_Parent">the identifier of the parent.</param>
  ///<param name="ARecursive">If true, the list contains the full branches.</param>
  ///<param name="AExclude_Inherited">If true, inherited Attributes are ignored.</param>
  TCreate_OL_Attribute_Filtered=function(const AID_Parent: Integer; const ARecursive: Boolean; const AExclude_Inherited: Boolean=False): TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Links_Types_Manager'}
  ///<summary>Function returning the filter type of a given link Type depending on its sense (direct / inverse).</summary>
  TGet_Link_Type_Filtering_Type=function(const AID_Link_Type: Integer; const AInv: Boolean): TLink_Attribute_Filtering_Type; stdcall;

  ///<summary>Function returning the boolean bResearch_Filtering of a given link Type depending on its sense (direct / inverse).</summary>
  TGet_Link_Type_Research_Filtering=function(const AID_Link_Type: Integer; const AInv: Boolean): Boolean; stdcall;

  ///<summary>Function returning the identifier of the Attribute using a given Link Type into the "direct" direction.</summary>
  ///<param name="AID_Link_Type">The identifier of the Link Type.</param>
  ///<returns>The function may return a null value. This mean that no Attribute uses the Link Type into this direction.</returns>
  TGet_Link_Type_ID_Direct_Attribute=function(const AID_Link_Type: Integer): Integer; stdcall;

  ///<summary>Function returning the identifier of the Attribute using a given Link Type into the "inverse" direction.</summary>
  ///<param name="AID_Link_Type">The identifier of the Link Type.</param>
  ///<returns>The function may return a null value. This mean that no Attribute uses the Link Type into this direction.</returns>
  TGet_Link_Type_ID_Inv_Attribute=function(const AID_Link_Type: Integer): Integer; stdcall;

  ///<summary>Function returning the the Attribute object using a given Link Type into the "direct" direction.</summary>
  ///<param name="AID_Link_Type">The identifier of the Link Type.</param>
  ///<returns>The function returns a nil value. This mean that no Attribute uses the Link Type into this direction.</returns>
  TGet_Link_Type_Direct_Attribute=function(const AID_Link_Type: Integer): TS_Attribute; stdcall;

  ///<summary>Function returning the the Attribute object using a given Link Type into the "inverse" direction.</summary>
  ///<param name="AID_Link_Type">The identifier of the Link Type.</param>
  ///<returns>The function returns a nil value. This mean that no Attribute uses the Link Type into this direction.</returns>
  TGet_Link_Type_Inv_Attribute=function(const AID_Link_Type: Integer): TS_Attribute; stdcall;

  ///<summary>Function returning the list of Link Types.</summary>
  TGet_OL_Link_Type=function: TObjectList; stdcall;

  ///<summary>Function returning the a TS_Link_Type object from its identifier.</summary>
  ///<param name="AID_Link_Type">The identifier of the Link Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Link_Type=function(const AID_Link_Type: Integer; const ARaiseException: Boolean=True): TS_Link_Type; stdcall;

  ///<summary>Function returning the a the name of a given Link Type.</summary>
  ///<param name="AID_Link_Type">The identifier of the Link Type.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Link_Type_Name=function(const AID_Link_Type: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning true if a Link Type is associative.</summary>
  ///<param name="AID_Link_Type">The identifier of the Link Type.</param>
  TGet_Link_Type_Associativity=function(AID_Link_Type: Integer): Boolean; stdcall;
  {$ENDREGION}

  {$REGION 'U_Choices_Guides_Manager'}
  ///<summary>Procedure initializing the Choice Guides variables and list.</summary>
  ///<summary>It must NOT be called except if loaded Choice Guides objects are manually modified.</summary>
  TInitialize_Choice_Guides=procedure; stdcall;

  ///<summary>Procedure loading the Choice Guides Objects.</summary>
  TLoad_Choice_Guides=procedure; stdcall;

  ///<summary>Function returning a Choice Guide from its identifier.</summary>
  ///<param name="AID_Choice_Guide">The identifier of the choice guide.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Choice_Guide=function(const AID_Choice_Guide: Integer; const ARaiseException: Boolean=True): TCG_Choice_Guide; stdcall;

  ///<summary>Function returning the name of a given Choice Guide.</summary>
  ///<param name="AID_Choice_Guide">The identifier of the choice guide.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Choice_Guide_Name=function(const AID_Choice_Guide: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning a Question from its identifier.</summary>
  ///<param name="AID_Question">The identifier of the Question.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Question=function(const AID_Question: Integer; const ARaiseException: Boolean=True): TCG_Question; stdcall;

  ///<summary>Function returning the name of a given Question.</summary>
  ///<param name="AID_Question">The identifier of the Question.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Question_Name=function(const AID_Question: Integer; const ARaiseException: Boolean): string; stdcall;

  ///<summary>Function returning true if the choice guide were loaded.</summary>
  TGet_Choice_Guide_Loaded=function: Boolean; stdcall;

  ///<summary>Function returning the list of Choices Guides loaded.</summary>
  TGet_OL_Choice_Guide=function: TObjectList; stdcall;
  {$ENDREGION}

  {$REGION 'U_Exportations_Manager'}
  ///<summary>Function returning the list of Exportations.</summary>
  TGet_OL_Exportation=function: TObjectList; stdcall;

  ///<summary>Function returning an TE_Exportation object from its identifier.</summary>
  ///<param name="AID_Exportation">The identifier of the Exportation.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Exportation=function(const AID_Exportation: Integer; const ARaiseException: Boolean=True): TE_Exportation; stdcall;

  ///<summary>Function returning an TE_Exportation object from its identifier.</summary>
  ///<param name="AID_Exportation">The identifier of the Exportation.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGet_Exportation_Name=function(const AID_Exportation: Integer; const ARaiseException: Boolean=True): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_RequirementsListHelper'}
  TRequirementsListAdvancedHelper=class(TObject)
  public
    ///<summary>Function returning the whole list of system requirements lists.</summary>
    ///<param name="AFullLoading">If true, the sub-rls, the criteria and the preselection are loaded.</param>
    function ListSystem_(const AFullLoading: Boolean): TObjectList; virtual; stdcall; abstract;
    function WriteComparisonRequirementList(const AIdObject: Integer; const ASlIdAttribute: TStringList; const AIdAdvancedComparison: Integer=0): Integer; virtual; stdcall; abstract;
  end;

  TRequirementsListHelper=class(TObject)
  public
    function GetSystemRequirementList(const ARlTag: string): TMCS_Requirement_List; overload; virtual; stdcall; abstract;
    function GetSystemRequirementList(const AIdRl: Integer): TMCS_Requirement_List; overload; virtual; stdcall; abstract;
    function Read_(const AIdRequirementsList: Integer): TMCS_Requirement_List; overload; virtual; stdcall; abstract;
    ///<summary>Function creating and returning a tagged Requirements List object.</summary>
    ///<param name="ATag">The tag of the Requirements List.</param>
    ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Requirements List.</param>
    function Read_(const ATag: string; const ARaiseException: Boolean=True): TMCS_Requirement_List; overload; virtual; stdcall; abstract;
    function New_: TMCS_Requirement_List; virtual; stdcall; abstract;
    ///<summary>Function returning the list of standard Requirement Lists (potentially filtered on a given Object Type).</summary>
    ///<param name="AIdFilteringObjectType">The identifier of the filtering Object Type.</param>
    ///<param name="AFullLoading">If true, the sub-rls, the criteria and the preselection are loaded.</param>
    function ListStandard_(const AIdFilteringObjectType: Integer; const AFullLoading: Boolean): TObjectList; virtual; stdcall; abstract;
    function Advanced: TRequirementsListAdvancedHelper; virtual; stdcall; abstract;
    function GetName(const AIdRequirementsList: Integer; const ARaiseException: Boolean): string; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of a tagged Requirements List.</summary>
    ///<param name="ATag">The tag of the Requirements List.</param>
    ///<param name="ARaiseException">If true, the function raises an error if the tag corresponds to no Requirements List.</param>
    function TagToId(const ATag: string; const ARaiseException: Boolean=True): Integer; virtual; stdcall; abstract;
  end;

  T_RequirementsList=function: TRequirementsListHelper; stdcall;

  ///<summary>Function returning the name of a given Requirement List.</summary>
  ///<param name="AIdRequirementsList">The identifier of the Requirement List.</param>
  ///<param name="ARaiseException">If true, an error is raised if the identifier doest not correspond to any existing Requirements List.</param>
  TGetRequirementsListName=function(const AIdRequirementsList: Integer; const ARaiseException: Boolean=True): string; stdcall;
  {$ENDREGION}

  {$REGION 'U_BusinessViewHelper'}
  TBusinessObjectHelper=class(TObject)
  public
    function New_(const AIdBusinessView: Integer; const AIdLevel: Integer; const AObject: TS_Object=nil): TBV_Object; overload; virtual; stdcall; abstract;
    function New_(const AJSON: string): TBV_Object; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the children objects of a given business object. They may be direct children objects of the given object (in case of an iLevel=0 TBV_Object) or/and linked objects.</summary>
    ///<param name="AOlBusinessObjectPath">The business objects corresponding to the path of the object to expand. The last object of the list is the node to expand. The first one is its root node.</param>
    ///<param name="AIdBusinessView">The identifier of the business view.</param>
    ///<param name="AFullExpand">If true, the whole branch/tree is returned.</param>
    function Expand_(const AOlBusinessObjectPath: TObjectList; const AIdBusinessView: Integer; const AFullExpand: Boolean=False): TObjectList; virtual; stdcall; abstract;
    ///<summary>Function updating a business view object. The new data have to be read.</summary>
    ///<values>This function is usefull to update object of business view whose data are modified into a form (for example).</values>
    ///<param name="AOlBusinessObjectPath">The BV objects corresponding to the path of the object to update. The last object of the list is the node to update. The first one is its root node.</param>
    ///<returns>The function returns true if at least one data was updated.</returns>
    function Update(const AOlBusinessObjectPath: TObjectList): Boolean; overload; virtual; stdcall; abstract;
    ///<summary>Function updating a business view object thanks to a list of data (supposed to be more recent).</summary>
    ///<values>This function is usefull to update object of business view whose data are modified into a form (for example).</values>
    ///<param name="AOlBusinessObjectPath">The BV objects corresponding to the path of the object to update. The last object of the list is the node to update. The first one is its root node.</param>
    ///<param name="AOlData">The list of data used to update the Object.</param>
    ///<returns>The function returns true if at least one data was updated.</returns>
    function Update(const AOlBusinessObjectPath: TObjectList; const AOlData: TObjectList): Boolean; overload; virtual; stdcall; abstract;
    ///<summary>Function updating a business view object thanks to a single data (supposed to be more recent).</summary>
    ///<values>This function is usefull to update an object of the business view when the a child link object was added .</values>
    ///<param name="AOlBusinessObjectPath">The BV objects corresponding to the path of the object to update. The last object of the list is the node to update. The first one is its root node.</param>
    ///<param name="AData">The data to use to update the Object.</param>
    ///<returns>The function returns true if at least one data was updated.</returns>
    function Update(const AOlBusinessObjectPath: TObjectList; const AData: TD_Data_Link): Boolean; overload; virtual; stdcall; abstract;
  end;

  TBusinessViewHelper=class(TObject)
  public
    function GetList: TObjectList; virtual; stdcall; abstract;
    function Get(const AIdBusinessView: Integer; const ARaiseException: Boolean=True): TS_Attribute_Set; virtual; stdcall; abstract;
    function GetLevel(const AIdBusinessView: Integer; const AIdLevel: Integer; const ARaiseException: Boolean=True): TS_Attribute_Set_Level; overload; virtual; stdcall; abstract;
    function GetLevel(const AIdBusinessView: Integer; const AIdParentLevel: Integer; const AIdAttribute: Integer; const ARaiseException: Boolean=True): TS_Attribute_Set_Level; overload; virtual; stdcall; abstract;
    ///<summary>Function creating a list of possible pathes to find a given object into a given business view.</summary>
    ///<param name="AIdBusinessView">The identifier of the Business view.</param>
    ///<param name="AIdObject">The identifier of the Object to search.</param>
    ///<param name="APreferedPath">A prefered path. If one of the path found is compatible with the prefered path, it is put at the first position of the list sent as result.</param>
    ///<returns>A TObjectList of TPath objects.</returns>
    function SearchBusinessObject_(const AIdBusinessView: Integer; const AIdObject: Integer; const APreferedPath: TPath): TObjectList; virtual; stdcall; abstract;
    function ListRootBusinessObjects_(const AIdBusinessView: Integer): TObjectList; virtual; stdcall; abstract;
  end;

  T_BusinessView=function: TBusinessViewHelper; stdcall;

  T_BusinessObject=function: TBusinessObjectHelper; stdcall;
  {$ENDREGION}

  {$REGION 'U_ContextStringHelper'}
  TContextStringHelper=class(TObject)
  public
    ///<summary>Method contextualizing a given string. The string is assumed to be "object" independant.</summary>
    function Contextualize(const S: string): string; overload; virtual; stdcall; abstract;
    ///<summary>Method contextualizing a given string thanks to a given object. The function READS the needed data, names, aso.</summary>
    function Contextualize(const S: string; const AIdObject: Integer; const ADataSeparator: string=','): string; overload; virtual; stdcall; abstract;
    ///<summary>Method contextualizing a given string thanks to a given object. The function does NOT read the needed data.</summary>
    function Contextualize(const S: string; const AObject: TNamed_Object; const ADataSeparator: string=','): string; overload; virtual; stdcall; abstract;
    ///<summary>Method extracting the attributes chains from a given string and filling a given attributes set with them.</summary>
    procedure ExtractAttributes(const S: string; const AAttributesSetToFill: TS_Attribute_Set); virtual; stdcall; abstract;
    ///<summary>Method returning the external link of a given object.</summary>
    function GetObjectExternalLink(const AIdObject: Integer): string; overload; virtual; stdcall; abstract;
    ///<summary>Method returning the external link of a given object.</summary>
    function GetObjectExternalLink(const AObject: TNamed_Object): string; overload; virtual; stdcall; abstract;
  end;

  T_ContextString=function: TContextStringHelper; stdcall;
  {$ENDREGION}

  {$REGION 'U_ContextVariablesHelpers'}
  TVariablesAdvancedHelper=class(TObject)
  public
    ///<summary>Method setting or updating a given pair key / string value.</summary>
    function SetPair(const AKey: string; const AValue: string): string; overload; virtual; stdcall; abstract;
    ///<summary>Method setting or updating a given pair key / float value.</summary>
    function SetPair(const AKey: string; const AValue: Double): Double; overload; virtual; stdcall; abstract;
    ///<summary>Method setting or updating a given pair key / boolean value.</summary>
    function SetPair(const AKey: string; const AValue: Boolean): Boolean; overload; virtual; stdcall; abstract;
    ///<summary>Method setting or updating a given pair key / integer value.</summary>
    function SetPair(const AKey: string; const AValue: Integer): Integer; overload; virtual; stdcall; abstract;
    ///<summary>Method removing a given pair.</summary>
    procedure RemoveValue(const AKey: string); virtual; stdcall; abstract;
  end;

  TVariablesVirtualHelper=class(TObject)
  public
    ///<summary>Method returning the string value corresponding to a given key.</summary>
    function GetValue(const AKey: string; const ADefault: string=''): string; virtual; stdcall; abstract;
    ///<summary>Method returning the float value corresponding to a given key.</summary>
    function GetfValue(const AKey: string; const ADefault: Double=-NAN): Double; virtual; stdcall; abstract;
    ///<summary>Method returning the boolean value corresponding to a given key.</summary>
    function GetbValue(const AKey: string; const ADefault: Boolean=False): Boolean; virtual; stdcall; abstract;
    ///<summary>Method returning the integer value corresponding to a given key.</summary>
    function GetiValue(const AKey: string; const ADefault: Integer=0): Integer; virtual; stdcall; abstract;
    ///<summary>Method returning true if a given key was found.</summary>
    function IsDefined(const AKey: string): Boolean; virtual; stdcall; abstract;
  end;

  TVariablesHelper=class(TVariablesVirtualHelper)
  public
    ///<summary>Method setting or updating a given pair key / string value.</summary>
    function SetValue(const AValue: string; const AKey: string=''): string; overload; virtual; stdcall; abstract;
    ///<summary>Method setting or updating a given pair key / string value.</summary>
    function SetValue(const AValue: Double; const AKey: string=''): string; overload; virtual; stdcall; abstract;
    ///<summary>Method setting or updating a given pair key / boolean value.</summary>
    function SetValue(const AValue: Boolean; const AKey: string=''): string; overload; virtual; stdcall; abstract;
    ///<summary>Method setting or updating a given pair key / integer value.</summary>
    function SetValue(const AValue: Integer; const AKey: string=''): string; overload; virtual; stdcall; abstract;
    ///<summary>Method returning the string value corresponding to a given key and erasing it.</summary>
    function ExtractValue(const AKey: string; const ADefault: string=''): string; virtual; stdcall; abstract;
    ///<summary>Method returning the string value corresponding to a given key and erasing it.</summary>
    function ExtractfValue(const AKey: string; const ADefault: Double=-NAN): Double; virtual; stdcall; abstract;
    ///<summary>Method returning the string value corresponding to a given key and erasing it.</summary>
    function ExtractbValue(const AKey: string; const ADefault: Boolean=False): Boolean; virtual; stdcall; abstract;
    ///<summary>Method returning the string value corresponding to a given key and erasing it.</summary>
    function ExtractiValue(const AKey: string; const ADefault: Integer=0): Integer; virtual; stdcall; abstract;
  end;

  TConstantsAdministrationHelper=class(TVariablesAdvancedHelper)
  public
    ///<summary>Method returning the whole dictionary. DO NOT FREE IT!</summary>
    function List: TDictionary<string,string>; virtual; stdcall; abstract;
    procedure Assign(const ASlContant: TStringList); overload; virtual; stdcall; abstract;
    procedure Assign(const AConstants: TDictionary<string,string>); overload; virtual; stdcall; abstract;
    ///<summary>Method updating the context variables file with the content of the current dictionary.</summary>
    procedure Write; virtual; stdcall; abstract;
  end;

  TConstantsHelper=class(TVariablesVirtualHelper)
  public
    function Administration: TConstantsAdministrationHelper; virtual; stdcall; abstract;
  end;

  ///<summary>Helper for the constants stored into the file 'Context_Variables.exml'.</summary>
  T_Constants=function: TConstantsHelper; stdcall;

  T_Variables=function: TVariablesHelper; stdcall;
  {$ENDREGION}

  {$REGION 'U_ObjectSettingsHelper'}
  TObjectSettingsHelper=class(TObject)
  public
    ///<summary>Function returning the settings string for a given object and tag.</summary>
    ///<summary>The object identifier may be null. The tag string may be empty. BUT NOT BOTH!</summary>
    ///<param name="ATag">If the tag is empty, no filtering on tag is aplied.</param>
    ///<param name="AIdObject">If the object identifier is null, a "NULL" filter is applied.</param>
    function Read(const AIdObject: Integer; const ATag: string): string; virtual; stdcall; abstract;
    ///<summary>Function updating the settings for a given object and tag.</summary>
    ///<summary>Send an empty string to remove the entry from the table.</summary>
    ///<summary>The object identifier may be null. The tag string may be empty. BUT NOT BOTH!</summary>
    function Write(const AIdObject: Integer; const ATag: string; const ASettings: string): string; virtual; stdcall; abstract;
    ///<summary>Function updating the settings for a given object and tag. It concats the existing string with the given string with a given string separator.</summary>
    ///<summary>The object identifier may be null. The tag string may be empty. BUT NOT BOTH!</summary>
    function Concat(const AIdObject: Integer; const ATag: string; const ASettingsToConcat: string; const ASeparator: string=''): string; virtual; stdcall; abstract;
  end;

  T_ObjectSettings=function: TObjectSettingsHelper; stdcall;
  {$ENDREGION}

  {$REGION 'U_ModelApplicationHelper'}
  TModelHelper=class(TObject)
  public
    function LoadTxDll(const AFilePath: string; const AKeepLoaded: Boolean; out AUnload: Boolean): NativeUInt; overload; virtual; stdcall; abstract;
    function LoadTxDll(const AFilePath: string): NativeUInt; overload; virtual; stdcall; abstract;
    ///<summary>Function calling a dll function respecting the type of the TxAPI models.</summary>
    ///<summary>function(AParameters: array of const): TArr_VarRec; stdcall; export;</summary>
    ///<param name="AFilePath">The path of the dll file.</param>
    ///<param name="AFunction">The name of the function to call.</param>
    ///<param name="AArrInputs">The list of parameters to send to the function.</param>
    ///<param name="AKeepLoaded">If true, the dll is kept loaded after having beeing called. This allows to speed up the next call but the dll must be compliant with this kind of functioning.</param>
    function CallTxDllFunction(const AFilePath: string; const AFunction: string; const AArrInputs: array of TVarRec; const AKeepLoaded: Boolean): TArr_VarRec; virtual; stdcall; abstract;
    ///<summary>Procedure unloading the dll files corresponding to specific devs loaded by the TxAPI.</summary>
    procedure UnloadTxDlls; virtual; stdcall; abstract;
    function List: TObjectList; virtual; stdcall; abstract;
    ///<summary>Function returning a model application thanks to its identifier.</summary>
    ///<param name="AIdModel">The identifier of the Model.</param>
    ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
    function Get(const AIdModel: Integer; const ARaiseException: Boolean=True): TMA_Model; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the name of a given Model Application.</summary>
    ///<param name="AIdModel">The identifier of the Model.</param>
    ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
    function GetName(const AIdModel: Integer; const ARaiseException: Boolean=True): string; virtual; stdcall; abstract;
    ///<summary>Function returning a tagged Model.</summary>
    ///<param name="ATag">The tag of model.</param>
    ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
    function Get(const ATag: string; const ARaiseException: Boolean=True): TMA_Model; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of a tagged Model.</summary>
    ///<param name="ATag">The tag of the Model.</param>
    ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
    function TagToId(const ATag: string; const ARaiseException: Boolean=True): Integer; virtual; stdcall; abstract;
  end;

  TModelApplicationAdvancedHelper=class(TObject)
  public
    ///<summary>function the identifier of a model application triggering on a Object checking action in link attribute form. </summary>
    ///<param name="AIdAttribute">The identifier of the link attribute.</param>
    function GetAttributeIdModelApplicationForDynamicGroup(const AIdAttribute: Integer): Integer; virtual; stdcall; abstract;
    procedure InitializeModelApplicationsInputs(var AArrInputs: TArr_VarRec; const AIdModelApplication: Integer; const AIdObjectType: Integer); overload; virtual; stdcall; abstract;
    procedure InitializeModelApplicationsInputs(var AArrInputs: TArr_VarRec; const AIdModelApplication: Integer; const AIdObjectType: Integer; const AObject: TS_Object); overload; virtual; stdcall; abstract;
    procedure InitializeModelApplicationsInputs(var AArrInputs: TArr_VarRec; const AIdModelApplication: Integer; const AIdObjectType: Integer; const AOlObject: TObjectList); overload; virtual; stdcall; abstract;
    function ObjectDependencyToStr(const AObjectDependency: TObjectDependency): string; virtual; stdcall; abstract;
    function List: TObjectList; virtual; stdcall; abstract;
    ///<summary>Function creating and returning the list of loaded Applications Models using a given Model.</summary>
    ///<param name="AIdModel">The identifier of the Model.</param>
    function FilterOnModel_(const AIdModel: Integer): TObjectList; virtual; stdcall; abstract;
    ///<summary>function creating a filtered TObjectList of TMA_Model_Application.</summary>
    ///<param name="AEvent">the filtering event.</param>
    ///<param name="AIdObjectType">the Object Type of the Model Application.</param>
    ///<param name="AArrIdAttribute">if different from 0, the model application must contain at least of the attributes.</param>
    ///<param name="AReadWriteMode">the read/write mode to filter on.</param>
    ///<param name="AObjectsAreSelected">Indicates if objects are selected or not.</param>
    function FilterOnEvent_(const AEvent: TMAEvent; const AIdObjectType: Integer; const AArrIdAttribute: array of Integer; const AReadWriteMode: TReadWriteMode=rwmUndefined; const AObjectsAreSelected: Boolean=False): TObjectList; virtual; stdcall; abstract;
    ///<summary>Function executing Models applications on a given event and returning a "command line" string.</summary>
    ///<param name="AEvent">The event.</param>
    ///<param name="AIdObject">The identifier of the selected object.</param>
    ///<param name="AIdObjectType">The identifier of the selected object type.</param>
    ///<param name="AArrIdAttribute">The list of Attributes identifiers triggering the models applications.</param>
    ///<param name="AReadWriteMode">The read or write mode. This context's parameter may influence the list of models applications triggered.</param>
    function Execute(const AEvent: TMAEvent; const AIdObjectType: Integer; const AIdObject: Integer; const AArrIdAttribute: array of Integer; AReadWriteMode: TReadWriteMode=rwmUndefined): string; overload; virtual; stdcall; abstract;
    ///<summary>Function executing the first part of a Model application of type "On Object Checked".</summary>
    ///<param name="AIdModelApplication">The identifier of the model application.</param>
    ///<param name="AIdObject">The identifier of the selected object.</param>
    ///<param name="AIdsCheckedObjects">A string list of the identifiers of the checked objects, separated by #13#10.</param>
    ///<returns>The function returns a boolean indicating if the hidden groups contain data.</returns>
    function HandleDynamicGroupsStep1(AIdModelApplication: Integer; AIdObject: Integer; AIdsCheckedObjects: string): Boolean; virtual; stdcall; abstract;
    ///<summary>Function executing the second part of a Model application of type "On Object Checked".</summary>
    ///<summary>It returns the list of visible group attributes, separated by #13#10.</summary>
    ///<param name="AIdModelApplication">The identifier of the model application.</param>
    ///<param name="AIdObject">The idntifier of the selected object.</param>
    ///<param name="AIdsCheckedObjects">A string list of the identifiers of the checked objects, separated by #13#10.</param>
    ///<param name="ADeleteData">If true, the data inside hidden groups will be deleted.</param>
    function HandleDynamicGroupsStep2(AIdModelApplication: Integer; AIdObject: Integer; AIdsCheckedObjects: string; ADeleteData: Boolean): string; virtual; stdcall; abstract;
  end;

  TModelApplicationHelper=class(TObject)
  public
    function Advanced: TModelApplicationAdvancedHelper; virtual; stdcall; abstract;
    ///<summary>Function executing a Model application and returning a "command line" string.</summary>
    ///<param name="AIdModelApplication">The identifier of the Model's Application.</param>
    ///<param name="AIdObject">The identifier of the selected Object.</param>
    ///<param name="AIdObjectType">The identifier of the selected Object Type.</param>
    function Execute(const AIdModelApplication: Integer; const AIdObject: Integer=0; const AIdObjectType: Integer=0): string; overload; virtual; stdcall; abstract;
    ///<summary>Function executing a Model application and returning a "command line" string.</summary>
    ///<param name="AIdModelApplication">The identifier of the Model's Application.</param>
    ///<param name="AObject">The object.</param>
    ///<param name="AIdObjectType">The identifier of the selected Object Type.</param>
    function Execute(const AIdModelApplication: Integer; const AObject: TS_Object; const AIdObjectType: Integer=0): string; overload; virtual; stdcall; abstract;
    ///<summary>Function executing a Model application on a given list of objects (one execution for many objects) and returning a "command line" string.</summary>
    ///<param name="AIdModelApplication">The identifier of the Model's Application.</param>
    ///<param name="AArrIdObject">The list of objects to send to the model application.</param>
    ///<param name="AIdObjectType">The identifier of the selected Object Type.</param>
    function Execute(const AIdModelApplication: Integer; const AArrIdObject: array of Integer; const AIdObjectType: Integer=0): string; overload; virtual; stdcall; abstract;
    ///<summary>Function executing a Model application on a given list of objects (one execution for many objects) and returning a "command line" string.</summary>
    ///<param name="AIdModelApplication">The identifier of the Model's Application.</param>
    ///<param name="ASlIdObject">The list of objects to send to the model application.</param>
    ///<param name="AIdObjectType">The identifier of the selected Object Type.</param>
    function Execute(const AIdModelApplication: Integer; const ASlIdObject: TStringList; const AIdObjectType: Integer=0): string; overload; virtual; stdcall; abstract;
    ///<summary>Function executing a Model application on a given list of objects (one execution for many objects) and returning a "command line" string.</summary>
    ///<param name="AIdModelApplication">The identifier of the Model's Application.</param>
    ///<param name="AOlObject">The list of objects to send to the model application.</param>
    ///<param name="AIdObjectType">The identifier of the selected Object Type.</param>
    function Execute(const AIdModelApplication: Integer; const AOlObject: TObjectList; const AIdObjectType: Integer=0): string; overload; virtual; stdcall; abstract;
    ///<summary>Function returning a model application thanks to its identifier.</summary>
    ///<param name="AIdModelApplication">The identifier of the Model Application.</param>
    ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
    function Get(const AIdModelApplication: Integer; const ARaiseException: Boolean=True): TMA_Model_Application; overload; virtual; stdcall; abstract;
    ///<summary>Function returning a tagged Models Application.</summary>
    ///<param name="ATag">The tag of the Models Application.</param>
    ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
    function Get(const ATag: string; const ARaiseException: Boolean=True): TMA_Model_Application; overload; virtual; stdcall; abstract;
    ///<summary>Function returning the name of a given Model Application.</summary>
    ///<param name="AIdModelApplication">The identifier of the Model Application.</param>
    ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
    function GetName(const AIdModelApplication: Integer; const ARaiseException: Boolean=True): string; virtual; stdcall; abstract;
    ///<summary>Function returning the identifier of a tagged Models Application.</summary>
    ///<param name="ATag">The tag of the Models Application.</param>
    ///<param name="ARaiseException">If true, the function raises an error if no object could be found.</param>
    function TagToId(const ATag: string; const ARaiseException: Boolean=True): Integer; virtual; stdcall; abstract;
  end;

  T_ModelApplication=function: TModelApplicationHelper; stdcall;

  T_Model=function: TModelHelper; stdcall;

  ///<summary>Function returning the name of a given Requirement List.</summary>
  ///<param name="AIdModelApplication">The identifier of the Requirement List.</param>
  ///<param name="ARaiseException">If true, an error is raised if the identifier doest not correspond to any existing Requirements List.</param>
  TGetModelApplicationName=function(const AIdModelApplication: Integer; const ARaiseException: Boolean=True): string; stdcall;

  ///<summary>Function returning the name of a given Model Application.</summary>
  ///<param name="AIdModel">The identifier of the Model.</param>
  ///<param name="ARaiseException">If true, the function raises an EIDObjNotFound error if no object could be found.</param>
  TGetModelName=function(const AIdModel: Integer; const ARaiseException: Boolean=True): string; stdcall;
  {$ENDREGION}



var
  {$REGION 'U_Root_Classes'}
  Set_Expert_Mode: TSet_Expert_Mode;
  Get_Expert_Mode: TGet_Expert_Mode;
  Create_IDObjFromQuery: TCreate_IDObjFromQuery;
  Create_TreeObj: TCreate_TreeObj;
  Create_NamedObj: TCreate_NamedObj;
  IndexOfIDObj: TIndexOfIDObj;
  IndexOfIDObjExt: TIndexOfIDObjExt;
  Get_IDObj: TGet_IDObj;
  Get_IDObjExt: TGet_IDObjExt;
  IndexOf_Ordered_Object: TIndexOf_Ordered_Object;
  Get_Ordered_Object: TGet_Ordered_Object;
  IndexOf_Named_Object: TIndexOf_Named_Object;
  IndexOf_Child: TIndexOf_Child;
  Get_Obj_Child: TGet_Obj_Child;
  Get_Object_Parent: TGet_Object_Parent;
  Get_Named_Object: TGet_Named_Object;
  IndexOfIDObj_In_SL: TIndexOfIDObj_In_SL;
  Create_SL_From_OL: TCreate_SL_From_OL;
  OLIDObjToIDs: TOLIDObjToIDs;
  Create_CoupledObj: TCreate_CoupledObj;
  Create_OL_Filtered_From_Parent: TCreate_OL_Filtered_From_Parent;
  Clear_OLIDObj: TClear_OLIDObj;
  Remove_IDObj: TRemove_IDObj;
  IsOLIDObjModified: TIsOLIDObjModified;
  Add_IDObjs: TAdd_IDObjs;
  Create_IDObjFromClassName: TCreate_IDObjFromClassName;
  Create_IDObj: TCreate_IDObj;
  Create_IDObjFromXMLNode: TCreate_IDObjFromXMLNode;
  TDToClassName: TTDToClassName;
  TDToStr: TTDToStr;
  Get_IDObjName: TGet_IDObjName;
  Get_IDObjNameExt: TGet_IDObjNameExt;
  OlToJSONArray: TOlToJSONArray;
  OlToJSON: TOlToJSON;
  FillJSONArray: TFillJSONArray;
  {$ENDREGION}

  {$REGION 'U_Misc'}
  ClassNameToTable: TClassNameToTable;
  Sort_OL: TSort_OL;
  {$ENDREGION}

  {$REGION 'U_Action'}
  Create_MD_Action: TCreate_MD_Action;
  LATToStr: TLATToStr;
  LACToStr: TLACToStr;
  {$ENDREGION}

  {$REGION 'U_DB_Log'}
  Create_Log: TCreate_Log;
  {$ENDREGION}

  {$REGION 'U_Attribute'}
  Create_Attribute: TCreate_Attribute;
  Delete_Attribute: TDelete_Attribute;
  {$ENDREGION}

  {$REGION 'U_Object_Type'}
  Create_Object_Type: TCreate_Object_Type;
  {$ENDREGION}

  {$REGION 'U_Object_Data'}
  Create_Object_Data: TCreate_Object_Data;
  Update_OL_Object_Data: TUpdate_OL_Object_Data;
  {$ENDREGION}

  {$REGION 'U_Path'}
  Create_OL_Path: TCreate_OL_Path;
  Create_Path: TCreate_Path;
  Create_Path_From_IDs: TCreate_Path_From_IDs;
  {$ENDREGION}

  {$REGION 'U_Structure'}
  Set_Object_Folder: TSet_Object_Folder;
  GetObjectRight: TGetObjectRight;
  Get_Object_Deepness: TGet_Object_Deepness;
  Get_Object_Hint: TGet_Object_Hint;
  Get_Object_ID_OT: TGet_Object_ID_OT;
  Get_ID_Object_From_Name: TGet_ID_Object_From_Name;
  Get_Object_Nb_Children: TGet_Object_Nb_Children;
  Create_OL_Object: TCreate_OL_Object;
  Create_OL_Object_Link_Form: TCreate_OL_Object_Link_Form;
  Get_Parent_Inheritage: TGet_Parent_Inheritage;
  Create_OL_Object_Tree_Sorted_From_SL_ID: TCreate_OL_Object_Tree_Sorted_From_SL_ID;
  Create_OL_Object_Tree_Sorted: TCreate_OL_Object_Tree_Sorted;
  Create_SL_ID_Object: TCreate_SL_ID_Object;
  Create_OL_Object_From_Preselection: TCreate_OL_Object_From_Preselection;
  Create_OL_Object_Link_Form_Filtered: TCreate_OL_Object_Link_Form_Filtered;
  Get_Object_ID_Parent: TGet_Object_ID_Parent;
  Create_Object_In_DB: TCreate_Object_In_DB;
  Sort_Objects_in_DB: TSort_Objects_in_DB;
  Move_Object: TMove_Object;
  Initialize_Standard_Duplication: TInitialize_Standard_Duplication;
  Fill_Object_From_Advanced_Creation_Settings: TFill_Object_From_Advanced_Creation_Settings;
  Fill_Object_From_Duplication_Settings: TFill_Object_From_Duplication_Settings;
  Create_Object_From_Duplication_Settings: TCreate_Object_From_Duplication_Settings;
  Create_Object_Duplicated: TCreate_Object_Duplicated;
  Get_Object_Icon: TGet_Object_Icon;
  Get_Object_Name_Extended: TGet_Object_Name_Extended;
  Get_Object_Name: TGet_Object_Name;
  Restore_Object: TRestore_Object;
  Empty_Trash: TEmpty_Trash;
  Create_SL_ID_Object_From_Names: TCreate_SL_ID_Object_From_Names;
  Delete_Objects: TDelete_Objects;
  Delete_Objects_From_Deletion_Settings: TDelete_Objects_From_Deletion_Settings;
  Delete_Object: TDelete_Object;
  AttributeTypeToShortCodedStr: TAttributeTypeToShortCodedStr;
  AttributeTypeToStr: TAttributeTypeToStr;
  Get_AttributeTypeLabel: TGet_AttributeTypeLabel;
  Get_Object_Folder: TGet_Object_Folder;
  Create_SL_ID_Object_Without_Data: TCreate_SL_ID_Object_Without_Data;
  HasObjectData: THasObjectData;
  Check_Object_Existence: TCheck_Object_Existence;
  Creer_Instance_Erreur_Parente_Modifiee: TCreer_Instance_Erreur_Parente_Modifiee;
  Get_Object_sPath: TGet_Object_sPath;
  Create_OL_Object_From_Table: TCreate_OL_Object_From_Table;
  Check_Object_ExistenceExt: TCheck_Object_ExistenceExt;
  Write_New_Object: TWrite_New_Object;
  Rename_Object: TRename_Object;
  {$ENDREGION}

  {$REGION 'U_Attribute_Set_Level'}
  Create_Attribute_Set_Level: TCreate_Attribute_Set_Level;
  {$ENDREGION}

  {$REGION 'U_Attribute_Set'}
  Create_Attribute_Set: TCreate_Attribute_Set;
  {$ENDREGION}

  {$REGION 'U_Business_View'}
  Create_OL_Duplication_Settings_Filtered: TCreate_OL_Duplication_Settings_Filtered;
  Create_OL_Deletion_Settings_Filtered: TCreate_OL_Deletion_Settings_Filtered;
  Create_OL_Advanced_Creation_Settings_Filtered: TCreate_OL_Advanced_Creation_Settings_Filtered;
  Create_OL_Attribute_For_Advanced_Duplication: TCreate_OL_Attribute_For_Advanced_Duplication;
  Create_OL_Advanced_Comparison_Settings_Filtered: TCreate_OL_Advanced_Comparison_Settings_Filtered;
  Get_Default_Advanced_Comparison_Settings: TGet_Default_Advanced_Comparison_Settings;
  Create_OL_Attribute_For_Advanced_Creation: TCreate_OL_Attribute_For_Advanced_Creation;
  Create_OL_Attribute_For_Advanced_Comparison: TCreate_OL_Attribute_For_Advanced_Comparison;
  {$ENDREGION}

  {$REGION 'U_Link_Type'}
  Create_Link_Type: TCreate_Link_Type;
  {$ENDREGION}

  {$REGION 'U_Data_Date'}
  Create_Data_Date: TCreate_Data_Date;
  {$ENDREGION}

  {$REGION 'U_Data_String'}
  Create_Data_String: TCreate_Data_String;
  {$ENDREGION}

  {$REGION 'U_Data_Text'}
  Create_Data_Text: TCreate_Data_Text;
  {$ENDREGION}

  {$REGION 'U_Data_URL'}
  Create_Data_URL: TCreate_Data_URL;
  {$ENDREGION}

  {$REGION 'U_Data_Boolean'}
  Create_Data_Boolean: TCreate_Data_Boolean;
  {$ENDREGION}

  {$REGION 'U_Data_Decimal'}
  Create_Data_Decimal: TCreate_Data_Decimal;
  {$ENDREGION}

  {$REGION 'U_Data_File'}
  Create_Data_File: TCreate_Data_File;
  {$ENDREGION}

  {$REGION 'U_Data_Table_Value'}
  Create_Table_Value: TCreate_Table_Value;
  {$ENDREGION}

  {$REGION 'U_Data_Table'}
  Create_Data_Table: TCreate_Data_Table;
  {$ENDREGION}

  {$REGION 'U_Data_Link'}
  Create_Data_Link: TCreate_Data_Link;
  {$ENDREGION}

  {$REGION 'U_Object_Associative'}
  Create_Object_Associative: TCreate_Object_Associative;
  {$ENDREGION}

  {$REGION 'U_Data_Link_Ass'}
  Create_Data_Link_Ass: TCreate_Data_Link_Ass;
  {$ENDREGION}

  {$REGION 'U_Data'}
  Create_Data_From_String: TCreate_Data_From_String;
  Create_Data_From_TD: TCreate_Data_From_TD;
  Create_Data: TCreate_Data;
  Create_Data_Numerical: TCreate_Data_Numerical;
  Create_Series: TCreate_Series;
  DecToStrF_From_Attribute: TDecToStrF_From_Attribute;
  Create_OL_Data_From_Object: TCreate_OL_Data_From_Object;
  Create_OL_Data_From_Attribute: TCreate_OL_Data_From_Attribute;
  Create_OL_Data: TCreate_OL_Data;
  Get_Data: TGet_Data;
  FillOlFilteredData: TFillOlFilteredData;
  Create_OL_Data_Filtered: TCreate_OL_Data_Filtered;
  Export_Multiple_Data_Table_To_File: TExport_Multiple_Data_Table_To_File;
  Export_Data_Table_To_File: TExport_Data_Table_To_File;
  Get_Object_Associative: TGet_Object_Associative;
  Get_NumericalData_fValue: TGet_NumericalData_fValue;
  Get_Data_fValue: TGet_Data_fValue;
  Get_Data_bValue: TGet_Data_bValue;
  Get_Data_sValue: TGet_Data_sValue;
  Get_Data_ID_Object_Linked: TGet_Data_ID_Object_Linked;
  Get_Data_OL_Object_Linked: TGet_Data_OL_Object_Linked;
  Get_Data_SL_ID_Object_Linked: TGet_Data_SL_ID_Object_Linked;
  Get_Data_Object_Linked: TGet_Data_Object_Linked;
  Write_Single_Data: TWrite_Single_Data;
  Write_Data_Link: TWrite_Data_Link;
  Write_Data_Boolean: TWrite_Data_Boolean;
  Write_Data_Numerical: TWrite_Data_Numerical;
  Write_Data_String: TWrite_Data_String;
  Write_Data_File: TWrite_Data_File;
  Write_Data: TWrite_Data;
  Read_Data_Link: TRead_Data_Link;
  Read_Data_Link_Single_ID_Object: TRead_Data_Link_Single_ID_Object;
  Read_Data_Boolean: TRead_Data_Boolean;
  Read_Data_Numerical: TRead_Data_Numerical;
  Read_Data_String: TRead_Data_String;
  Read_Data_Table: TRead_Data_Table;
  Read_Data_File: TRead_Data_File;
  Read_Data_Filename: TRead_Data_Filename;
  Extract_Data_Table_Graphics: TExtract_Data_Table_Graphics;
  Delete_Data: TDelete_Data;
  Create_OL_Archived_File: TCreate_OL_Archived_File;
  Create_Archived_File: TCreate_Archived_File;
  Extract_Data_File_File: TExtract_Data_File_File;
  Extract_Archived_File_File: TExtract_Archived_File_File;
  Get_ID_Archived_File_From_Filename: TGet_ID_Archived_File_From_Filename;
  Create_Data_File_For_Publication: TCreate_Data_File_For_Publication;
  Initialize_New_Document_Model: TInitialize_New_Document_Model;
  Check_Document_With_Template_Gestion: TCheck_Document_With_Template_Gestion;
  Initialize_New_Document: TInitialize_New_Document;
  Create_Document_Versionned_In_DB: TCreate_Document_Versionned_In_DB;
  Pass_Document_As_Reference: TPass_Document_As_Reference;
  {$ENDREGION}

  {$REGION 'U_Right'}
  Create_Right: TCreate_Right;
  Modify_Object_Rights: TModify_Object_Rights;
  Get_User_Default_Right_On_New_Object: TGet_User_Default_Right_On_New_Object;
  GetActiveUserRightOnObject: TGetActiveUserRightOnObject;
  {$ENDREGION}

  {$REGION 'U_LObject'}
  Create_LObject: TCreate_LObject;
  {$ENDREGION}

  {$REGION 'U_Users_Group_User'}
  Create_Users_Group_User2: TCreate_Users_Group_User2;
  Create_Users_Group_User: TCreate_Users_Group_User;
  {$ENDREGION}

  {$REGION 'U_User'}
  Create_User: TCreate_User;
  Create_OL_User: TCreate_OL_User;
  {$ENDREGION}

  {$REGION 'U_Users_Group'}
  Create_Users_Group: TCreate_Users_Group;
  {$ENDREGION}

  {$REGION 'U_Users_Manager'}
  CreateOlSpecificUsersGroup: TCreateOlSpecificUsersGroup;
  Load_Users_Groups: TLoad_Users_Groups;
  Test_Binding_Between_User_And_Users_Group: TTest_Binding_Between_User_And_Users_Group;
  Get_Generated_Password: TGet_Generated_Password;
  Check_Password_Policy: TCheck_Password_Policy;
  Get_User_Expiration_Date: TGet_User_Expiration_Date;
  Get_User_Duration_Password_Validity: TGet_User_Duration_Password_Validity;
  Get_User_Password_Last_Change_Date: TGet_User_Password_Last_Change_Date;
  Get_User_Name: TGet_User_Name;
  Get_User_Nb_UG: TGet_User_Nb_UG;
  Get_ID_User_From_ID_Object: TGet_ID_User_From_ID_Object;
  Get_User_ID_Object: TGet_User_ID_Object;
  Get_ID_User_From_Login: TGet_ID_User_From_Login;
  Get_ID_User_From_Name: TGet_ID_User_From_Name;
  Get_User_Login: TGet_User_Login;
  Get_User_Login_From_Name: TGet_User_Login_From_Name;
  Get_User_Date_Last_Connection: TGet_User_Date_Last_Connection;
  Get_ID_Users_Group_From_Login: TGet_ID_Users_Group_From_Login;
  Get_ID_Users_Group_From_Name: TGet_ID_Users_Group_From_Name;
  Write_New_Users_Group: TWrite_New_Users_Group;
  Get_Unique_Login: TGet_Unique_Login;
  Get_Unique_Users_Group_Name: TGet_Unique_Users_Group_Name;
  Get_ID_Users_Group_From_User: TGet_ID_Users_Group_From_User;
  Add_User_To_Users_Group: TAdd_User_To_Users_Group;
  Remove_User_From_Users_Group: TRemove_User_From_Users_Group;
  Write_New_UserExt: TWrite_New_UserExt;
  Write_New_User: TWrite_New_User;
  Update_Users_Group_Object_Right: TUpdate_Users_Group_Object_Right;
  Remove_Users_Specific_Rights_On_Object: TRemove_Users_Specific_Rights_On_Object;
  Get_OL_Users_Group: TGet_OL_Users_Group;
  Get_User_Password: TGet_User_Password;
  Update_User_Password: TUpdate_User_Password;
  Get_User_Icon: TGet_User_Icon;
  Get_Users_Group: TGet_Users_Group;
  Get_Users_Group_Name: TGet_Users_Group_Name;
  Remove_Object_Specific_Rights: TRemove_Object_Specific_Rights;
  Remove_Object_Standard_Rights: TRemove_Object_Standard_Rights;
  RemoveUnrelevantUsersGroups: TRemoveUnrelevantUsersGroups;
  {$ENDREGION}

  {$REGION 'U_Unit'}
  Create_Conversion: TCreate_Conversion;
  Create_Unit: TCreate_Unit;
  {$ENDREGION}

  {$REGION 'U_File_Type'}
  Create_File_Type: TCreate_File_Type;
  CheckIf_File_Type_Deletable: TCheckIf_File_Type_Deletable;
  Get_File_Type_Nb_Archived_Files: TGet_File_Type_Nb_Archived_Files;
  {$ENDREGION}

  {$REGION 'U_Table_Type'}
  Create_Table_Type: TCreate_Table_Type;
  {$ENDREGION}

  {$REGION 'U_Series_Type'}
  Create_Series_Type: TCreate_Series_Type;
  {$ENDREGION}

  {$REGION 'U_Criterion'}
  Create_Criterion: TCreate_Criterion;
  Delete_Criterion: TDelete_Criterion;
  Get_Criterion: TGet_Criterion;
  {$ENDREGION}

  {$REGION 'U_Requirement_List'}
  Delete_Requirement_List: TDelete_Requirement_List;
  {$ENDREGION}

  {$REGION 'U_MCS'}
  Create_OL_Comparable_Attribute: TCreate_OL_Comparable_Attribute;
  Get_Criterion_From_Kinship_and_Attribute: TGet_Criterion_From_Kinship_and_Attribute;
  {$ENDREGION}

  {$REGION 'U_Extraction'}
  Create_Extraction: TCreate_Extraction;
  {$ENDREGION}

  {$REGION 'U_Bookmark'}
  Create_Bookmark: TCreate_Bookmark;
  {$ENDREGION}

  {$REGION 'U_Statistics'}
  Update_OL_Statistics_And_Correlation: TUpdate_OL_Statistics_And_Correlation;
  {$ENDREGION}

  {$REGION 'U_Evaluation'}
  Create_Evaluation: TCreate_Evaluation;
  {$ENDREGION}

  {$REGION 'U_Translation_Object_Type'}
  Create_Translation_Object_Type: TCreate_Translation_Object_Type;
  {$ENDREGION}

  {$REGION 'U_XML'}
  Create_Object_From_XML: TCreate_Object_From_XML;
  Create_Object_From_XML_File: TCreate_Object_From_XML_File;
  Fill_XML_From_OL: TFill_XML_From_OL;
  OLToXML: TOLToXML;
  {$ENDREGION}

  {$REGION 'U_Choice_Guide'}
  Get_Choice_Guide_Default_RL_Name: TGet_Choice_Guide_Default_RL_Name;
  Create_Choice_Guide: TCreate_Choice_Guide;
  {$ENDREGION}

  {$REGION 'U_Answer'}
  Create_Answer: TCreate_Answer;
  {$ENDREGION}

  {$REGION 'U_Answers'}
  Create_Answers2: TCreate_Answers2;
  Create_Answers_From_File: TCreate_Answers_From_File;
  Create_Answers: TCreate_Answers;
  {$ENDREGION}

  {$REGION 'U_Question'}
  Get_Question_Type_Name: TGet_Question_Type_Name;
  Create_Question: TCreate_Question;
  {$ENDREGION}

  {$REGION 'U_VACBOA'}
  Create_VACBOA: TCreate_VACBOA;
  {$ENDREGION}

  {$REGION 'U_Source'}
  Create_OL_Source: TCreate_OL_Source;
  Create_OL_Source_From_Object: TCreate_OL_Source_From_Object;
  Create_Source: TCreate_Source;
  Get_Source: TGet_Source;
  Get_Source_OL_Data: TGet_Source_OL_Data;
  Create_OL_Source_Filtered: TCreate_OL_Source_Filtered;
  {$ENDREGION}

  {$REGION 'U_Information'}
  Get_Information: TGet_Information;
  Create_OL_Information_From_Tab: TCreate_OL_Information_From_Tab;
  Create_OL_Information: TCreate_OL_Information;
  Create_Information: TCreate_Information;
  {$ENDREGION}

  {$REGION 'U_MCS_Algorithm'}
  Create_MCS_Mark: TCreate_MCS_Mark;
  Create_SL_ID_Object_From_bValue: TCreate_SL_ID_Object_From_bValue;
  Create_SL_ID_Object_From_sValue: TCreate_SL_ID_Object_From_sValue;
  Create_SL_ID_Object_From_fValue: TCreate_SL_ID_Object_From_fValue;
  Create_SL_ID_Object_From_Range_Value: TCreate_SL_ID_Object_From_Range_Value;
  Create_SL_ID_Object_From_Linked_Object: TCreate_SL_ID_Object_From_Linked_Object;
  Get_ID_Object_From_sValue: TGet_ID_Object_From_sValue;
  Get_ID_Object_From_fValue: TGet_ID_Object_From_fValue;
  Get_ID_Object_From_bValue: TGet_ID_Object_From_bValue;
  Get_ID_Object_From_Range_Value: TGet_ID_Object_From_Range_Value;
  Get_ID_Object_From_Linked_Object: TGet_ID_Object_From_Linked_Object;
  {$ENDREGION}

  {$REGION 'U_Mark_Criterion'}
  Create_MCS_Mark_Criterion: TCreate_MCS_Mark_Criterion;
  {$ENDREGION}

  {$REGION 'U_Mark_Object'}
  Create_MCS_Mark_Object: TCreate_MCS_Mark_Object;
  {$ENDREGION}

  {$REGION 'U_Results'}
  Create_MCS_Results: TCreate_MCS_Results;
  {$ENDREGION}

  {$REGION 'U_Structure_Multilingualism'}
  Create_Language: TCreate_Language;
  {$ENDREGION}

  {$REGION 'U_Language_Manager'}
  _Path: T_Path;
  Get_OL_Language: TGet_OL_Language;
  Get_Language: TGet_Language;
  Get_Active_Language: TGet_Active_Language;
  Get_Active_Language_Code: TGet_Active_Language_Code;
  Get_Active_Language_ID: TGet_Active_Language_ID;
  Set_Active_Language: TSet_Active_Language;
  Get_Language_Name: TGet_Language_Name;
  {$ENDREGION}

  {$REGION 'U_IO'}
  Create_IO: TCreate_IO;
  {$ENDREGION}

  {$REGION 'U_Model'}
  Create_Model: TCreate_Model;
  {$ENDREGION}

  {$REGION 'U_iEquivalence'}
  Create_Eq_iEquivalence: TCreate_Eq_iEquivalence;
  Get_iEquivalence_From_Right: TGet_iEquivalence_From_Right;
  Get_iEquivalence_From_Left: TGet_iEquivalence_From_Left;
  {$ENDREGION}

  {$REGION 'U_sEquivalence'}
  Create_Eq_sEquivalence: TCreate_Eq_sEquivalence;
  Get_sEquivalence_From_Right: TGet_sEquivalence_From_Right;
  {$ENDREGION}

  {$REGION 'U_Eq_Attribute_ID'}
  Create_Eq_Attribute_ID: TCreate_Eq_Attribute_ID;
  {$ENDREGION}

  {$REGION 'U_Eq_Attribute_sID'}
  Create_Eq_Attribute_sID: TCreate_Eq_Attribute_sID;
  {$ENDREGION}

  {$REGION 'U_Eq_Object_Attribute'}
  Create_Eq_Object_Attribute: TCreate_Eq_Object_Attribute;
  {$ENDREGION}

  {$REGION 'U_Eq_Object_ID'}
  Create_Eq_Object_ID: TCreate_Eq_Object_ID;
  {$ENDREGION}

  {$REGION 'U_Eq_Object_sID'}
  Create_Eq_Object_sID: TCreate_Eq_Object_sID;
  {$ENDREGION}

  {$REGION 'U_Applied_IO'}
  Create_Applied_IO: TCreate_Applied_IO;
  {$ENDREGION}

  {$REGION 'U_Model_Application'}
  Create_Model_Application: TCreate_Model_Application;
  {$ENDREGION}

  {$REGION 'U_Exportation'}
  ExportationTypeToStr: TExportationTypeToStr;
  Create_Exportation: TCreate_Exportation;
  {$ENDREGION}

  {$REGION 'U_Connection_Settings'}
  Create_Connection_Settings: TCreate_Connection_Settings;
  {$ENDREGION}

  {$REGION 'U_TEEXMA_Connection_Settings'}
  Create_TEEXMA_Connection_Settings: TCreate_TEEXMA_Connection_Settings;
  {$ENDREGION}

  {$REGION 'U_CS_LDAP'}
  Create_CS_LDAP: TCreate_CS_LDAP;
  {$ENDREGION}

  {$REGION 'U_Connection'}
  Get_TxAPIConnection: TGet_TxAPIConnection;
  Set_Excel_Retrieve_Results: TSet_Excel_Retrieve_Results;
  Get_Dir_TEEXMA_Temp: TGet_Dir_TEEXMA_Temp;
  Get_Dir_TEEXMA: TGet_Dir_TEEXMA;
  Get_Dir_Administration: TGet_Dir_Administration;
  Get_Path_File_Administration_EXE: TGet_Path_File_Administration_EXE;
  Get_Dir_Archived_Files: TGet_Dir_Archived_Files;
  Get_Dir_Customer_Resources: TGet_Dir_Customer_Resources;
  Get_Dir_Resources: TGet_Dir_Resources;
  Get_Dir_Exportations: TGet_Dir_Exportations;
  Get_Path_File_No_Model_BMP: TGet_Path_File_No_Model_BMP;
  Get_Dir_HTML: TGet_Dir_HTML;
  Get_Dir_Graphs: TGet_Dir_Graphs;
  Get_Dir_Lib_Graphs: TGet_Dir_Lib_Graphs;
  Get_Path_File_Home_HTML: TGet_Path_File_Home_HTML;
  Get_Dir_Pictures: TGet_Dir_Pictures;
  Get_Dir_Pictures_Buttons: TGet_Dir_Pictures_Buttons;
  Get_Dir_Icons: TGet_Dir_Icons;
  Get_Dir_Icons_Web: TGet_Dir_Icons_Web;
  Get_Dir_Icons_Old: TGet_Dir_Icons_Old;
  Get_Dir_Illustrations: TGet_Dir_Illustrations;
  Get_File_Path_Banner_Default_JPG: TGet_File_Path_Banner_Default_JPG;
  Get_Dir_Helps: TGet_Dir_Helps;
  Get_Dir_Extractions: TGet_Dir_Extractions;
  Get_Dir_CR_Translations: TGet_Dir_CR_Translations;
  Get_Path_File_TEEXMA_XSD: TGet_Path_File_TEEXMA_XSD;
  Get_Dir_CR_Extractions: TGet_Dir_CR_Extractions;
  Get_Dir_CR_Graphs: TGet_Dir_CR_Graphs;
  Get_Dir_CR_Models: TGet_Dir_CR_Models;
  Get_Dir_CR_Illustrations: TGet_Dir_CR_Illustrations;
  Get_Dir_CR_HTML: TGet_Dir_CR_HTML;
  Get_Path_File_Folder_HTML: TGet_Path_File_Folder_HTML;
  Get_Dir_CR_Banners: TGet_Dir_CR_Banners;
  Get_Dir_CR_Portals: TGet_Dir_CR_Portals;
  Get_Dir_CR_Icons: TGet_Dir_CR_Icons;
  Get_Dir_CR_Icons_Web: TGet_Dir_CR_Icons_Web;
  Get_Dir_CR_Exportations: TGet_Dir_CR_Exportations;
  Get_Archived_File_Stored_In_DB: TGet_Archived_File_Stored_In_DB;
  Get_TEEXMA_ConnectionString: TGet_TEEXMA_ConnectionString;
  Get_TEEXMA_Archived_File_ConnectionString: TGet_TEEXMA_Archived_File_ConnectionString;
  Get_Authentification_Type: TGet_Authentification_Type;
  Get_Automated_Connection_Type: TGet_Automated_Connection_Type;
  Get_Prohibit_Manual_Connection: TGet_Prohibit_Manual_Connection;
  Get_Strong_Password: TGet_Strong_Password;
  Get_Display_Users_List: TGet_Display_Users_List;
  Get_Path_File_Help_PDF: TGet_Path_File_Help_PDF;
  Get_Name_DB: TGet_Name_DB;
  Get_Server_URL: TGet_Server_URL;
  Get_Logged_With_WSession: TGet_Logged_With_WSession;
  Get_Default_Language_Code: TGet_Default_Language_Code;
  Get_Path_File_Preferences_INI: TGet_Path_File_Preferences_INI;
  Get_TxRevision: TGet_TxRevision;
  Get_DB_Revision: TGet_DB_Revision;
  Get_TxDB_Revision: TGet_TxDB_Revision;
  Set_TxOut_Object: TSet_TxOut_Object;
  Get_TxOut_Object: TGet_TxOut_Object;
  FinalizeTxAPI: TFinalizeTxAPI;
  InitializeTxAPIForExternalDevs: TInitializeTxAPIForExternalDevs;
  Reinit_Connections: TReinit_Connections;
  Add_Allowed_Thread_For_TXAPI_Translation: TAdd_Allowed_Thread_For_TXAPI_Translation;
  InitializeTxAPI: TInitializeTxAPI;
  Get_Data_Numbering_Type: TGet_Data_Numbering_Type;
  Get_List_Ordering_Type: TGet_List_Ordering_Type;
  Get_Banner_Visible_By_Default: TGet_Banner_Visible_By_Default;
  Get_Display_Object_Path_In_Banner: TGet_Display_Object_Path_In_Banner;
  Get_Copy_Resources: TGet_Copy_Resources;
  Get_Date_Format: TGet_Date_Format;
  Get_Date_and_Time_Format: TGet_Date_and_Time_Format;
  Get_Display_Unit_In_Extractions: TGet_Display_Unit_In_Extractions;
  Get_Close_Splashscreen: TGet_Close_Splashscreen;
  Get_Secured_Mode: TGet_Secured_Mode;
  DateToTXStr: TDateToTXStr;
  DateTimeToTXStr: TDateTimeToTXStr;
  Get_Nb_Max_Paths: TGet_Nb_Max_Paths;
  Get_Nb_Max_Links_Displayed: TGet_Nb_Max_Links_Displayed;
  Get_Nb_Max_Data_Displayed: TGet_Nb_Max_Data_Displayed;
  Set_XLS_Models_Displayed: TSet_XLS_Models_Displayed;
  Get_XLS_Models_Displayed: TGet_XLS_Models_Displayed;
  Get_Use_RichText: TGet_Use_RichText;
  Set_Extractions_Displayed: TSet_Extractions_Displayed;
  Get_Extraction_Displayed: TGet_Extraction_Displayed;
  SetForceCriterion_Win_Exportation: TSetForceCriterion_Win_Exportation;
  GetForceCriterion_Win_Exportation: TGetForceCriterion_Win_Exportation;
  TxBeginTrans: TTxBeginTrans;
  TxCommitTrans: TTxCommitTrans;
  TxRollbackTrans: TTxRollbackTrans;
  Extract_Icon: TExtract_Icon;
  Get_IL_OT: TGet_IL_OT;
  Load_Structure: TLoad_Structure;
  Initialize_Structure_Variables: TInitialize_Structure_Variables;
  Get_Structure_Loaded: TGet_Structure_Loaded;
  Get_Trash_Mode: TGet_Trash_Mode;
  GetTxAPIContextOfUse: TGetTxAPIContextOfUse;
  Get_IP_Client: TGet_IP_Client;
  DisconnectActiveUser: TDisconnectActiveUser;
  IsActiveUserAdministrator: TIsActiveUserAdministrator;
  SetActiveUser: TSetActiveUser;
  Get_Active_User_Name: TGet_Active_User_Name;
  Get_Active_User_ID: TGet_Active_User_ID;
  Get_Active_User_Login: TGet_Active_User_Login;
  Get_Active_User_Last_Connection_Date: TGet_Active_User_Last_Connection_Date;
  Get_Active_User_ID_Object: TGet_Active_User_ID_Object;
  Get_Active_User_ID_Users_Group: TGet_Active_User_ID_Users_Group;
  Get_URL_Online_Help: TGet_URL_Online_Help;
  Get_Active_User_Function_Right: TGet_Active_User_Function_Right;
  Get_Active_User_Password: TGet_Active_User_Password;
  Update_Active_User_Password: TUpdate_Active_User_Password;
  Authenticate: TAuthenticate;
  Get_TxStrFieldMaxSize: TGet_TxStrFieldMaxSize;
  Get_Archived_File_DB_Type: TGet_Archived_File_DB_Type;
  Get_Nbre_Licences_Administration: TGet_Nbre_Licences_Administration;
  Get_Nbre_Licences_Modification: TGet_Nbre_Licences_Modification;
  Get_DB_Type: TGet_DB_Type;
  Get_Nbre_Licences_Lecture: TGet_Nbre_Licences_Lecture;
  Get_Licence_Extraction: TGet_Licence_Extraction;
  Get_Licence_FullTextSearch: TGet_Licence_FullTextSearch;
  Get_Licence_Selection: TGet_Licence_Selection;
  Get_Licence_Calculs: TGet_Licence_Calculs;
  Get_Licence_Traitements_Statistiques: TGet_Licence_Traitements_Statistiques;
  Get_Licence_Authentification_Windows: TGet_Licence_Authentification_Windows;
  Get_Licence_API: TGet_Licence_API;
  Get_Licence_Multilinguisme: TGet_Licence_Multilinguisme;
  Get_Path_File_TxWebComponents_DLL: TGet_Path_File_TxWebComponents_DLL;
  Get_Path_File_TxWebForm_DLL: TGet_Path_File_TxWebForm_DLL;
  Get_Path_File_TxWebExportation_DLL: TGet_Path_File_TxWebExportation_DLL;
  Get_Path_File_TxContextVariables_DLL: TGet_Path_File_TxContextVariables_DLL;
  GetTxLogFilePathin_DLL: TGetTxLogFilePathin_DLL;
  Get_TEEXMA_Title: TGet_TEEXMA_Title;
  Get_Administration_Title: TGet_Administration_Title;
  Get_Short_Description: TGet_Short_Description;
  Get_Dir_Win: TGet_Dir_Win;
  Get_Dir_Web: TGet_Dir_Web;
  Get_Dir_WebPictures: TGet_Dir_WebPictures;
  {$ENDREGION}

  {$REGION 'U_Browsing_History'}
  Retrieve_Next_Browsing_History: TRetrieve_Next_Browsing_History;
  Retrieve_Prev_Browsing_History: TRetrieve_Prev_Browsing_History;
  Update_Browsing_History: TUpdate_Browsing_History;
  Check_Next_Browsing_History: TCheck_Next_Browsing_History;
  Check_Prev_Browsing_History: TCheck_Prev_Browsing_History;
  Reset_Browsing_History: TReset_Browsing_History;
  {$ENDREGION}

  {$REGION 'U_Tmp_Table'}
  _TmpTable: T_TmpTable;
  {$ENDREGION}

  {$REGION 'U_Log_TXAPI'}
  Test_TxExcept: TTest_TxExcept;
  GetTxLogFilePath: TGetTxLogFilePath;
  IsTxLogNeeded: TIsTxLogNeeded;
  GetTxLogDir: TGetTxLogDir;
  GetTxLogErrorsDir: TGetTxLogErrorsDir;
  {$ENDREGION}

  {$REGION 'U_Web'}
  IsWeb: TIsWeb;
  Initialize_WEBClient_Settings: TInitialize_WEBClient_Settings;
  Initialize_WEB_Settings: TInitialize_WEB_Settings;
  Get_URL_TEEXMA: TGet_URL_TEEXMA;
  Get_IISApplicationName: TGet_IISApplicationName;
  Get_RUrl_Tmp: TGet_RUrl_Tmp;
  Get_Url_Tmp: TGet_Url_Tmp;
  Get_URL_Web_Interface_Temp: TGet_URL_Web_Interface_Temp;
  Get_User_Session_ID: TGet_User_Session_ID;
  Get_Max_Size_Upload: TGet_Max_Size_Upload;
  {$ENDREGION}

  {$REGION 'U_UTC'}
  TxNow: TTxNow;
  TxUTCToDateTime: TTxUTCToDateTime;
  TxDateTimeToUTC: TTxDateTimeToUTC;
  {$ENDREGION}

  {$REGION 'U_Attribute_Set_Manager'}
  Create_OL_Attribute_Set_Filtered_On_Link_Attribute: TCreate_OL_Attribute_Set_Filtered_On_Link_Attribute;
  Create_OL_Attribute_Set_Filtered: TCreate_OL_Attribute_Set_Filtered;
  Get_Attribute_Set_Level_From_Attribute: TGet_Attribute_Set_Level_From_Attribute;
  Create_OL_Attribute_From_OL_Level: TCreate_OL_Attribute_From_OL_Level;
  Load_Attributes_Sets: TLoad_Attributes_Sets;
  Get_OL_Attribute_Set: TGet_OL_Attribute_Set;
  Get_OL_Duplication_Settings: TGet_OL_Duplication_Settings;
  Get_OL_Deletion_Settings: TGet_OL_Deletion_Settings;
  Get_OL_Advanced_Creation: TGet_OL_Advanced_Creation;
  Get_OL_Advanced_Comparison: TGet_OL_Advanced_Comparison;
  Get_Advanced_Creation_Settings_ID_OT: TGet_Advanced_Creation_Settings_ID_OT;
  Get_Advanced_Comparison_Settings: TGet_Advanced_Comparison_Settings;
  GetDefaultIdAdvancedCreation: TGetDefaultIdAdvancedCreation;
  Check_Attribute_Set_Existence: TCheck_Attribute_Set_Existence;
  Get_Attribute_Set: TGet_Attribute_Set;
  Get_Attribute_Set_Name: TGet_Attribute_Set_Name;
  {$ENDREGION}

  {$REGION 'U_Objects_Manager'}
  Create_Object_Manager: TCreate_Object_Manager;
  {$ENDREGION}

  {$REGION 'U_Importation'}
  Import_XML_File: TImport_XML_File;
  Import_XML_Flow: TImport_XML_Flow;
  {$ENDREGION}

  {$REGION 'U_Data_Manager'}
  Create_Data_Manager: TCreate_Data_Manager;
  {$ENDREGION}

  {$REGION 'U_Extraction_Manager'}
  Get_Extraction_Type_Name: TGet_Extraction_Type_Name;
  Extract_Objects: TExtract_Objects;
  WordDocumentToPDF: TWordDocumentToPDF;
  Check_PDFPrinter_Availability: TCheck_PDFPrinter_Availability;
  Get_OL_Extraction: TGet_OL_Extraction;
  Create_OL_Extraction: TCreate_OL_Extraction;
  Get_Extraction_Name: TGet_Extraction_Name;
  Get_Extraction: TGet_Extraction;
  {$ENDREGION}

  {$REGION 'U_Log_Manager'}
  Create_Log_Manager: TCreate_Log_Manager;
  logAction: TlogAction;
  Get_DBLog_Nb_Actions: TGet_DBLog_Nb_Actions;
  Clean_DBLog: TClean_DBLog;
  Load_DBLogs: TLoad_DBLogs;
  Get_OL_DBLog: TGet_OL_DBLog;
  Initialize_DBLogs: TInitialize_DBLogs;
  Get_DBLog_Name: TGet_DBLog_Name;
  {$ENDREGION}

  {$REGION 'U_Equivalence_Manager'}
  Create_OL_Sub_Equivalence: TCreate_OL_Sub_Equivalence;
  Get_Equivalence_From_Left: TGet_Equivalence_From_Left;
  Get_Equivalence_Set_Name: TGet_Equivalence_Set_Name;
  Get_Equivalence_Set: TGet_Equivalence_Set;
  Check_Equivalence_Set_Existence: TCheck_Equivalence_Set_Existence;
  Create_Equivalence_Set: TCreate_Equivalence_Set;
  Create_OL_Equivalence_Set: TCreate_OL_Equivalence_Set;
  Get_Equivalences_Set_OL_Equivalence: TGet_Equivalences_Set_OL_Equivalence;
  {$ENDREGION}

  {$REGION 'U_Data_File_Functions'}
  Create_Data_File_For_Reference: TCreate_Data_File_For_Reference;
  Get_Data_ID_Archived_File: TGet_Data_ID_Archived_File;
  {$ENDREGION}

  {$REGION 'U_Objects_Functions'}
  Create_Object: TCreate_Object;
  {$ENDREGION}

  {$REGION 'U_Tag_Manager'}
  Reset_TaggedTxConcepts: TReset_TaggedTxConcepts;
  Get_Object_Name_From_Tag: TGet_Object_Name_From_Tag;
  Get_ID_Object_From_Tag: TGet_ID_Object_From_Tag;
  Get_Object_FirstTag: TGet_Object_FirstTag;
  CheckIf_Object_Tagged: TCheckIf_Object_Tagged;
  Get_Attribute_From_Tag: TGet_Attribute_From_Tag;
  Get_ID_Attribute_From_Tag: TGet_ID_Attribute_From_Tag;
  Get_ID_Object_Type_From_Tag: TGet_ID_Object_Type_From_Tag;
  Get_Attribute_Set_From_Tag: TGet_Attribute_Set_From_Tag;
  Get_OT_Tags: TGet_OT_Tags;
  Get_Advanced_Creation_From_Tag: TGet_Advanced_Creation_From_Tag;
  Get_Advanced_Duplication_From_Tag: TGet_Advanced_Duplication_From_Tag;
  Get_Advanced_Comparison_From_Tag: TGet_Advanced_Comparison_From_Tag;
  Get_Advanced_Deletion_From_Tag: TGet_Advanced_Deletion_From_Tag;
  Get_ID_Advanced_Creation_From_Tag: TGet_ID_Advanced_Creation_From_Tag;
  Get_ID_Advanced_Comparison_From_Tag: TGet_ID_Advanced_Comparison_From_Tag;
  Get_ID_Advanced_Duplication_From_Tag: TGet_ID_Advanced_Duplication_From_Tag;
  Get_ID_Advanced_Deletion_From_Tag: TGet_ID_Advanced_Deletion_From_Tag;
  Get_Unit_From_Tag: TGet_Unit_From_Tag;
  Get_Exportation_From_Tag: TGet_Exportation_From_Tag;
  Get_Extraction_From_Tag: TGet_Extraction_From_Tag;
  Get_Object_Type_From_Tag: TGet_Object_Type_From_Tag;
  Get_Table_Type_From_Tag: TGet_Table_Type_From_Tag;
  Get_ID_Table_Type_From_Tag: TGet_ID_Table_Type_From_Tag;
  Get_ID_Unit_From_Tag: TGet_ID_Unit_From_Tag;
  Get_ID_Attribute_Set_From_Tag: TGet_ID_Attribute_Set_From_Tag;
  Get_ID_Exportation_From_Tag: TGet_ID_Exportation_From_Tag;
  Get_ID_Extraction_From_Tag: TGet_ID_Extraction_From_Tag;
  Get_TaggedTxConceptID: TGet_TaggedTxConceptID;
  TagToID: TTagToID;
  Tag_TxConcept: TTag_TxConcept;
  CheckIf_Tag_Available: TCheckIf_Tag_Available;
  Get_ID_Choice_Guide_From_Tag: TGet_ID_Choice_Guide_From_Tag;
  Get_Choice_Guide_From_Tag: TGet_Choice_Guide_From_Tag;
  Get_ID_Series_Type_From_Tag: TGet_ID_Series_Type_From_Tag;
  Get_Series_Type_From_Tag: TGet_Series_Type_From_Tag;
  Get_ID_Users_Group_From_Tag: TGet_ID_Users_Group_From_Tag;
  Get_Users_Group_From_Tag: TGet_Users_Group_From_Tag;
  Get_ID_Equivalences_Set_From_Tag: TGet_ID_Equivalences_Set_From_Tag;
  Get_Equivalences_Set_From_Tag: TGet_Equivalences_Set_From_Tag;
  Get_ID_File_Type_From_Tag: TGet_ID_File_Type_From_Tag;
  Get_File_Type_From_Tag: TGet_File_Type_From_Tag;
  Get_ID_Link_Type_From_Tag: TGet_ID_Link_Type_From_Tag;
  Get_Link_Type_From_Tag: TGet_Link_Type_From_Tag;
  Get_ID_Language_From_Tag: TGet_ID_Language_From_Tag;
  Get_Language_From_Tag: TGet_Language_From_Tag;
  Get_ID_Log_From_Tag: TGet_ID_Log_From_Tag;
  Get_Log_From_Tag: TGet_Log_From_Tag;
  {$ENDREGION}

  {$REGION 'U_Object_Data_Functions'}
  Create_Object_Data_From_Object: TCreate_Object_Data_From_Object;
  Create_Object_Data_From_Tab: TCreate_Object_Data_From_Tab;
  Update_Object_Data: TUpdate_Object_Data;
  Create_Object_Data_From_Attribute_Set: TCreate_Object_Data_From_Attribute_Set;
  Create_OL_Object_Data_From_Path: TCreate_OL_Object_Data_From_Path;
  Create_OL_Object_Data_From_Attribute: TCreate_OL_Object_Data_From_Attribute;
  Sort_OL_Object_Data: TSort_OL_Object_Data;
  Create_OL_Object_Data_From_Attribute_Set: TCreate_OL_Object_Data_From_Attribute_Set;
  {$ENDREGION}

  {$REGION 'U_Lockings_Manager'}
  Prepare_CheckOut: TPrepare_CheckOut;
  CheckOut: TCheckOut;
  Prepare_CheckIn: TPrepare_CheckIn;
  CheckIn: TCheckIn;
  Remove_Unrelevant_Lockings: TRemove_Unrelevant_Lockings;
  CheckIf_Object_Locked: TCheckIf_Object_Locked;
  Locking_TypeToStr: TLocking_TypeToStr;
  Lock_Object: TLock_Object;
  Handle_Automatic_Unlocking: THandle_Automatic_Unlocking;
  Unlock_Object: TUnlock_Object;
  Create_OL_Locking: TCreate_OL_Locking;
  {$ENDREGION}

  {$REGION 'U_Attribute_Filters_Manager'}
  Get_Attribute_Filter: TGet_Attribute_Filter;
  {$ENDREGION}

  {$REGION 'U_SolR'}
  Get_ExternalServersToIndexCount: TGet_ExternalServersToIndexCount;
  Get_OL_ExternalServersToIndex: TGet_OL_ExternalServersToIndex;
  IsTextSearchInFilesActive: TIsTextSearchInFilesActive;
  Get_SolRUrl: TGet_SolRUrl;
  Get_SolRDir: TGet_SolRDir;
  IsTextSearchInExternalServersActive: TIsTextSearchInExternalServersActive;
  Get_UrlSolRForExternalServers: TGet_UrlSolRForExternalServers;
  {$ENDREGION}

  {$REGION 'U_Units_Manager'}
  Convert_Value: TConvert_Value;
  Convert_DValue: TConvert_DValue;
  Create_OL_Conversion_From_Unit: TCreate_OL_Conversion_From_Unit;
  Get_Conversion: TGet_Conversion;
  Get_Unit_Name: TGet_Unit_Name;
  Get_Conversion_Name: TGet_Conversion_Name;
  Get_OL_Unit: TGet_OL_Unit;
  Get_OL_Conversion: TGet_OL_Conversion;
  Get_Unit: TGet_Unit;
  Get_ID_Unit_From_Name: TGet_ID_Unit_From_Name;
  Get_Unit_Nb_Attributes: TGet_Unit_Nb_Attributes;
  {$ENDREGION}

  {$REGION 'U_Files_Types_Manager'}
  Get_OL_File_Type: TGet_OL_File_Type;
  Get_File_Type: TGet_File_Type;
  Get_File_Type_FIT: TGet_File_Type_FIT;
  Get_File_Type_Name: TGet_File_Type_Name;
  Get_File_Type_RDir: TGet_File_Type_RDir;
  Get_File_Type_Read_Only: TGet_File_Type_Read_Only;
  Get_Attribute_File_Type: TGet_Attribute_File_Type;
  Get_File_Type_Nb_Attributes: TGet_File_Type_Nb_Attributes;
  {$ENDREGION}

  {$REGION 'U_Tables_Types_Manager'}
  Get_OL_Table_Type: TGet_OL_Table_Type;
  Get_Series_Type: TGet_Series_Type;
  Get_Series_Type_Name_Complete: TGet_Series_Type_Name_Complete;
  Get_Series_Type_Name: TGet_Series_Type_Name;
  Get_Series_Type_ID_Table_Type: TGet_Series_Type_ID_Table_Type;
  Get_Series_Type_ID_Unit: TGet_Series_Type_ID_Unit;
  Get_Table_Type: TGet_Table_Type;
  Get_Table_Type_OL_Series_Type: TGet_Table_Type_OL_Series_Type;
  Get_Table_Type_Name: TGet_Table_Type_Name;
  Get_Table_Type_Nb_Attributes: TGet_Table_Type_Nb_Attributes;
  {$ENDREGION}

  {$REGION 'U_Objects_Types_Manager'}
  Get_OL_OT: TGet_OL_OT;
  Get_OT_Source: TGet_OT_Source;
  Get_OT_Task: TGet_OT_Task;
  Get_OT_Task_Notification_Type: TGet_OT_Task_Notification_Type;
  Get_OT_Library: TGet_OT_Library;
  Get_OT_Information: TGet_OT_Information;
  Get_OT_Portal: TGet_OT_Portal;
  Get_OT_User: TGet_OT_User;
  Get_OL_OT_Standard: TGet_OL_OT_Standard;
  Get_OL_OT_Standard_Invisible: TGet_OL_OT_Standard_Invisible;
  Get_OL_OT_Standard_Visible: TGet_OL_OT_Standard_Visible;
  Get_OL_OT_Associative: TGet_OL_OT_Associative;
  Get_OL_OT_Listing: TGet_OL_OT_Listing;
  Get_OT_Associativity: TGet_OT_Associativity;
  Get_OT_Locking_Type: TGet_OT_Locking_Type;
  Get_OT_Icon: TGet_OT_Icon;
  Get_OT: TGet_OT;
  Check_OT_Existence: TCheck_OT_Existence;
  Get_ID_OT_Source: TGet_ID_OT_Source;
  Get_ID_OT_Information: TGet_ID_OT_Information;
  Get_ID_OT_User: TGet_ID_OT_User;
  Get_ID_OT_Portal: TGet_ID_OT_Portal;
  Get_ID_OT_Project: TGet_ID_OT_Project;
  Get_ID_OT_Task: TGet_ID_OT_Task;
  Get_ID_OT_Task_Notification_Type: TGet_ID_OT_Task_Notification_Type;
  Get_ID_OT_Library: TGet_ID_OT_Library;
  Get_OT_OL_Tab: TGet_OT_OL_Tab;
  Get_OT_OL_Attribute: TGet_OT_OL_Attribute;
  Get_OT_Nb_Attributes: TGet_OT_Nb_Attributes;
  Get_OT_Right: TGet_OT_Right;
  Get_OT_Type: TGet_OT_Type;
  Get_OT_Hint: TGet_OT_Hint;
  Get_OT_Name: TGet_OT_Name;
  Get_OT_Nb_Objects: TGet_OT_Nb_Objects;
  CheckIf_OT_Extractable: TCheckIf_OT_Extractable;
  Get_OT_Folder: TGet_OT_Folder;
  {$ENDREGION}

  {$REGION 'U_Attributes_Manager'}
  Get_Attribute_Clickability: TGet_Attribute_Clickability;
  Retrieve_Link_Attribute_Informations: TRetrieve_Link_Attribute_Informations;
  Get_Attribute_From_ID_Object_Information: TGet_Attribute_From_ID_Object_Information;
  Get_Attribute: TGet_Attribute;
  CheckIf_Link_Attribute: TCheckIf_Link_Attribute;
  CheckIf_File_Attribute: TCheckIf_File_Attribute;
  CheckIf_Numerical_Attribute: TCheckIf_Numerical_Attribute;
  CheckIf_String_Attribute: TCheckIf_String_Attribute;
  Check_Attribute_Data_Type: TCheck_Attribute_Data_Type;
  Check_Attribute_Existence: TCheck_Attribute_Existence;
  Get_Attribute_TD: TGet_Attribute_TD;
  Get_Attribute_Name: TGet_Attribute_Name;
  Get_Attribute_Hint: TGet_Attribute_Hint;
  Get_Attribute_List: TGet_Attribute_List;
  Get_Attribute_ID_Tab: TGet_Attribute_ID_Tab;
  Get_Attribute_ID_File_Type: TGet_Attribute_ID_File_Type;
  Get_Attribute_ID_Unit: TGet_Attribute_ID_Unit;
  Get_Attribute_ID_Table_Type: TGet_Attribute_ID_Table_Type;
  Get_Attribute_Table_Type: TGet_Attribute_Table_Type;
  Get_Attribute_OL_Series_Type: TGet_Attribute_OL_Series_Type;
  Get_Attribute_ID_OT_Destination: TGet_Attribute_ID_OT_Destination;
  Get_Ass_Attribute_ID_Right_Link_Type: TGet_Ass_Attribute_ID_Right_Link_Type;
  Get_Ass_Attribute_ID_Left_Link_Type: TGet_Ass_Attribute_ID_Left_Link_Type;
  Get_Ass_Attribute_ID_Right_Attribute: TGet_Ass_Attribute_ID_Right_Attribute;
  Get_Ass_Attribute_ID_Left_Attribute: TGet_Ass_Attribute_ID_Left_Attribute;
  Get_Ass_Attribute_ID_OT_Associative: TGet_Ass_Attribute_ID_OT_Associative;
  Get_OL_Associative_Attribute: TGet_OL_Associative_Attribute;
  Get_Ass_Attribute_ID_OT_Left: TGet_Ass_Attribute_ID_OT_Left;
  Get_Ass_Attribute_ID_OT_Right: TGet_Ass_Attribute_ID_OT_Right;
  Get_Attribute_Absolute_Order: TGet_Attribute_Absolute_Order;
  Get_Attribute_ID_Object_Information: TGet_Attribute_ID_Object_Information;
  Get_OL_Attribute_Table_Using_Excel: TGet_OL_Attribute_Table_Using_Excel;
  Get_Attribute_ID_Attribute_Set_Filtering: TGet_Attribute_ID_Attribute_Set_Filtering;
  Get_Attribute_Attribute_Set_Filtering: TGet_Attribute_Attribute_Set_Filtering;
  Get_Attribute_ID_OT_Source: TGet_Attribute_ID_OT_Source;
  Get_Attribute_ID_OT: TGet_Attribute_ID_OT;
  Get_Attribute_ID_LT: TGet_Attribute_ID_LT;
  Get_Attribute_Multiplicity: TGet_Attribute_Multiplicity;
  Get_Attribute_Multiplicity_Inverse_Link: TGet_Attribute_Multiplicity_Inverse_Link;
  Get_Attribute_Inverse: TGet_Attribute_Inverse;
  Get_Attribute_ID_Object_Filtering: TGet_Attribute_ID_Object_Filtering;
  Get_Attribute_Transpose: TGet_Attribute_Transpose;
  Get_Attribute_Inherited: TGet_Attribute_Inherited;
  Get_Attribute_ID_Attribute_Lnk_Inheritage: TGet_Attribute_ID_Attribute_Lnk_Inheritage;
  Get_Attribute_ID_Attribute_Inheritage: TGet_Attribute_ID_Attribute_Inheritage;
  Get_Attribute_Associativity: TGet_Attribute_Associativity;
  Get_OL_Attribute_Complete: TGet_OL_Attribute_Complete;
  Get_Attribute_ID_Parent: TGet_Attribute_ID_Parent;
  Check_Attribute_Object_Type: TCheck_Attribute_Object_Type;
  Get_Attribute_SL_ID_Unit: TGet_Attribute_SL_ID_Unit;
  RetrieveNumericalAttributeValues: TRetrieveNumericalAttributeValues;
  Get_Attribute_Min_Value: TGet_Attribute_Min_Value;
  Get_Attribute_Max_Value: TGet_Attribute_Max_Value;
  Get_Attribute_Nb_Data: TGet_Attribute_Nb_Data;
  Create_OL_Attribute_Filtered: TCreate_OL_Attribute_Filtered;
  {$ENDREGION}

  {$REGION 'U_Links_Types_Manager'}
  Get_Link_Type_Filtering_Type: TGet_Link_Type_Filtering_Type;
  Get_Link_Type_Research_Filtering: TGet_Link_Type_Research_Filtering;
  Get_Link_Type_ID_Direct_Attribute: TGet_Link_Type_ID_Direct_Attribute;
  Get_Link_Type_ID_Inv_Attribute: TGet_Link_Type_ID_Inv_Attribute;
  Get_Link_Type_Direct_Attribute: TGet_Link_Type_Direct_Attribute;
  Get_Link_Type_Inv_Attribute: TGet_Link_Type_Inv_Attribute;
  Get_OL_Link_Type: TGet_OL_Link_Type;
  Get_Link_Type: TGet_Link_Type;
  Get_Link_Type_Name: TGet_Link_Type_Name;
  Get_Link_Type_Associativity: TGet_Link_Type_Associativity;
  {$ENDREGION}

  {$REGION 'U_Choices_Guides_Manager'}
  Initialize_Choice_Guides: TInitialize_Choice_Guides;
  Load_Choice_Guides: TLoad_Choice_Guides;
  Get_Choice_Guide: TGet_Choice_Guide;
  Get_Choice_Guide_Name: TGet_Choice_Guide_Name;
  Get_Question: TGet_Question;
  Get_Question_Name: TGet_Question_Name;
  Get_Choice_Guide_Loaded: TGet_Choice_Guide_Loaded;
  Get_OL_Choice_Guide: TGet_OL_Choice_Guide;
  {$ENDREGION}

  {$REGION 'U_Exportations_Manager'}
  Get_OL_Exportation: TGet_OL_Exportation;
  Get_Exportation: TGet_Exportation;
  Get_Exportation_Name: TGet_Exportation_Name;
  {$ENDREGION}

  {$REGION 'U_RequirementsListHelper'}
  _RequirementsList: T_RequirementsList;
  GetRequirementsListName: TGetRequirementsListName;
  {$ENDREGION}

  {$REGION 'U_BusinessViewHelper'}
  _BusinessView: T_BusinessView;
  _BusinessObject: T_BusinessObject;
  {$ENDREGION}

  {$REGION 'U_ContextStringHelper'}
  _ContextString: T_ContextString;
  {$ENDREGION}

  {$REGION 'U_ContextVariablesHelpers'}
  _Constants: T_Constants;
  _Variables: T_Variables;
  {$ENDREGION}

  {$REGION 'U_ObjectSettingsHelper'}
  _ObjectSettings: T_ObjectSettings;
  {$ENDREGION}

  {$REGION 'U_ModelApplicationHelper'}
  _ModelApplication: T_ModelApplication;
  _Model: T_Model;
  GetModelApplicationName: TGetModelApplicationName;
  GetModelName: TGetModelName;
  {$ENDREGION}


///<summary>Procedure loading the dll named "TxAPI".</summary>
///<param name="AFilePath">The absolute path to the dll.</param>
procedure Load_TxAPI(AFilePath: string);

///<summary>Procedure unloading the dll named "TxAPI".</summary>
procedure Unload_TxAPI;

///<summary>Function returning true if the dll "TxAPI" was loaded.</summary>
function Get_Dll_TxAPI_Loaded: boolean;

implementation

var
  hDll: THandle;

procedure Load_TxAPI(AFilePath: string);
resourcestring
  RS_Error_Invalide_File='Le fichier %s n''est pas valide.';
begin
  if hDll <> 0 then
    exit;

  Check_FileExists(AFilePath);

  hDll := Load_Dll(AFilePath);

  {$REGION 'U_Root_Classes'}
  @Set_Expert_Mode := Get_Dll_Function_Adress(hDll,'Set_Expert_Mode',AFilePath);
  @Get_Expert_Mode := Get_Dll_Function_Adress(hDll,'Get_Expert_Mode',AFilePath);
  @Create_IDObjFromQuery := Get_Dll_Function_Adress(hDll,'Create_IDObjFromQuery',AFilePath);
  @Create_TreeObj := Get_Dll_Function_Adress(hDll,'Create_TreeObj',AFilePath);
  @Create_NamedObj := Get_Dll_Function_Adress(hDll,'Create_NamedObj',AFilePath);
  @IndexOfIDObj := Get_Dll_Function_Adress(hDll,'IndexOfIDObj',AFilePath);
  @IndexOfIDObjExt := Get_Dll_Function_Adress(hDll,'IndexOfIDObjExt',AFilePath);
  @Get_IDObj := Get_Dll_Function_Adress(hDll,'Get_IDObj',AFilePath);
  @Get_IDObjExt := Get_Dll_Function_Adress(hDll,'Get_IDObjExt',AFilePath);
  @IndexOf_Ordered_Object := Get_Dll_Function_Adress(hDll,'IndexOf_Ordered_Object',AFilePath);
  @Get_Ordered_Object := Get_Dll_Function_Adress(hDll,'Get_Ordered_Object',AFilePath);
  @IndexOf_Named_Object := Get_Dll_Function_Adress(hDll,'IndexOf_Named_Object',AFilePath);
  @IndexOf_Child := Get_Dll_Function_Adress(hDll,'IndexOf_Child',AFilePath);
  @Get_Obj_Child := Get_Dll_Function_Adress(hDll,'Get_Obj_Child',AFilePath);
  @Get_Object_Parent := Get_Dll_Function_Adress(hDll,'Get_Object_Parent',AFilePath);
  @Get_Named_Object := Get_Dll_Function_Adress(hDll,'Get_Named_Object',AFilePath);
  @IndexOfIDObj_In_SL := Get_Dll_Function_Adress(hDll,'IndexOfIDObj_In_SL',AFilePath);
  @Create_SL_From_OL := Get_Dll_Function_Adress(hDll,'Create_SL_From_OL',AFilePath);
  @OLIDObjToIDs := Get_Dll_Function_Adress(hDll,'OLIDObjToIDs',AFilePath);
  @Create_CoupledObj := Get_Dll_Function_Adress(hDll,'Create_CoupledObj',AFilePath);
  @Create_OL_Filtered_From_Parent := Get_Dll_Function_Adress(hDll,'Create_OL_Filtered_From_Parent',AFilePath);
  @Clear_OLIDObj := Get_Dll_Function_Adress(hDll,'Clear_OLIDObj',AFilePath);
  @Remove_IDObj := Get_Dll_Function_Adress(hDll,'Remove_IDObj',AFilePath);
  @IsOLIDObjModified := Get_Dll_Function_Adress(hDll,'IsOLIDObjModified',AFilePath);
  @Add_IDObjs := Get_Dll_Function_Adress(hDll,'Add_IDObjs',AFilePath);
  @Create_IDObjFromClassName := Get_Dll_Function_Adress(hDll,'Create_IDObjFromClassName',AFilePath);
  @Create_IDObj := Get_Dll_Function_Adress(hDll,'Create_IDObj',AFilePath);
  @Create_IDObjFromXMLNode := Get_Dll_Function_Adress(hDll,'Create_IDObjFromXMLNode',AFilePath);
  @TDToClassName := Get_Dll_Function_Adress(hDll,'TDToClassName',AFilePath);
  @TDToStr := Get_Dll_Function_Adress(hDll,'TDToStr',AFilePath);
  @Get_IDObjName := Get_Dll_Function_Adress(hDll,'Get_IDObjName',AFilePath);
  @Get_IDObjNameExt := Get_Dll_Function_Adress(hDll,'Get_IDObjNameExt',AFilePath);
  @OlToJSONArray := Get_Dll_Function_Adress(hDll,'OlToJSONArray',AFilePath);
  @OlToJSON := Get_Dll_Function_Adress(hDll,'OlToJSON',AFilePath);
  @FillJSONArray := Get_Dll_Function_Adress(hDll,'FillJSONArray',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Misc'}
  @ClassNameToTable := Get_Dll_Function_Adress(hDll,'ClassNameToTable',AFilePath);
  @Sort_OL := Get_Dll_Function_Adress(hDll,'Sort_OL',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Action'}
  @Create_MD_Action := Get_Dll_Function_Adress(hDll,'Create_MD_Action',AFilePath);
  @LATToStr := Get_Dll_Function_Adress(hDll,'LATToStr',AFilePath);
  @LACToStr := Get_Dll_Function_Adress(hDll,'LACToStr',AFilePath);
  {$ENDREGION}

  {$REGION 'U_DB_Log'}
  @Create_Log := Get_Dll_Function_Adress(hDll,'Create_Log',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Attribute'}
  @Create_Attribute := Get_Dll_Function_Adress(hDll,'Create_Attribute',AFilePath);
  @Delete_Attribute := Get_Dll_Function_Adress(hDll,'Delete_Attribute',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Object_Type'}
  @Create_Object_Type := Get_Dll_Function_Adress(hDll,'Create_Object_Type',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Object_Data'}
  @Create_Object_Data := Get_Dll_Function_Adress(hDll,'Create_Object_Data',AFilePath);
  @Update_OL_Object_Data := Get_Dll_Function_Adress(hDll,'Update_OL_Object_Data',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Path'}
  @Create_OL_Path := Get_Dll_Function_Adress(hDll,'Create_OL_Path',AFilePath);
  @Create_Path := Get_Dll_Function_Adress(hDll,'Create_Path',AFilePath);
  @Create_Path_From_IDs := Get_Dll_Function_Adress(hDll,'Create_Path_From_IDs',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Structure'}
  @Set_Object_Folder := Get_Dll_Function_Adress(hDll,'Set_Object_Folder',AFilePath);
  @GetObjectRight := Get_Dll_Function_Adress(hDll,'GetObjectRight',AFilePath);
  @Get_Object_Deepness := Get_Dll_Function_Adress(hDll,'Get_Object_Deepness',AFilePath);
  @Get_Object_Hint := Get_Dll_Function_Adress(hDll,'Get_Object_Hint',AFilePath);
  @Get_Object_ID_OT := Get_Dll_Function_Adress(hDll,'Get_Object_ID_OT',AFilePath);
  @Get_ID_Object_From_Name := Get_Dll_Function_Adress(hDll,'Get_ID_Object_From_Name',AFilePath);
  @Get_Object_Nb_Children := Get_Dll_Function_Adress(hDll,'Get_Object_Nb_Children',AFilePath);
  @Create_OL_Object := Get_Dll_Function_Adress(hDll,'Create_OL_Object',AFilePath);
  @Create_OL_Object_Link_Form := Get_Dll_Function_Adress(hDll,'Create_OL_Object_Link_Form',AFilePath);
  @Get_Parent_Inheritage := Get_Dll_Function_Adress(hDll,'Get_Parent_Inheritage',AFilePath);
  @Create_OL_Object_Tree_Sorted_From_SL_ID := Get_Dll_Function_Adress(hDll,'Create_OL_Object_Tree_Sorted_From_SL_ID',AFilePath);
  @Create_OL_Object_Tree_Sorted := Get_Dll_Function_Adress(hDll,'Create_OL_Object_Tree_Sorted',AFilePath);
  @Create_SL_ID_Object := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object',AFilePath);
  @Create_OL_Object_From_Preselection := Get_Dll_Function_Adress(hDll,'Create_OL_Object_From_Preselection',AFilePath);
  @Create_OL_Object_Link_Form_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Object_Link_Form_Filtered',AFilePath);
  @Get_Object_ID_Parent := Get_Dll_Function_Adress(hDll,'Get_Object_ID_Parent',AFilePath);
  @Create_Object_In_DB := Get_Dll_Function_Adress(hDll,'Create_Object_In_DB',AFilePath);
  @Sort_Objects_in_DB := Get_Dll_Function_Adress(hDll,'Sort_Objects_in_DB',AFilePath);
  @Move_Object := Get_Dll_Function_Adress(hDll,'Move_Object',AFilePath);
  @Initialize_Standard_Duplication := Get_Dll_Function_Adress(hDll,'Initialize_Standard_Duplication',AFilePath);
  @Fill_Object_From_Advanced_Creation_Settings := Get_Dll_Function_Adress(hDll,'Fill_Object_From_Advanced_Creation_Settings',AFilePath);
  @Fill_Object_From_Duplication_Settings := Get_Dll_Function_Adress(hDll,'Fill_Object_From_Duplication_Settings',AFilePath);
  @Create_Object_From_Duplication_Settings := Get_Dll_Function_Adress(hDll,'Create_Object_From_Duplication_Settings',AFilePath);
  @Create_Object_Duplicated := Get_Dll_Function_Adress(hDll,'Create_Object_Duplicated',AFilePath);
  @Get_Object_Icon := Get_Dll_Function_Adress(hDll,'Get_Object_Icon',AFilePath);
  @Get_Object_Name_Extended := Get_Dll_Function_Adress(hDll,'Get_Object_Name_Extended',AFilePath);
  @Get_Object_Name := Get_Dll_Function_Adress(hDll,'Get_Object_Name',AFilePath);
  @Restore_Object := Get_Dll_Function_Adress(hDll,'Restore_Object',AFilePath);
  @Empty_Trash := Get_Dll_Function_Adress(hDll,'Empty_Trash',AFilePath);
  @Create_SL_ID_Object_From_Names := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object_From_Names',AFilePath);
  @Delete_Objects := Get_Dll_Function_Adress(hDll,'Delete_Objects',AFilePath);
  @Delete_Objects_From_Deletion_Settings := Get_Dll_Function_Adress(hDll,'Delete_Objects_From_Deletion_Settings',AFilePath);
  @Delete_Object := Get_Dll_Function_Adress(hDll,'Delete_Object',AFilePath);
  @AttributeTypeToShortCodedStr := Get_Dll_Function_Adress(hDll,'AttributeTypeToShortCodedStr',AFilePath);
  @AttributeTypeToStr := Get_Dll_Function_Adress(hDll,'AttributeTypeToStr',AFilePath);
  @Get_AttributeTypeLabel := Get_Dll_Function_Adress(hDll,'Get_AttributeTypeLabel',AFilePath);
  @Get_Object_Folder := Get_Dll_Function_Adress(hDll,'Get_Object_Folder',AFilePath);
  @Create_SL_ID_Object_Without_Data := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object_Without_Data',AFilePath);
  @HasObjectData := Get_Dll_Function_Adress(hDll,'HasObjectData',AFilePath);
  @Check_Object_Existence := Get_Dll_Function_Adress(hDll,'Check_Object_Existence',AFilePath);
  @Creer_Instance_Erreur_Parente_Modifiee := Get_Dll_Function_Adress(hDll,'Creer_Instance_Erreur_Parente_Modifiee',AFilePath);
  @Get_Object_sPath := Get_Dll_Function_Adress(hDll,'Get_Object_sPath',AFilePath);
  @Create_OL_Object_From_Table := Get_Dll_Function_Adress(hDll,'Create_OL_Object_From_Table',AFilePath);
  @Check_Object_ExistenceExt := Get_Dll_Function_Adress(hDll,'Check_Object_ExistenceExt',AFilePath);
  @Write_New_Object := Get_Dll_Function_Adress(hDll,'Write_New_Object',AFilePath);
  @Rename_Object := Get_Dll_Function_Adress(hDll,'Rename_Object',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Attribute_Set_Level'}
  @Create_Attribute_Set_Level := Get_Dll_Function_Adress(hDll,'Create_Attribute_Set_Level',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Attribute_Set'}
  @Create_Attribute_Set := Get_Dll_Function_Adress(hDll,'Create_Attribute_Set',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Business_View'}
  @Create_OL_Duplication_Settings_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Duplication_Settings_Filtered',AFilePath);
  @Create_OL_Deletion_Settings_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Deletion_Settings_Filtered',AFilePath);
  @Create_OL_Advanced_Creation_Settings_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Advanced_Creation_Settings_Filtered',AFilePath);
  @Create_OL_Attribute_For_Advanced_Duplication := Get_Dll_Function_Adress(hDll,'Create_OL_Attribute_For_Advanced_Duplication',AFilePath);
  @Create_OL_Advanced_Comparison_Settings_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Advanced_Comparison_Settings_Filtered',AFilePath);
  @Get_Default_Advanced_Comparison_Settings := Get_Dll_Function_Adress(hDll,'Get_Default_Advanced_Comparison_Settings',AFilePath);
  @Create_OL_Attribute_For_Advanced_Creation := Get_Dll_Function_Adress(hDll,'Create_OL_Attribute_For_Advanced_Creation',AFilePath);
  @Create_OL_Attribute_For_Advanced_Comparison := Get_Dll_Function_Adress(hDll,'Create_OL_Attribute_For_Advanced_Comparison',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Link_Type'}
  @Create_Link_Type := Get_Dll_Function_Adress(hDll,'Create_Link_Type',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Date'}
  @Create_Data_Date := Get_Dll_Function_Adress(hDll,'Create_Data_Date',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_String'}
  @Create_Data_String := Get_Dll_Function_Adress(hDll,'Create_Data_String',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Text'}
  @Create_Data_Text := Get_Dll_Function_Adress(hDll,'Create_Data_Text',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_URL'}
  @Create_Data_URL := Get_Dll_Function_Adress(hDll,'Create_Data_URL',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Boolean'}
  @Create_Data_Boolean := Get_Dll_Function_Adress(hDll,'Create_Data_Boolean',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Decimal'}
  @Create_Data_Decimal := Get_Dll_Function_Adress(hDll,'Create_Data_Decimal',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_File'}
  @Create_Data_File := Get_Dll_Function_Adress(hDll,'Create_Data_File',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Table_Value'}
  @Create_Table_Value := Get_Dll_Function_Adress(hDll,'Create_Table_Value',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Table'}
  @Create_Data_Table := Get_Dll_Function_Adress(hDll,'Create_Data_Table',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Link'}
  @Create_Data_Link := Get_Dll_Function_Adress(hDll,'Create_Data_Link',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Object_Associative'}
  @Create_Object_Associative := Get_Dll_Function_Adress(hDll,'Create_Object_Associative',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Link_Ass'}
  @Create_Data_Link_Ass := Get_Dll_Function_Adress(hDll,'Create_Data_Link_Ass',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data'}
  @Create_Data_From_String := Get_Dll_Function_Adress(hDll,'Create_Data_From_String',AFilePath);
  @Create_Data_From_TD := Get_Dll_Function_Adress(hDll,'Create_Data_From_TD',AFilePath);
  @Create_Data := Get_Dll_Function_Adress(hDll,'Create_Data',AFilePath);
  @Create_Data_Numerical := Get_Dll_Function_Adress(hDll,'Create_Data_Numerical',AFilePath);
  @Create_Series := Get_Dll_Function_Adress(hDll,'Create_Series',AFilePath);
  @DecToStrF_From_Attribute := Get_Dll_Function_Adress(hDll,'DecToStrF_From_Attribute',AFilePath);
  @Create_OL_Data_From_Object := Get_Dll_Function_Adress(hDll,'Create_OL_Data_From_Object',AFilePath);
  @Create_OL_Data_From_Attribute := Get_Dll_Function_Adress(hDll,'Create_OL_Data_From_Attribute',AFilePath);
  @Create_OL_Data := Get_Dll_Function_Adress(hDll,'Create_OL_Data',AFilePath);
  @Get_Data := Get_Dll_Function_Adress(hDll,'Get_Data',AFilePath);
  @FillOlFilteredData := Get_Dll_Function_Adress(hDll,'FillOlFilteredData',AFilePath);
  @Create_OL_Data_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Data_Filtered',AFilePath);
  @Export_Multiple_Data_Table_To_File := Get_Dll_Function_Adress(hDll,'Export_Multiple_Data_Table_To_File',AFilePath);
  @Export_Data_Table_To_File := Get_Dll_Function_Adress(hDll,'Export_Data_Table_To_File',AFilePath);
  @Get_Object_Associative := Get_Dll_Function_Adress(hDll,'Get_Object_Associative',AFilePath);
  @Get_NumericalData_fValue := Get_Dll_Function_Adress(hDll,'Get_NumericalData_fValue',AFilePath);
  @Get_Data_fValue := Get_Dll_Function_Adress(hDll,'Get_Data_fValue',AFilePath);
  @Get_Data_bValue := Get_Dll_Function_Adress(hDll,'Get_Data_bValue',AFilePath);
  @Get_Data_sValue := Get_Dll_Function_Adress(hDll,'Get_Data_sValue',AFilePath);
  @Get_Data_ID_Object_Linked := Get_Dll_Function_Adress(hDll,'Get_Data_ID_Object_Linked',AFilePath);
  @Get_Data_OL_Object_Linked := Get_Dll_Function_Adress(hDll,'Get_Data_OL_Object_Linked',AFilePath);
  @Get_Data_SL_ID_Object_Linked := Get_Dll_Function_Adress(hDll,'Get_Data_SL_ID_Object_Linked',AFilePath);
  @Get_Data_Object_Linked := Get_Dll_Function_Adress(hDll,'Get_Data_Object_Linked',AFilePath);
  @Write_Single_Data := Get_Dll_Function_Adress(hDll,'Write_Single_Data',AFilePath);
  @Write_Data_Link := Get_Dll_Function_Adress(hDll,'Write_Data_Link',AFilePath);
  @Write_Data_Boolean := Get_Dll_Function_Adress(hDll,'Write_Data_Boolean',AFilePath);
  @Write_Data_Numerical := Get_Dll_Function_Adress(hDll,'Write_Data_Numerical',AFilePath);
  @Write_Data_String := Get_Dll_Function_Adress(hDll,'Write_Data_String',AFilePath);
  @Write_Data_File := Get_Dll_Function_Adress(hDll,'Write_Data_File',AFilePath);
  @Write_Data := Get_Dll_Function_Adress(hDll,'Write_Data',AFilePath);
  @Read_Data_Link := Get_Dll_Function_Adress(hDll,'Read_Data_Link',AFilePath);
  @Read_Data_Link_Single_ID_Object := Get_Dll_Function_Adress(hDll,'Read_Data_Link_Single_ID_Object',AFilePath);
  @Read_Data_Boolean := Get_Dll_Function_Adress(hDll,'Read_Data_Boolean',AFilePath);
  @Read_Data_Numerical := Get_Dll_Function_Adress(hDll,'Read_Data_Numerical',AFilePath);
  @Read_Data_String := Get_Dll_Function_Adress(hDll,'Read_Data_String',AFilePath);
  @Read_Data_Table := Get_Dll_Function_Adress(hDll,'Read_Data_Table',AFilePath);
  @Read_Data_File := Get_Dll_Function_Adress(hDll,'Read_Data_File',AFilePath);
  @Read_Data_Filename := Get_Dll_Function_Adress(hDll,'Read_Data_Filename',AFilePath);
  @Extract_Data_Table_Graphics := Get_Dll_Function_Adress(hDll,'Extract_Data_Table_Graphics',AFilePath);
  @Delete_Data := Get_Dll_Function_Adress(hDll,'Delete_Data',AFilePath);
  @Create_OL_Archived_File := Get_Dll_Function_Adress(hDll,'Create_OL_Archived_File',AFilePath);
  @Create_Archived_File := Get_Dll_Function_Adress(hDll,'Create_Archived_File',AFilePath);
  @Extract_Data_File_File := Get_Dll_Function_Adress(hDll,'Extract_Data_File_File',AFilePath);
  @Extract_Archived_File_File := Get_Dll_Function_Adress(hDll,'Extract_Archived_File_File',AFilePath);
  @Get_ID_Archived_File_From_Filename := Get_Dll_Function_Adress(hDll,'Get_ID_Archived_File_From_Filename',AFilePath);
  @Create_Data_File_For_Publication := Get_Dll_Function_Adress(hDll,'Create_Data_File_For_Publication',AFilePath);
  @Initialize_New_Document_Model := Get_Dll_Function_Adress(hDll,'Initialize_New_Document_Model',AFilePath);
  @Check_Document_With_Template_Gestion := Get_Dll_Function_Adress(hDll,'Check_Document_With_Template_Gestion',AFilePath);
  @Initialize_New_Document := Get_Dll_Function_Adress(hDll,'Initialize_New_Document',AFilePath);
  @Create_Document_Versionned_In_DB := Get_Dll_Function_Adress(hDll,'Create_Document_Versionned_In_DB',AFilePath);
  @Pass_Document_As_Reference := Get_Dll_Function_Adress(hDll,'Pass_Document_As_Reference',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Right'}
  @Create_Right := Get_Dll_Function_Adress(hDll,'Create_Right',AFilePath);
  @Modify_Object_Rights := Get_Dll_Function_Adress(hDll,'Modify_Object_Rights',AFilePath);
  @Get_User_Default_Right_On_New_Object := Get_Dll_Function_Adress(hDll,'Get_User_Default_Right_On_New_Object',AFilePath);
  @GetActiveUserRightOnObject := Get_Dll_Function_Adress(hDll,'GetActiveUserRightOnObject',AFilePath);
  {$ENDREGION}

  {$REGION 'U_LObject'}
  @Create_LObject := Get_Dll_Function_Adress(hDll,'Create_LObject',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Users_Group_User'}
  @Create_Users_Group_User2 := Get_Dll_Function_Adress(hDll,'Create_Users_Group_User2',AFilePath);
  @Create_Users_Group_User := Get_Dll_Function_Adress(hDll,'Create_Users_Group_User',AFilePath);
  {$ENDREGION}

  {$REGION 'U_User'}
  @Create_User := Get_Dll_Function_Adress(hDll,'Create_User',AFilePath);
  @Create_OL_User := Get_Dll_Function_Adress(hDll,'Create_OL_User',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Users_Group'}
  @Create_Users_Group := Get_Dll_Function_Adress(hDll,'Create_Users_Group',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Users_Manager'}
  @CreateOlSpecificUsersGroup := Get_Dll_Function_Adress(hDll,'CreateOlSpecificUsersGroup',AFilePath);
  @Load_Users_Groups := Get_Dll_Function_Adress(hDll,'Load_Users_Groups',AFilePath);
  @Test_Binding_Between_User_And_Users_Group := Get_Dll_Function_Adress(hDll,'Test_Binding_Between_User_And_Users_Group',AFilePath);
  @Get_Generated_Password := Get_Dll_Function_Adress(hDll,'Get_Generated_Password',AFilePath);
  @Check_Password_Policy := Get_Dll_Function_Adress(hDll,'Check_Password_Policy',AFilePath);
  @Get_User_Expiration_Date := Get_Dll_Function_Adress(hDll,'Get_User_Expiration_Date',AFilePath);
  @Get_User_Duration_Password_Validity := Get_Dll_Function_Adress(hDll,'Get_User_Duration_Password_Validity',AFilePath);
  @Get_User_Password_Last_Change_Date := Get_Dll_Function_Adress(hDll,'Get_User_Password_Last_Change_Date',AFilePath);
  @Get_User_Name := Get_Dll_Function_Adress(hDll,'Get_User_Name',AFilePath);
  @Get_User_Nb_UG := Get_Dll_Function_Adress(hDll,'Get_User_Nb_UG',AFilePath);
  @Get_ID_User_From_ID_Object := Get_Dll_Function_Adress(hDll,'Get_ID_User_From_ID_Object',AFilePath);
  @Get_User_ID_Object := Get_Dll_Function_Adress(hDll,'Get_User_ID_Object',AFilePath);
  @Get_ID_User_From_Login := Get_Dll_Function_Adress(hDll,'Get_ID_User_From_Login',AFilePath);
  @Get_ID_User_From_Name := Get_Dll_Function_Adress(hDll,'Get_ID_User_From_Name',AFilePath);
  @Get_User_Login := Get_Dll_Function_Adress(hDll,'Get_User_Login',AFilePath);
  @Get_User_Login_From_Name := Get_Dll_Function_Adress(hDll,'Get_User_Login_From_Name',AFilePath);
  @Get_User_Date_Last_Connection := Get_Dll_Function_Adress(hDll,'Get_User_Date_Last_Connection',AFilePath);
  @Get_ID_Users_Group_From_Login := Get_Dll_Function_Adress(hDll,'Get_ID_Users_Group_From_Login',AFilePath);
  @Get_ID_Users_Group_From_Name := Get_Dll_Function_Adress(hDll,'Get_ID_Users_Group_From_Name',AFilePath);
  @Write_New_Users_Group := Get_Dll_Function_Adress(hDll,'Write_New_Users_Group',AFilePath);
  @Get_Unique_Login := Get_Dll_Function_Adress(hDll,'Get_Unique_Login',AFilePath);
  @Get_Unique_Users_Group_Name := Get_Dll_Function_Adress(hDll,'Get_Unique_Users_Group_Name',AFilePath);
  @Get_ID_Users_Group_From_User := Get_Dll_Function_Adress(hDll,'Get_ID_Users_Group_From_User',AFilePath);
  @Add_User_To_Users_Group := Get_Dll_Function_Adress(hDll,'Add_User_To_Users_Group',AFilePath);
  @Remove_User_From_Users_Group := Get_Dll_Function_Adress(hDll,'Remove_User_From_Users_Group',AFilePath);
  @Write_New_UserExt := Get_Dll_Function_Adress(hDll,'Write_New_UserExt',AFilePath);
  @Write_New_User := Get_Dll_Function_Adress(hDll,'Write_New_User',AFilePath);
  @Update_Users_Group_Object_Right := Get_Dll_Function_Adress(hDll,'Update_Users_Group_Object_Right',AFilePath);
  @Remove_Users_Specific_Rights_On_Object := Get_Dll_Function_Adress(hDll,'Remove_Users_Specific_Rights_On_Object',AFilePath);
  @Get_OL_Users_Group := Get_Dll_Function_Adress(hDll,'Get_OL_Users_Group',AFilePath);
  @Get_User_Password := Get_Dll_Function_Adress(hDll,'Get_User_Password',AFilePath);
  @Update_User_Password := Get_Dll_Function_Adress(hDll,'Update_User_Password',AFilePath);
  @Get_User_Icon := Get_Dll_Function_Adress(hDll,'Get_User_Icon',AFilePath);
  @Get_Users_Group := Get_Dll_Function_Adress(hDll,'Get_Users_Group',AFilePath);
  @Get_Users_Group_Name := Get_Dll_Function_Adress(hDll,'Get_Users_Group_Name',AFilePath);
  @Remove_Object_Specific_Rights := Get_Dll_Function_Adress(hDll,'Remove_Object_Specific_Rights',AFilePath);
  @Remove_Object_Standard_Rights := Get_Dll_Function_Adress(hDll,'Remove_Object_Standard_Rights',AFilePath);
  @RemoveUnrelevantUsersGroups := Get_Dll_Function_Adress(hDll,'RemoveUnrelevantUsersGroups',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Unit'}
  @Create_Conversion := Get_Dll_Function_Adress(hDll,'Create_Conversion',AFilePath);
  @Create_Unit := Get_Dll_Function_Adress(hDll,'Create_Unit',AFilePath);
  {$ENDREGION}

  {$REGION 'U_File_Type'}
  @Create_File_Type := Get_Dll_Function_Adress(hDll,'Create_File_Type',AFilePath);
  @CheckIf_File_Type_Deletable := Get_Dll_Function_Adress(hDll,'CheckIf_File_Type_Deletable',AFilePath);
  @Get_File_Type_Nb_Archived_Files := Get_Dll_Function_Adress(hDll,'Get_File_Type_Nb_Archived_Files',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Table_Type'}
  @Create_Table_Type := Get_Dll_Function_Adress(hDll,'Create_Table_Type',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Series_Type'}
  @Create_Series_Type := Get_Dll_Function_Adress(hDll,'Create_Series_Type',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Criterion'}
  @Create_Criterion := Get_Dll_Function_Adress(hDll,'Create_Criterion',AFilePath);
  @Delete_Criterion := Get_Dll_Function_Adress(hDll,'Delete_Criterion',AFilePath);
  @Get_Criterion := Get_Dll_Function_Adress(hDll,'Get_Criterion',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Requirement_List'}
  @Delete_Requirement_List := Get_Dll_Function_Adress(hDll,'Delete_Requirement_List',AFilePath);
  {$ENDREGION}

  {$REGION 'U_MCS'}
  @Create_OL_Comparable_Attribute := Get_Dll_Function_Adress(hDll,'Create_OL_Comparable_Attribute',AFilePath);
  @Get_Criterion_From_Kinship_and_Attribute := Get_Dll_Function_Adress(hDll,'Get_Criterion_From_Kinship_and_Attribute',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Extraction'}
  @Create_Extraction := Get_Dll_Function_Adress(hDll,'Create_Extraction',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Bookmark'}
  @Create_Bookmark := Get_Dll_Function_Adress(hDll,'Create_Bookmark',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Statistics'}
  @Update_OL_Statistics_And_Correlation := Get_Dll_Function_Adress(hDll,'Update_OL_Statistics_And_Correlation',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Evaluation'}
  @Create_Evaluation := Get_Dll_Function_Adress(hDll,'Create_Evaluation',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Translation_Object_Type'}
  @Create_Translation_Object_Type := Get_Dll_Function_Adress(hDll,'Create_Translation_Object_Type',AFilePath);
  {$ENDREGION}

  {$REGION 'U_XML'}
  @Create_Object_From_XML := Get_Dll_Function_Adress(hDll,'Create_Object_From_XML',AFilePath);
  @Create_Object_From_XML_File := Get_Dll_Function_Adress(hDll,'Create_Object_From_XML_File',AFilePath);
  @Fill_XML_From_OL := Get_Dll_Function_Adress(hDll,'Fill_XML_From_OL',AFilePath);
  @OLToXML := Get_Dll_Function_Adress(hDll,'OLToXML',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Choice_Guide'}
  @Get_Choice_Guide_Default_RL_Name := Get_Dll_Function_Adress(hDll,'Get_Choice_Guide_Default_RL_Name',AFilePath);
  @Create_Choice_Guide := Get_Dll_Function_Adress(hDll,'Create_Choice_Guide',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Answer'}
  @Create_Answer := Get_Dll_Function_Adress(hDll,'Create_Answer',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Answers'}
  @Create_Answers2 := Get_Dll_Function_Adress(hDll,'Create_Answers2',AFilePath);
  @Create_Answers_From_File := Get_Dll_Function_Adress(hDll,'Create_Answers_From_File',AFilePath);
  @Create_Answers := Get_Dll_Function_Adress(hDll,'Create_Answers',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Question'}
  @Get_Question_Type_Name := Get_Dll_Function_Adress(hDll,'Get_Question_Type_Name',AFilePath);
  @Create_Question := Get_Dll_Function_Adress(hDll,'Create_Question',AFilePath);
  {$ENDREGION}

  {$REGION 'U_VACBOA'}
  @Create_VACBOA := Get_Dll_Function_Adress(hDll,'Create_VACBOA',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Source'}
  @Create_OL_Source := Get_Dll_Function_Adress(hDll,'Create_OL_Source',AFilePath);
  @Create_OL_Source_From_Object := Get_Dll_Function_Adress(hDll,'Create_OL_Source_From_Object',AFilePath);
  @Create_Source := Get_Dll_Function_Adress(hDll,'Create_Source',AFilePath);
  @Get_Source := Get_Dll_Function_Adress(hDll,'Get_Source',AFilePath);
  @Get_Source_OL_Data := Get_Dll_Function_Adress(hDll,'Get_Source_OL_Data',AFilePath);
  @Create_OL_Source_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Source_Filtered',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Information'}
  @Get_Information := Get_Dll_Function_Adress(hDll,'Get_Information',AFilePath);
  @Create_OL_Information_From_Tab := Get_Dll_Function_Adress(hDll,'Create_OL_Information_From_Tab',AFilePath);
  @Create_OL_Information := Get_Dll_Function_Adress(hDll,'Create_OL_Information',AFilePath);
  @Create_Information := Get_Dll_Function_Adress(hDll,'Create_Information',AFilePath);
  {$ENDREGION}

  {$REGION 'U_MCS_Algorithm'}
  @Create_MCS_Mark := Get_Dll_Function_Adress(hDll,'Create_MCS_Mark',AFilePath);
  @Create_SL_ID_Object_From_bValue := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object_From_bValue',AFilePath);
  @Create_SL_ID_Object_From_sValue := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object_From_sValue',AFilePath);
  @Create_SL_ID_Object_From_fValue := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object_From_fValue',AFilePath);
  @Create_SL_ID_Object_From_Range_Value := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object_From_Range_Value',AFilePath);
  @Create_SL_ID_Object_From_Linked_Object := Get_Dll_Function_Adress(hDll,'Create_SL_ID_Object_From_Linked_Object',AFilePath);
  @Get_ID_Object_From_sValue := Get_Dll_Function_Adress(hDll,'Get_ID_Object_From_sValue',AFilePath);
  @Get_ID_Object_From_fValue := Get_Dll_Function_Adress(hDll,'Get_ID_Object_From_fValue',AFilePath);
  @Get_ID_Object_From_bValue := Get_Dll_Function_Adress(hDll,'Get_ID_Object_From_bValue',AFilePath);
  @Get_ID_Object_From_Range_Value := Get_Dll_Function_Adress(hDll,'Get_ID_Object_From_Range_Value',AFilePath);
  @Get_ID_Object_From_Linked_Object := Get_Dll_Function_Adress(hDll,'Get_ID_Object_From_Linked_Object',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Mark_Criterion'}
  @Create_MCS_Mark_Criterion := Get_Dll_Function_Adress(hDll,'Create_MCS_Mark_Criterion',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Mark_Object'}
  @Create_MCS_Mark_Object := Get_Dll_Function_Adress(hDll,'Create_MCS_Mark_Object',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Results'}
  @Create_MCS_Results := Get_Dll_Function_Adress(hDll,'Create_MCS_Results',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Structure_Multilingualism'}
  @Create_Language := Get_Dll_Function_Adress(hDll,'Create_Language',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Language_Manager'}
  @_Path := Get_Dll_Function_Adress(hDll,'_Path',AFilePath);
  @Get_OL_Language := Get_Dll_Function_Adress(hDll,'Get_OL_Language',AFilePath);
  @Get_Language := Get_Dll_Function_Adress(hDll,'Get_Language',AFilePath);
  @Get_Active_Language := Get_Dll_Function_Adress(hDll,'Get_Active_Language',AFilePath);
  @Get_Active_Language_Code := Get_Dll_Function_Adress(hDll,'Get_Active_Language_Code',AFilePath);
  @Get_Active_Language_ID := Get_Dll_Function_Adress(hDll,'Get_Active_Language_ID',AFilePath);
  @Set_Active_Language := Get_Dll_Function_Adress(hDll,'Set_Active_Language',AFilePath);
  @Get_Language_Name := Get_Dll_Function_Adress(hDll,'Get_Language_Name',AFilePath);
  {$ENDREGION}

  {$REGION 'U_IO'}
  @Create_IO := Get_Dll_Function_Adress(hDll,'Create_IO',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Model'}
  @Create_Model := Get_Dll_Function_Adress(hDll,'Create_Model',AFilePath);
  {$ENDREGION}

  {$REGION 'U_iEquivalence'}
  @Create_Eq_iEquivalence := Get_Dll_Function_Adress(hDll,'Create_Eq_iEquivalence',AFilePath);
  @Get_iEquivalence_From_Right := Get_Dll_Function_Adress(hDll,'Get_iEquivalence_From_Right',AFilePath);
  @Get_iEquivalence_From_Left := Get_Dll_Function_Adress(hDll,'Get_iEquivalence_From_Left',AFilePath);
  {$ENDREGION}

  {$REGION 'U_sEquivalence'}
  @Create_Eq_sEquivalence := Get_Dll_Function_Adress(hDll,'Create_Eq_sEquivalence',AFilePath);
  @Get_sEquivalence_From_Right := Get_Dll_Function_Adress(hDll,'Get_sEquivalence_From_Right',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Eq_Attribute_ID'}
  @Create_Eq_Attribute_ID := Get_Dll_Function_Adress(hDll,'Create_Eq_Attribute_ID',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Eq_Attribute_sID'}
  @Create_Eq_Attribute_sID := Get_Dll_Function_Adress(hDll,'Create_Eq_Attribute_sID',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Eq_Object_Attribute'}
  @Create_Eq_Object_Attribute := Get_Dll_Function_Adress(hDll,'Create_Eq_Object_Attribute',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Eq_Object_ID'}
  @Create_Eq_Object_ID := Get_Dll_Function_Adress(hDll,'Create_Eq_Object_ID',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Eq_Object_sID'}
  @Create_Eq_Object_sID := Get_Dll_Function_Adress(hDll,'Create_Eq_Object_sID',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Applied_IO'}
  @Create_Applied_IO := Get_Dll_Function_Adress(hDll,'Create_Applied_IO',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Model_Application'}
  @Create_Model_Application := Get_Dll_Function_Adress(hDll,'Create_Model_Application',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Exportation'}
  @ExportationTypeToStr := Get_Dll_Function_Adress(hDll,'ExportationTypeToStr',AFilePath);
  @Create_Exportation := Get_Dll_Function_Adress(hDll,'Create_Exportation',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Connection_Settings'}
  @Create_Connection_Settings := Get_Dll_Function_Adress(hDll,'Create_Connection_Settings',AFilePath);
  {$ENDREGION}

  {$REGION 'U_TEEXMA_Connection_Settings'}
  @Create_TEEXMA_Connection_Settings := Get_Dll_Function_Adress(hDll,'Create_TEEXMA_Connection_Settings',AFilePath);
  {$ENDREGION}

  {$REGION 'U_CS_LDAP'}
  @Create_CS_LDAP := Get_Dll_Function_Adress(hDll,'Create_CS_LDAP',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Connection'}
  @Get_TxAPIConnection := Get_Dll_Function_Adress(hDll,'Get_TxAPIConnection',AFilePath);
  @Set_Excel_Retrieve_Results := Get_Dll_Function_Adress(hDll,'Set_Excel_Retrieve_Results',AFilePath);
  @Get_Dir_TEEXMA_Temp := Get_Dll_Function_Adress(hDll,'Get_Dir_TEEXMA_Temp',AFilePath);
  @Get_Dir_TEEXMA := Get_Dll_Function_Adress(hDll,'Get_Dir_TEEXMA',AFilePath);
  @Get_Dir_Administration := Get_Dll_Function_Adress(hDll,'Get_Dir_Administration',AFilePath);
  @Get_Path_File_Administration_EXE := Get_Dll_Function_Adress(hDll,'Get_Path_File_Administration_EXE',AFilePath);
  @Get_Dir_Archived_Files := Get_Dll_Function_Adress(hDll,'Get_Dir_Archived_Files',AFilePath);
  @Get_Dir_Customer_Resources := Get_Dll_Function_Adress(hDll,'Get_Dir_Customer_Resources',AFilePath);
  @Get_Dir_Resources := Get_Dll_Function_Adress(hDll,'Get_Dir_Resources',AFilePath);
  @Get_Dir_Exportations := Get_Dll_Function_Adress(hDll,'Get_Dir_Exportations',AFilePath);
  @Get_Path_File_No_Model_BMP := Get_Dll_Function_Adress(hDll,'Get_Path_File_No_Model_BMP',AFilePath);
  @Get_Dir_HTML := Get_Dll_Function_Adress(hDll,'Get_Dir_HTML',AFilePath);
  @Get_Dir_Graphs := Get_Dll_Function_Adress(hDll,'Get_Dir_Graphs',AFilePath);
  @Get_Dir_Lib_Graphs := Get_Dll_Function_Adress(hDll,'Get_Dir_Lib_Graphs',AFilePath);
  @Get_Path_File_Home_HTML := Get_Dll_Function_Adress(hDll,'Get_Path_File_Home_HTML',AFilePath);
  @Get_Dir_Pictures := Get_Dll_Function_Adress(hDll,'Get_Dir_Pictures',AFilePath);
  @Get_Dir_Pictures_Buttons := Get_Dll_Function_Adress(hDll,'Get_Dir_Pictures_Buttons',AFilePath);
  @Get_Dir_Icons := Get_Dll_Function_Adress(hDll,'Get_Dir_Icons',AFilePath);
  @Get_Dir_Icons_Web := Get_Dll_Function_Adress(hDll,'Get_Dir_Icons_Web',AFilePath);
  @Get_Dir_Icons_Old := Get_Dll_Function_Adress(hDll,'Get_Dir_Icons_Old',AFilePath);
  @Get_Dir_Illustrations := Get_Dll_Function_Adress(hDll,'Get_Dir_Illustrations',AFilePath);
  @Get_File_Path_Banner_Default_JPG := Get_Dll_Function_Adress(hDll,'Get_File_Path_Banner_Default_JPG',AFilePath);
  @Get_Dir_Helps := Get_Dll_Function_Adress(hDll,'Get_Dir_Helps',AFilePath);
  @Get_Dir_Extractions := Get_Dll_Function_Adress(hDll,'Get_Dir_Extractions',AFilePath);
  @Get_Dir_CR_Translations := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Translations',AFilePath);
  @Get_Path_File_TEEXMA_XSD := Get_Dll_Function_Adress(hDll,'Get_Path_File_TEEXMA_XSD',AFilePath);
  @Get_Dir_CR_Extractions := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Extractions',AFilePath);
  @Get_Dir_CR_Graphs := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Graphs',AFilePath);
  @Get_Dir_CR_Models := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Models',AFilePath);
  @Get_Dir_CR_Illustrations := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Illustrations',AFilePath);
  @Get_Dir_CR_HTML := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_HTML',AFilePath);
  @Get_Path_File_Folder_HTML := Get_Dll_Function_Adress(hDll,'Get_Path_File_Folder_HTML',AFilePath);
  @Get_Dir_CR_Banners := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Banners',AFilePath);
  @Get_Dir_CR_Portals := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Portals',AFilePath);
  @Get_Dir_CR_Icons := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Icons',AFilePath);
  @Get_Dir_CR_Icons_Web := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Icons_Web',AFilePath);
  @Get_Dir_CR_Exportations := Get_Dll_Function_Adress(hDll,'Get_Dir_CR_Exportations',AFilePath);
  @Get_Archived_File_Stored_In_DB := Get_Dll_Function_Adress(hDll,'Get_Archived_File_Stored_In_DB',AFilePath);
  @Get_TEEXMA_ConnectionString := Get_Dll_Function_Adress(hDll,'Get_TEEXMA_ConnectionString',AFilePath);
  @Get_TEEXMA_Archived_File_ConnectionString := Get_Dll_Function_Adress(hDll,'Get_TEEXMA_Archived_File_ConnectionString',AFilePath);
  @Get_Authentification_Type := Get_Dll_Function_Adress(hDll,'Get_Authentification_Type',AFilePath);
  @Get_Automated_Connection_Type := Get_Dll_Function_Adress(hDll,'Get_Automated_Connection_Type',AFilePath);
  @Get_Prohibit_Manual_Connection := Get_Dll_Function_Adress(hDll,'Get_Prohibit_Manual_Connection',AFilePath);
  @Get_Strong_Password := Get_Dll_Function_Adress(hDll,'Get_Strong_Password',AFilePath);
  @Get_Display_Users_List := Get_Dll_Function_Adress(hDll,'Get_Display_Users_List',AFilePath);
  @Get_Path_File_Help_PDF := Get_Dll_Function_Adress(hDll,'Get_Path_File_Help_PDF',AFilePath);
  @Get_Name_DB := Get_Dll_Function_Adress(hDll,'Get_Name_DB',AFilePath);
  @Get_Server_URL := Get_Dll_Function_Adress(hDll,'Get_Server_URL',AFilePath);
  @Get_Logged_With_WSession := Get_Dll_Function_Adress(hDll,'Get_Logged_With_WSession',AFilePath);
  @Get_Default_Language_Code := Get_Dll_Function_Adress(hDll,'Get_Default_Language_Code',AFilePath);
  @Get_Path_File_Preferences_INI := Get_Dll_Function_Adress(hDll,'Get_Path_File_Preferences_INI',AFilePath);
  @Get_TxRevision := Get_Dll_Function_Adress(hDll,'Get_TxRevision',AFilePath);
  @Get_DB_Revision := Get_Dll_Function_Adress(hDll,'Get_DB_Revision',AFilePath);
  @Get_TxDB_Revision := Get_Dll_Function_Adress(hDll,'Get_TxDB_Revision',AFilePath);
  @Set_TxOut_Object := Get_Dll_Function_Adress(hDll,'Set_TxOut_Object',AFilePath);
  @Get_TxOut_Object := Get_Dll_Function_Adress(hDll,'Get_TxOut_Object',AFilePath);
  @FinalizeTxAPI := Get_Dll_Function_Adress(hDll,'FinalizeTxAPI',AFilePath);
  @InitializeTxAPIForExternalDevs := Get_Dll_Function_Adress(hDll,'InitializeTxAPIForExternalDevs',AFilePath);
  @Reinit_Connections := Get_Dll_Function_Adress(hDll,'Reinit_Connections',AFilePath);
  @Add_Allowed_Thread_For_TXAPI_Translation := Get_Dll_Function_Adress(hDll,'Add_Allowed_Thread_For_TXAPI_Translation',AFilePath);
  @InitializeTxAPI := Get_Dll_Function_Adress(hDll,'InitializeTxAPI',AFilePath);
  @Get_Data_Numbering_Type := Get_Dll_Function_Adress(hDll,'Get_Data_Numbering_Type',AFilePath);
  @Get_List_Ordering_Type := Get_Dll_Function_Adress(hDll,'Get_List_Ordering_Type',AFilePath);
  @Get_Banner_Visible_By_Default := Get_Dll_Function_Adress(hDll,'Get_Banner_Visible_By_Default',AFilePath);
  @Get_Display_Object_Path_In_Banner := Get_Dll_Function_Adress(hDll,'Get_Display_Object_Path_In_Banner',AFilePath);
  @Get_Copy_Resources := Get_Dll_Function_Adress(hDll,'Get_Copy_Resources',AFilePath);
  @Get_Date_Format := Get_Dll_Function_Adress(hDll,'Get_Date_Format',AFilePath);
  @Get_Date_and_Time_Format := Get_Dll_Function_Adress(hDll,'Get_Date_and_Time_Format',AFilePath);
  @Get_Display_Unit_In_Extractions := Get_Dll_Function_Adress(hDll,'Get_Display_Unit_In_Extractions',AFilePath);
  @Get_Close_Splashscreen := Get_Dll_Function_Adress(hDll,'Get_Close_Splashscreen',AFilePath);
  @Get_Secured_Mode := Get_Dll_Function_Adress(hDll,'Get_Secured_Mode',AFilePath);
  @DateToTXStr := Get_Dll_Function_Adress(hDll,'DateToTXStr',AFilePath);
  @DateTimeToTXStr := Get_Dll_Function_Adress(hDll,'DateTimeToTXStr',AFilePath);
  @Get_Nb_Max_Paths := Get_Dll_Function_Adress(hDll,'Get_Nb_Max_Paths',AFilePath);
  @Get_Nb_Max_Links_Displayed := Get_Dll_Function_Adress(hDll,'Get_Nb_Max_Links_Displayed',AFilePath);
  @Get_Nb_Max_Data_Displayed := Get_Dll_Function_Adress(hDll,'Get_Nb_Max_Data_Displayed',AFilePath);
  @Set_XLS_Models_Displayed := Get_Dll_Function_Adress(hDll,'Set_XLS_Models_Displayed',AFilePath);
  @Get_XLS_Models_Displayed := Get_Dll_Function_Adress(hDll,'Get_XLS_Models_Displayed',AFilePath);
  @Get_Use_RichText := Get_Dll_Function_Adress(hDll,'Get_Use_RichText',AFilePath);
  @Set_Extractions_Displayed := Get_Dll_Function_Adress(hDll,'Set_Extractions_Displayed',AFilePath);
  @Get_Extraction_Displayed := Get_Dll_Function_Adress(hDll,'Get_Extraction_Displayed',AFilePath);
  @SetForceCriterion_Win_Exportation := Get_Dll_Function_Adress(hDll,'SetForceCriterion_Win_Exportation',AFilePath);
  @GetForceCriterion_Win_Exportation := Get_Dll_Function_Adress(hDll,'GetForceCriterion_Win_Exportation',AFilePath);
  @TxBeginTrans := Get_Dll_Function_Adress(hDll,'TxBeginTrans',AFilePath);
  @TxCommitTrans := Get_Dll_Function_Adress(hDll,'TxCommitTrans',AFilePath);
  @TxRollbackTrans := Get_Dll_Function_Adress(hDll,'TxRollbackTrans',AFilePath);
  @Extract_Icon := Get_Dll_Function_Adress(hDll,'Extract_Icon',AFilePath);
  @Get_IL_OT := Get_Dll_Function_Adress(hDll,'Get_IL_OT',AFilePath);
  @Load_Structure := Get_Dll_Function_Adress(hDll,'Load_Structure',AFilePath);
  @Initialize_Structure_Variables := Get_Dll_Function_Adress(hDll,'Initialize_Structure_Variables',AFilePath);
  @Get_Structure_Loaded := Get_Dll_Function_Adress(hDll,'Get_Structure_Loaded',AFilePath);
  @Get_Trash_Mode := Get_Dll_Function_Adress(hDll,'Get_Trash_Mode',AFilePath);
  @GetTxAPIContextOfUse := Get_Dll_Function_Adress(hDll,'GetTxAPIContextOfUse',AFilePath);
  @Get_IP_Client := Get_Dll_Function_Adress(hDll,'Get_IP_Client',AFilePath);
  @DisconnectActiveUser := Get_Dll_Function_Adress(hDll,'DisconnectActiveUser',AFilePath);
  @IsActiveUserAdministrator := Get_Dll_Function_Adress(hDll,'IsActiveUserAdministrator',AFilePath);
  @SetActiveUser := Get_Dll_Function_Adress(hDll,'SetActiveUser',AFilePath);
  @Get_Active_User_Name := Get_Dll_Function_Adress(hDll,'Get_Active_User_Name',AFilePath);
  @Get_Active_User_ID := Get_Dll_Function_Adress(hDll,'Get_Active_User_ID',AFilePath);
  @Get_Active_User_Login := Get_Dll_Function_Adress(hDll,'Get_Active_User_Login',AFilePath);
  @Get_Active_User_Last_Connection_Date := Get_Dll_Function_Adress(hDll,'Get_Active_User_Last_Connection_Date',AFilePath);
  @Get_Active_User_ID_Object := Get_Dll_Function_Adress(hDll,'Get_Active_User_ID_Object',AFilePath);
  @Get_Active_User_ID_Users_Group := Get_Dll_Function_Adress(hDll,'Get_Active_User_ID_Users_Group',AFilePath);
  @Get_URL_Online_Help := Get_Dll_Function_Adress(hDll,'Get_URL_Online_Help',AFilePath);
  @Get_Active_User_Function_Right := Get_Dll_Function_Adress(hDll,'Get_Active_User_Function_Right',AFilePath);
  @Get_Active_User_Password := Get_Dll_Function_Adress(hDll,'Get_Active_User_Password',AFilePath);
  @Update_Active_User_Password := Get_Dll_Function_Adress(hDll,'Update_Active_User_Password',AFilePath);
  @Authenticate := Get_Dll_Function_Adress(hDll,'Authenticate',AFilePath);
  @Get_TxStrFieldMaxSize := Get_Dll_Function_Adress(hDll,'Get_TxStrFieldMaxSize',AFilePath);
  @Get_Archived_File_DB_Type := Get_Dll_Function_Adress(hDll,'Get_Archived_File_DB_Type',AFilePath);
  @Get_Nbre_Licences_Administration := Get_Dll_Function_Adress(hDll,'Get_Nbre_Licences_Administration',AFilePath);
  @Get_Nbre_Licences_Modification := Get_Dll_Function_Adress(hDll,'Get_Nbre_Licences_Modification',AFilePath);
  @Get_DB_Type := Get_Dll_Function_Adress(hDll,'Get_DB_Type',AFilePath);
  @Get_Nbre_Licences_Lecture := Get_Dll_Function_Adress(hDll,'Get_Nbre_Licences_Lecture',AFilePath);
  @Get_Licence_Extraction := Get_Dll_Function_Adress(hDll,'Get_Licence_Extraction',AFilePath);
  @Get_Licence_FullTextSearch := Get_Dll_Function_Adress(hDll,'Get_Licence_FullTextSearch',AFilePath);
  @Get_Licence_Selection := Get_Dll_Function_Adress(hDll,'Get_Licence_Selection',AFilePath);
  @Get_Licence_Calculs := Get_Dll_Function_Adress(hDll,'Get_Licence_Calculs',AFilePath);
  @Get_Licence_Traitements_Statistiques := Get_Dll_Function_Adress(hDll,'Get_Licence_Traitements_Statistiques',AFilePath);
  @Get_Licence_Authentification_Windows := Get_Dll_Function_Adress(hDll,'Get_Licence_Authentification_Windows',AFilePath);
  @Get_Licence_API := Get_Dll_Function_Adress(hDll,'Get_Licence_API',AFilePath);
  @Get_Licence_Multilinguisme := Get_Dll_Function_Adress(hDll,'Get_Licence_Multilinguisme',AFilePath);
  @Get_Path_File_TxWebComponents_DLL := Get_Dll_Function_Adress(hDll,'Get_Path_File_TxWebComponents_DLL',AFilePath);
  @Get_Path_File_TxWebForm_DLL := Get_Dll_Function_Adress(hDll,'Get_Path_File_TxWebForm_DLL',AFilePath);
  @Get_Path_File_TxWebExportation_DLL := Get_Dll_Function_Adress(hDll,'Get_Path_File_TxWebExportation_DLL',AFilePath);
  @Get_Path_File_TxContextVariables_DLL := Get_Dll_Function_Adress(hDll,'Get_Path_File_TxContextVariables_DLL',AFilePath);
  @GetTxLogFilePathin_DLL := Get_Dll_Function_Adress(hDll,'GetTxLogFilePathin_DLL',AFilePath);
  @Get_TEEXMA_Title := Get_Dll_Function_Adress(hDll,'Get_TEEXMA_Title',AFilePath);
  @Get_Administration_Title := Get_Dll_Function_Adress(hDll,'Get_Administration_Title',AFilePath);
  @Get_Short_Description := Get_Dll_Function_Adress(hDll,'Get_Short_Description',AFilePath);
  @Get_Dir_Win := Get_Dll_Function_Adress(hDll,'Get_Dir_Win',AFilePath);
  @Get_Dir_Web := Get_Dll_Function_Adress(hDll,'Get_Dir_Web',AFilePath);
  @Get_Dir_WebPictures := Get_Dll_Function_Adress(hDll,'Get_Dir_WebPictures',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Browsing_History'}
  @Retrieve_Next_Browsing_History := Get_Dll_Function_Adress(hDll,'Retrieve_Next_Browsing_History',AFilePath);
  @Retrieve_Prev_Browsing_History := Get_Dll_Function_Adress(hDll,'Retrieve_Prev_Browsing_History',AFilePath);
  @Update_Browsing_History := Get_Dll_Function_Adress(hDll,'Update_Browsing_History',AFilePath);
  @Check_Next_Browsing_History := Get_Dll_Function_Adress(hDll,'Check_Next_Browsing_History',AFilePath);
  @Check_Prev_Browsing_History := Get_Dll_Function_Adress(hDll,'Check_Prev_Browsing_History',AFilePath);
  @Reset_Browsing_History := Get_Dll_Function_Adress(hDll,'Reset_Browsing_History',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Tmp_Table'}
  @_TmpTable := Get_Dll_Function_Adress(hDll,'_TmpTable',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Log_TXAPI'}
  @Test_TxExcept := Get_Dll_Function_Adress(hDll,'Test_TxExcept',AFilePath);
  @GetTxLogFilePath := Get_Dll_Function_Adress(hDll,'GetTxLogFilePath',AFilePath);
  @IsTxLogNeeded := Get_Dll_Function_Adress(hDll,'IsTxLogNeeded',AFilePath);
  @GetTxLogDir := Get_Dll_Function_Adress(hDll,'GetTxLogDir',AFilePath);
  @GetTxLogErrorsDir := Get_Dll_Function_Adress(hDll,'GetTxLogErrorsDir',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Web'}
  @IsWeb := Get_Dll_Function_Adress(hDll,'IsWeb',AFilePath);
  @Initialize_WEBClient_Settings := Get_Dll_Function_Adress(hDll,'Initialize_WEBClient_Settings',AFilePath);
  @Initialize_WEB_Settings := Get_Dll_Function_Adress(hDll,'Initialize_WEB_Settings',AFilePath);
  @Get_URL_TEEXMA := Get_Dll_Function_Adress(hDll,'Get_URL_TEEXMA',AFilePath);
  @Get_IISApplicationName := Get_Dll_Function_Adress(hDll,'Get_IISApplicationName',AFilePath);
  @Get_RUrl_Tmp := Get_Dll_Function_Adress(hDll,'Get_RUrl_Tmp',AFilePath);
  @Get_Url_Tmp := Get_Dll_Function_Adress(hDll,'Get_Url_Tmp',AFilePath);
  @Get_URL_Web_Interface_Temp := Get_Dll_Function_Adress(hDll,'Get_URL_Web_Interface_Temp',AFilePath);
  @Get_User_Session_ID := Get_Dll_Function_Adress(hDll,'Get_User_Session_ID',AFilePath);
  @Get_Max_Size_Upload := Get_Dll_Function_Adress(hDll,'Get_Max_Size_Upload',AFilePath);
  {$ENDREGION}

  {$REGION 'U_UTC'}
  @TxNow := Get_Dll_Function_Adress(hDll,'TxNow',AFilePath);
  @TxUTCToDateTime := Get_Dll_Function_Adress(hDll,'TxUTCToDateTime',AFilePath);
  @TxDateTimeToUTC := Get_Dll_Function_Adress(hDll,'TxDateTimeToUTC',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Attribute_Set_Manager'}
  @Create_OL_Attribute_Set_Filtered_On_Link_Attribute := Get_Dll_Function_Adress(hDll,'Create_OL_Attribute_Set_Filtered_On_Link_Attribute',AFilePath);
  @Create_OL_Attribute_Set_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Attribute_Set_Filtered',AFilePath);
  @Get_Attribute_Set_Level_From_Attribute := Get_Dll_Function_Adress(hDll,'Get_Attribute_Set_Level_From_Attribute',AFilePath);
  @Create_OL_Attribute_From_OL_Level := Get_Dll_Function_Adress(hDll,'Create_OL_Attribute_From_OL_Level',AFilePath);
  @Load_Attributes_Sets := Get_Dll_Function_Adress(hDll,'Load_Attributes_Sets',AFilePath);
  @Get_OL_Attribute_Set := Get_Dll_Function_Adress(hDll,'Get_OL_Attribute_Set',AFilePath);
  @Get_OL_Duplication_Settings := Get_Dll_Function_Adress(hDll,'Get_OL_Duplication_Settings',AFilePath);
  @Get_OL_Deletion_Settings := Get_Dll_Function_Adress(hDll,'Get_OL_Deletion_Settings',AFilePath);
  @Get_OL_Advanced_Creation := Get_Dll_Function_Adress(hDll,'Get_OL_Advanced_Creation',AFilePath);
  @Get_OL_Advanced_Comparison := Get_Dll_Function_Adress(hDll,'Get_OL_Advanced_Comparison',AFilePath);
  @Get_Advanced_Creation_Settings_ID_OT := Get_Dll_Function_Adress(hDll,'Get_Advanced_Creation_Settings_ID_OT',AFilePath);
  @Get_Advanced_Comparison_Settings := Get_Dll_Function_Adress(hDll,'Get_Advanced_Comparison_Settings',AFilePath);
  @GetDefaultIdAdvancedCreation := Get_Dll_Function_Adress(hDll,'GetDefaultIdAdvancedCreation',AFilePath);
  @Check_Attribute_Set_Existence := Get_Dll_Function_Adress(hDll,'Check_Attribute_Set_Existence',AFilePath);
  @Get_Attribute_Set := Get_Dll_Function_Adress(hDll,'Get_Attribute_Set',AFilePath);
  @Get_Attribute_Set_Name := Get_Dll_Function_Adress(hDll,'Get_Attribute_Set_Name',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Objects_Manager'}
  @Create_Object_Manager := Get_Dll_Function_Adress(hDll,'Create_Object_Manager',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Importation'}
  @Import_XML_File := Get_Dll_Function_Adress(hDll,'Import_XML_File',AFilePath);
  @Import_XML_Flow := Get_Dll_Function_Adress(hDll,'Import_XML_Flow',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_Manager'}
  @Create_Data_Manager := Get_Dll_Function_Adress(hDll,'Create_Data_Manager',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Extraction_Manager'}
  @Get_Extraction_Type_Name := Get_Dll_Function_Adress(hDll,'Get_Extraction_Type_Name',AFilePath);
  @Extract_Objects := Get_Dll_Function_Adress(hDll,'Extract_Objects',AFilePath);
  @WordDocumentToPDF := Get_Dll_Function_Adress(hDll,'WordDocumentToPDF',AFilePath);
  @Check_PDFPrinter_Availability := Get_Dll_Function_Adress(hDll,'Check_PDFPrinter_Availability',AFilePath);
  @Get_OL_Extraction := Get_Dll_Function_Adress(hDll,'Get_OL_Extraction',AFilePath);
  @Create_OL_Extraction := Get_Dll_Function_Adress(hDll,'Create_OL_Extraction',AFilePath);
  @Get_Extraction_Name := Get_Dll_Function_Adress(hDll,'Get_Extraction_Name',AFilePath);
  @Get_Extraction := Get_Dll_Function_Adress(hDll,'Get_Extraction',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Log_Manager'}
  @Create_Log_Manager := Get_Dll_Function_Adress(hDll,'Create_Log_Manager',AFilePath);
  @logAction := Get_Dll_Function_Adress(hDll,'logAction',AFilePath);
  @Get_DBLog_Nb_Actions := Get_Dll_Function_Adress(hDll,'Get_DBLog_Nb_Actions',AFilePath);
  @Clean_DBLog := Get_Dll_Function_Adress(hDll,'Clean_DBLog',AFilePath);
  @Load_DBLogs := Get_Dll_Function_Adress(hDll,'Load_DBLogs',AFilePath);
  @Get_OL_DBLog := Get_Dll_Function_Adress(hDll,'Get_OL_DBLog',AFilePath);
  @Initialize_DBLogs := Get_Dll_Function_Adress(hDll,'Initialize_DBLogs',AFilePath);
  @Get_DBLog_Name := Get_Dll_Function_Adress(hDll,'Get_DBLog_Name',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Equivalence_Manager'}
  @Create_OL_Sub_Equivalence := Get_Dll_Function_Adress(hDll,'Create_OL_Sub_Equivalence',AFilePath);
  @Get_Equivalence_From_Left := Get_Dll_Function_Adress(hDll,'Get_Equivalence_From_Left',AFilePath);
  @Get_Equivalence_Set_Name := Get_Dll_Function_Adress(hDll,'Get_Equivalence_Set_Name',AFilePath);
  @Get_Equivalence_Set := Get_Dll_Function_Adress(hDll,'Get_Equivalence_Set',AFilePath);
  @Check_Equivalence_Set_Existence := Get_Dll_Function_Adress(hDll,'Check_Equivalence_Set_Existence',AFilePath);
  @Create_Equivalence_Set := Get_Dll_Function_Adress(hDll,'Create_Equivalence_Set',AFilePath);
  @Create_OL_Equivalence_Set := Get_Dll_Function_Adress(hDll,'Create_OL_Equivalence_Set',AFilePath);
  @Get_Equivalences_Set_OL_Equivalence := Get_Dll_Function_Adress(hDll,'Get_Equivalences_Set_OL_Equivalence',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Data_File_Functions'}
  @Create_Data_File_For_Reference := Get_Dll_Function_Adress(hDll,'Create_Data_File_For_Reference',AFilePath);
  @Get_Data_ID_Archived_File := Get_Dll_Function_Adress(hDll,'Get_Data_ID_Archived_File',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Objects_Functions'}
  @Create_Object := Get_Dll_Function_Adress(hDll,'Create_Object',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Tag_Manager'}
  @Reset_TaggedTxConcepts := Get_Dll_Function_Adress(hDll,'Reset_TaggedTxConcepts',AFilePath);
  @Get_Object_Name_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Object_Name_From_Tag',AFilePath);
  @Get_ID_Object_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Object_From_Tag',AFilePath);
  @Get_Object_FirstTag := Get_Dll_Function_Adress(hDll,'Get_Object_FirstTag',AFilePath);
  @CheckIf_Object_Tagged := Get_Dll_Function_Adress(hDll,'CheckIf_Object_Tagged',AFilePath);
  @Get_Attribute_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Attribute_From_Tag',AFilePath);
  @Get_ID_Attribute_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Attribute_From_Tag',AFilePath);
  @Get_ID_Object_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Object_Type_From_Tag',AFilePath);
  @Get_Attribute_Set_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Attribute_Set_From_Tag',AFilePath);
  @Get_OT_Tags := Get_Dll_Function_Adress(hDll,'Get_OT_Tags',AFilePath);
  @Get_Advanced_Creation_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Advanced_Creation_From_Tag',AFilePath);
  @Get_Advanced_Duplication_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Advanced_Duplication_From_Tag',AFilePath);
  @Get_Advanced_Comparison_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Advanced_Comparison_From_Tag',AFilePath);
  @Get_Advanced_Deletion_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Advanced_Deletion_From_Tag',AFilePath);
  @Get_ID_Advanced_Creation_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Advanced_Creation_From_Tag',AFilePath);
  @Get_ID_Advanced_Comparison_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Advanced_Comparison_From_Tag',AFilePath);
  @Get_ID_Advanced_Duplication_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Advanced_Duplication_From_Tag',AFilePath);
  @Get_ID_Advanced_Deletion_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Advanced_Deletion_From_Tag',AFilePath);
  @Get_Unit_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Unit_From_Tag',AFilePath);
  @Get_Exportation_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Exportation_From_Tag',AFilePath);
  @Get_Extraction_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Extraction_From_Tag',AFilePath);
  @Get_Object_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Object_Type_From_Tag',AFilePath);
  @Get_Table_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Table_Type_From_Tag',AFilePath);
  @Get_ID_Table_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Table_Type_From_Tag',AFilePath);
  @Get_ID_Unit_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Unit_From_Tag',AFilePath);
  @Get_ID_Attribute_Set_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Attribute_Set_From_Tag',AFilePath);
  @Get_ID_Exportation_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Exportation_From_Tag',AFilePath);
  @Get_ID_Extraction_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Extraction_From_Tag',AFilePath);
  @Get_TaggedTxConceptID := Get_Dll_Function_Adress(hDll,'Get_TaggedTxConceptID',AFilePath);
  @TagToID := Get_Dll_Function_Adress(hDll,'TagToID',AFilePath);
  @Tag_TxConcept := Get_Dll_Function_Adress(hDll,'Tag_TxConcept',AFilePath);
  @CheckIf_Tag_Available := Get_Dll_Function_Adress(hDll,'CheckIf_Tag_Available',AFilePath);
  @Get_ID_Choice_Guide_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Choice_Guide_From_Tag',AFilePath);
  @Get_Choice_Guide_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Choice_Guide_From_Tag',AFilePath);
  @Get_ID_Series_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Series_Type_From_Tag',AFilePath);
  @Get_Series_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Series_Type_From_Tag',AFilePath);
  @Get_ID_Users_Group_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Users_Group_From_Tag',AFilePath);
  @Get_Users_Group_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Users_Group_From_Tag',AFilePath);
  @Get_ID_Equivalences_Set_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Equivalences_Set_From_Tag',AFilePath);
  @Get_Equivalences_Set_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Equivalences_Set_From_Tag',AFilePath);
  @Get_ID_File_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_File_Type_From_Tag',AFilePath);
  @Get_File_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_File_Type_From_Tag',AFilePath);
  @Get_ID_Link_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Link_Type_From_Tag',AFilePath);
  @Get_Link_Type_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Link_Type_From_Tag',AFilePath);
  @Get_ID_Language_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Language_From_Tag',AFilePath);
  @Get_Language_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Language_From_Tag',AFilePath);
  @Get_ID_Log_From_Tag := Get_Dll_Function_Adress(hDll,'Get_ID_Log_From_Tag',AFilePath);
  @Get_Log_From_Tag := Get_Dll_Function_Adress(hDll,'Get_Log_From_Tag',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Object_Data_Functions'}
  @Create_Object_Data_From_Object := Get_Dll_Function_Adress(hDll,'Create_Object_Data_From_Object',AFilePath);
  @Create_Object_Data_From_Tab := Get_Dll_Function_Adress(hDll,'Create_Object_Data_From_Tab',AFilePath);
  @Update_Object_Data := Get_Dll_Function_Adress(hDll,'Update_Object_Data',AFilePath);
  @Create_Object_Data_From_Attribute_Set := Get_Dll_Function_Adress(hDll,'Create_Object_Data_From_Attribute_Set',AFilePath);
  @Create_OL_Object_Data_From_Path := Get_Dll_Function_Adress(hDll,'Create_OL_Object_Data_From_Path',AFilePath);
  @Create_OL_Object_Data_From_Attribute := Get_Dll_Function_Adress(hDll,'Create_OL_Object_Data_From_Attribute',AFilePath);
  @Sort_OL_Object_Data := Get_Dll_Function_Adress(hDll,'Sort_OL_Object_Data',AFilePath);
  @Create_OL_Object_Data_From_Attribute_Set := Get_Dll_Function_Adress(hDll,'Create_OL_Object_Data_From_Attribute_Set',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Lockings_Manager'}
  @Prepare_CheckOut := Get_Dll_Function_Adress(hDll,'Prepare_CheckOut',AFilePath);
  @CheckOut := Get_Dll_Function_Adress(hDll,'CheckOut',AFilePath);
  @Prepare_CheckIn := Get_Dll_Function_Adress(hDll,'Prepare_CheckIn',AFilePath);
  @CheckIn := Get_Dll_Function_Adress(hDll,'CheckIn',AFilePath);
  @Remove_Unrelevant_Lockings := Get_Dll_Function_Adress(hDll,'Remove_Unrelevant_Lockings',AFilePath);
  @CheckIf_Object_Locked := Get_Dll_Function_Adress(hDll,'CheckIf_Object_Locked',AFilePath);
  @Locking_TypeToStr := Get_Dll_Function_Adress(hDll,'Locking_TypeToStr',AFilePath);
  @Lock_Object := Get_Dll_Function_Adress(hDll,'Lock_Object',AFilePath);
  @Handle_Automatic_Unlocking := Get_Dll_Function_Adress(hDll,'Handle_Automatic_Unlocking',AFilePath);
  @Unlock_Object := Get_Dll_Function_Adress(hDll,'Unlock_Object',AFilePath);
  @Create_OL_Locking := Get_Dll_Function_Adress(hDll,'Create_OL_Locking',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Attribute_Filters_Manager'}
  @Get_Attribute_Filter := Get_Dll_Function_Adress(hDll,'Get_Attribute_Filter',AFilePath);
  {$ENDREGION}

  {$REGION 'U_SolR'}
  @Get_ExternalServersToIndexCount := Get_Dll_Function_Adress(hDll,'Get_ExternalServersToIndexCount',AFilePath);
  @Get_OL_ExternalServersToIndex := Get_Dll_Function_Adress(hDll,'Get_OL_ExternalServersToIndex',AFilePath);
  @IsTextSearchInFilesActive := Get_Dll_Function_Adress(hDll,'IsTextSearchInFilesActive',AFilePath);
  @Get_SolRUrl := Get_Dll_Function_Adress(hDll,'Get_SolRUrl',AFilePath);
  @Get_SolRDir := Get_Dll_Function_Adress(hDll,'Get_SolRDir',AFilePath);
  @IsTextSearchInExternalServersActive := Get_Dll_Function_Adress(hDll,'IsTextSearchInExternalServersActive',AFilePath);
  @Get_UrlSolRForExternalServers := Get_Dll_Function_Adress(hDll,'Get_UrlSolRForExternalServers',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Units_Manager'}
  @Convert_Value := Get_Dll_Function_Adress(hDll,'Convert_Value',AFilePath);
  @Convert_DValue := Get_Dll_Function_Adress(hDll,'Convert_DValue',AFilePath);
  @Create_OL_Conversion_From_Unit := Get_Dll_Function_Adress(hDll,'Create_OL_Conversion_From_Unit',AFilePath);
  @Get_Conversion := Get_Dll_Function_Adress(hDll,'Get_Conversion',AFilePath);
  @Get_Unit_Name := Get_Dll_Function_Adress(hDll,'Get_Unit_Name',AFilePath);
  @Get_Conversion_Name := Get_Dll_Function_Adress(hDll,'Get_Conversion_Name',AFilePath);
  @Get_OL_Unit := Get_Dll_Function_Adress(hDll,'Get_OL_Unit',AFilePath);
  @Get_OL_Conversion := Get_Dll_Function_Adress(hDll,'Get_OL_Conversion',AFilePath);
  @Get_Unit := Get_Dll_Function_Adress(hDll,'Get_Unit',AFilePath);
  @Get_ID_Unit_From_Name := Get_Dll_Function_Adress(hDll,'Get_ID_Unit_From_Name',AFilePath);
  @Get_Unit_Nb_Attributes := Get_Dll_Function_Adress(hDll,'Get_Unit_Nb_Attributes',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Files_Types_Manager'}
  @Get_OL_File_Type := Get_Dll_Function_Adress(hDll,'Get_OL_File_Type',AFilePath);
  @Get_File_Type := Get_Dll_Function_Adress(hDll,'Get_File_Type',AFilePath);
  @Get_File_Type_FIT := Get_Dll_Function_Adress(hDll,'Get_File_Type_FIT',AFilePath);
  @Get_File_Type_Name := Get_Dll_Function_Adress(hDll,'Get_File_Type_Name',AFilePath);
  @Get_File_Type_RDir := Get_Dll_Function_Adress(hDll,'Get_File_Type_RDir',AFilePath);
  @Get_File_Type_Read_Only := Get_Dll_Function_Adress(hDll,'Get_File_Type_Read_Only',AFilePath);
  @Get_Attribute_File_Type := Get_Dll_Function_Adress(hDll,'Get_Attribute_File_Type',AFilePath);
  @Get_File_Type_Nb_Attributes := Get_Dll_Function_Adress(hDll,'Get_File_Type_Nb_Attributes',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Tables_Types_Manager'}
  @Get_OL_Table_Type := Get_Dll_Function_Adress(hDll,'Get_OL_Table_Type',AFilePath);
  @Get_Series_Type := Get_Dll_Function_Adress(hDll,'Get_Series_Type',AFilePath);
  @Get_Series_Type_Name_Complete := Get_Dll_Function_Adress(hDll,'Get_Series_Type_Name_Complete',AFilePath);
  @Get_Series_Type_Name := Get_Dll_Function_Adress(hDll,'Get_Series_Type_Name',AFilePath);
  @Get_Series_Type_ID_Table_Type := Get_Dll_Function_Adress(hDll,'Get_Series_Type_ID_Table_Type',AFilePath);
  @Get_Series_Type_ID_Unit := Get_Dll_Function_Adress(hDll,'Get_Series_Type_ID_Unit',AFilePath);
  @Get_Table_Type := Get_Dll_Function_Adress(hDll,'Get_Table_Type',AFilePath);
  @Get_Table_Type_OL_Series_Type := Get_Dll_Function_Adress(hDll,'Get_Table_Type_OL_Series_Type',AFilePath);
  @Get_Table_Type_Name := Get_Dll_Function_Adress(hDll,'Get_Table_Type_Name',AFilePath);
  @Get_Table_Type_Nb_Attributes := Get_Dll_Function_Adress(hDll,'Get_Table_Type_Nb_Attributes',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Objects_Types_Manager'}
  @Get_OL_OT := Get_Dll_Function_Adress(hDll,'Get_OL_OT',AFilePath);
  @Get_OT_Source := Get_Dll_Function_Adress(hDll,'Get_OT_Source',AFilePath);
  @Get_OT_Task := Get_Dll_Function_Adress(hDll,'Get_OT_Task',AFilePath);
  @Get_OT_Task_Notification_Type := Get_Dll_Function_Adress(hDll,'Get_OT_Task_Notification_Type',AFilePath);
  @Get_OT_Library := Get_Dll_Function_Adress(hDll,'Get_OT_Library',AFilePath);
  @Get_OT_Information := Get_Dll_Function_Adress(hDll,'Get_OT_Information',AFilePath);
  @Get_OT_Portal := Get_Dll_Function_Adress(hDll,'Get_OT_Portal',AFilePath);
  @Get_OT_User := Get_Dll_Function_Adress(hDll,'Get_OT_User',AFilePath);
  @Get_OL_OT_Standard := Get_Dll_Function_Adress(hDll,'Get_OL_OT_Standard',AFilePath);
  @Get_OL_OT_Standard_Invisible := Get_Dll_Function_Adress(hDll,'Get_OL_OT_Standard_Invisible',AFilePath);
  @Get_OL_OT_Standard_Visible := Get_Dll_Function_Adress(hDll,'Get_OL_OT_Standard_Visible',AFilePath);
  @Get_OL_OT_Associative := Get_Dll_Function_Adress(hDll,'Get_OL_OT_Associative',AFilePath);
  @Get_OL_OT_Listing := Get_Dll_Function_Adress(hDll,'Get_OL_OT_Listing',AFilePath);
  @Get_OT_Associativity := Get_Dll_Function_Adress(hDll,'Get_OT_Associativity',AFilePath);
  @Get_OT_Locking_Type := Get_Dll_Function_Adress(hDll,'Get_OT_Locking_Type',AFilePath);
  @Get_OT_Icon := Get_Dll_Function_Adress(hDll,'Get_OT_Icon',AFilePath);
  @Get_OT := Get_Dll_Function_Adress(hDll,'Get_OT',AFilePath);
  @Check_OT_Existence := Get_Dll_Function_Adress(hDll,'Check_OT_Existence',AFilePath);
  @Get_ID_OT_Source := Get_Dll_Function_Adress(hDll,'Get_ID_OT_Source',AFilePath);
  @Get_ID_OT_Information := Get_Dll_Function_Adress(hDll,'Get_ID_OT_Information',AFilePath);
  @Get_ID_OT_User := Get_Dll_Function_Adress(hDll,'Get_ID_OT_User',AFilePath);
  @Get_ID_OT_Portal := Get_Dll_Function_Adress(hDll,'Get_ID_OT_Portal',AFilePath);
  @Get_ID_OT_Project := Get_Dll_Function_Adress(hDll,'Get_ID_OT_Project',AFilePath);
  @Get_ID_OT_Task := Get_Dll_Function_Adress(hDll,'Get_ID_OT_Task',AFilePath);
  @Get_ID_OT_Task_Notification_Type := Get_Dll_Function_Adress(hDll,'Get_ID_OT_Task_Notification_Type',AFilePath);
  @Get_ID_OT_Library := Get_Dll_Function_Adress(hDll,'Get_ID_OT_Library',AFilePath);
  @Get_OT_OL_Tab := Get_Dll_Function_Adress(hDll,'Get_OT_OL_Tab',AFilePath);
  @Get_OT_OL_Attribute := Get_Dll_Function_Adress(hDll,'Get_OT_OL_Attribute',AFilePath);
  @Get_OT_Nb_Attributes := Get_Dll_Function_Adress(hDll,'Get_OT_Nb_Attributes',AFilePath);
  @Get_OT_Right := Get_Dll_Function_Adress(hDll,'Get_OT_Right',AFilePath);
  @Get_OT_Type := Get_Dll_Function_Adress(hDll,'Get_OT_Type',AFilePath);
  @Get_OT_Hint := Get_Dll_Function_Adress(hDll,'Get_OT_Hint',AFilePath);
  @Get_OT_Name := Get_Dll_Function_Adress(hDll,'Get_OT_Name',AFilePath);
  @Get_OT_Nb_Objects := Get_Dll_Function_Adress(hDll,'Get_OT_Nb_Objects',AFilePath);
  @CheckIf_OT_Extractable := Get_Dll_Function_Adress(hDll,'CheckIf_OT_Extractable',AFilePath);
  @Get_OT_Folder := Get_Dll_Function_Adress(hDll,'Get_OT_Folder',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Attributes_Manager'}
  @Get_Attribute_Clickability := Get_Dll_Function_Adress(hDll,'Get_Attribute_Clickability',AFilePath);
  @Retrieve_Link_Attribute_Informations := Get_Dll_Function_Adress(hDll,'Retrieve_Link_Attribute_Informations',AFilePath);
  @Get_Attribute_From_ID_Object_Information := Get_Dll_Function_Adress(hDll,'Get_Attribute_From_ID_Object_Information',AFilePath);
  @Get_Attribute := Get_Dll_Function_Adress(hDll,'Get_Attribute',AFilePath);
  @CheckIf_Link_Attribute := Get_Dll_Function_Adress(hDll,'CheckIf_Link_Attribute',AFilePath);
  @CheckIf_File_Attribute := Get_Dll_Function_Adress(hDll,'CheckIf_File_Attribute',AFilePath);
  @CheckIf_Numerical_Attribute := Get_Dll_Function_Adress(hDll,'CheckIf_Numerical_Attribute',AFilePath);
  @CheckIf_String_Attribute := Get_Dll_Function_Adress(hDll,'CheckIf_String_Attribute',AFilePath);
  @Check_Attribute_Data_Type := Get_Dll_Function_Adress(hDll,'Check_Attribute_Data_Type',AFilePath);
  @Check_Attribute_Existence := Get_Dll_Function_Adress(hDll,'Check_Attribute_Existence',AFilePath);
  @Get_Attribute_TD := Get_Dll_Function_Adress(hDll,'Get_Attribute_TD',AFilePath);
  @Get_Attribute_Name := Get_Dll_Function_Adress(hDll,'Get_Attribute_Name',AFilePath);
  @Get_Attribute_Hint := Get_Dll_Function_Adress(hDll,'Get_Attribute_Hint',AFilePath);
  @Get_Attribute_List := Get_Dll_Function_Adress(hDll,'Get_Attribute_List',AFilePath);
  @Get_Attribute_ID_Tab := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Tab',AFilePath);
  @Get_Attribute_ID_File_Type := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_File_Type',AFilePath);
  @Get_Attribute_ID_Unit := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Unit',AFilePath);
  @Get_Attribute_ID_Table_Type := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Table_Type',AFilePath);
  @Get_Attribute_Table_Type := Get_Dll_Function_Adress(hDll,'Get_Attribute_Table_Type',AFilePath);
  @Get_Attribute_OL_Series_Type := Get_Dll_Function_Adress(hDll,'Get_Attribute_OL_Series_Type',AFilePath);
  @Get_Attribute_ID_OT_Destination := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_OT_Destination',AFilePath);
  @Get_Ass_Attribute_ID_Right_Link_Type := Get_Dll_Function_Adress(hDll,'Get_Ass_Attribute_ID_Right_Link_Type',AFilePath);
  @Get_Ass_Attribute_ID_Left_Link_Type := Get_Dll_Function_Adress(hDll,'Get_Ass_Attribute_ID_Left_Link_Type',AFilePath);
  @Get_Ass_Attribute_ID_Right_Attribute := Get_Dll_Function_Adress(hDll,'Get_Ass_Attribute_ID_Right_Attribute',AFilePath);
  @Get_Ass_Attribute_ID_Left_Attribute := Get_Dll_Function_Adress(hDll,'Get_Ass_Attribute_ID_Left_Attribute',AFilePath);
  @Get_Ass_Attribute_ID_OT_Associative := Get_Dll_Function_Adress(hDll,'Get_Ass_Attribute_ID_OT_Associative',AFilePath);
  @Get_OL_Associative_Attribute := Get_Dll_Function_Adress(hDll,'Get_OL_Associative_Attribute',AFilePath);
  @Get_Ass_Attribute_ID_OT_Left := Get_Dll_Function_Adress(hDll,'Get_Ass_Attribute_ID_OT_Left',AFilePath);
  @Get_Ass_Attribute_ID_OT_Right := Get_Dll_Function_Adress(hDll,'Get_Ass_Attribute_ID_OT_Right',AFilePath);
  @Get_Attribute_Absolute_Order := Get_Dll_Function_Adress(hDll,'Get_Attribute_Absolute_Order',AFilePath);
  @Get_Attribute_ID_Object_Information := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Object_Information',AFilePath);
  @Get_OL_Attribute_Table_Using_Excel := Get_Dll_Function_Adress(hDll,'Get_OL_Attribute_Table_Using_Excel',AFilePath);
  @Get_Attribute_ID_Attribute_Set_Filtering := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Attribute_Set_Filtering',AFilePath);
  @Get_Attribute_Attribute_Set_Filtering := Get_Dll_Function_Adress(hDll,'Get_Attribute_Attribute_Set_Filtering',AFilePath);
  @Get_Attribute_ID_OT_Source := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_OT_Source',AFilePath);
  @Get_Attribute_ID_OT := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_OT',AFilePath);
  @Get_Attribute_ID_LT := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_LT',AFilePath);
  @Get_Attribute_Multiplicity := Get_Dll_Function_Adress(hDll,'Get_Attribute_Multiplicity',AFilePath);
  @Get_Attribute_Multiplicity_Inverse_Link := Get_Dll_Function_Adress(hDll,'Get_Attribute_Multiplicity_Inverse_Link',AFilePath);
  @Get_Attribute_Inverse := Get_Dll_Function_Adress(hDll,'Get_Attribute_Inverse',AFilePath);
  @Get_Attribute_ID_Object_Filtering := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Object_Filtering',AFilePath);
  @Get_Attribute_Transpose := Get_Dll_Function_Adress(hDll,'Get_Attribute_Transpose',AFilePath);
  @Get_Attribute_Inherited := Get_Dll_Function_Adress(hDll,'Get_Attribute_Inherited',AFilePath);
  @Get_Attribute_ID_Attribute_Lnk_Inheritage := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Attribute_Lnk_Inheritage',AFilePath);
  @Get_Attribute_ID_Attribute_Inheritage := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Attribute_Inheritage',AFilePath);
  @Get_Attribute_Associativity := Get_Dll_Function_Adress(hDll,'Get_Attribute_Associativity',AFilePath);
  @Get_OL_Attribute_Complete := Get_Dll_Function_Adress(hDll,'Get_OL_Attribute_Complete',AFilePath);
  @Get_Attribute_ID_Parent := Get_Dll_Function_Adress(hDll,'Get_Attribute_ID_Parent',AFilePath);
  @Check_Attribute_Object_Type := Get_Dll_Function_Adress(hDll,'Check_Attribute_Object_Type',AFilePath);
  @Get_Attribute_SL_ID_Unit := Get_Dll_Function_Adress(hDll,'Get_Attribute_SL_ID_Unit',AFilePath);
  @RetrieveNumericalAttributeValues := Get_Dll_Function_Adress(hDll,'RetrieveNumericalAttributeValues',AFilePath);
  @Get_Attribute_Min_Value := Get_Dll_Function_Adress(hDll,'Get_Attribute_Min_Value',AFilePath);
  @Get_Attribute_Max_Value := Get_Dll_Function_Adress(hDll,'Get_Attribute_Max_Value',AFilePath);
  @Get_Attribute_Nb_Data := Get_Dll_Function_Adress(hDll,'Get_Attribute_Nb_Data',AFilePath);
  @Create_OL_Attribute_Filtered := Get_Dll_Function_Adress(hDll,'Create_OL_Attribute_Filtered',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Links_Types_Manager'}
  @Get_Link_Type_Filtering_Type := Get_Dll_Function_Adress(hDll,'Get_Link_Type_Filtering_Type',AFilePath);
  @Get_Link_Type_Research_Filtering := Get_Dll_Function_Adress(hDll,'Get_Link_Type_Research_Filtering',AFilePath);
  @Get_Link_Type_ID_Direct_Attribute := Get_Dll_Function_Adress(hDll,'Get_Link_Type_ID_Direct_Attribute',AFilePath);
  @Get_Link_Type_ID_Inv_Attribute := Get_Dll_Function_Adress(hDll,'Get_Link_Type_ID_Inv_Attribute',AFilePath);
  @Get_Link_Type_Direct_Attribute := Get_Dll_Function_Adress(hDll,'Get_Link_Type_Direct_Attribute',AFilePath);
  @Get_Link_Type_Inv_Attribute := Get_Dll_Function_Adress(hDll,'Get_Link_Type_Inv_Attribute',AFilePath);
  @Get_OL_Link_Type := Get_Dll_Function_Adress(hDll,'Get_OL_Link_Type',AFilePath);
  @Get_Link_Type := Get_Dll_Function_Adress(hDll,'Get_Link_Type',AFilePath);
  @Get_Link_Type_Name := Get_Dll_Function_Adress(hDll,'Get_Link_Type_Name',AFilePath);
  @Get_Link_Type_Associativity := Get_Dll_Function_Adress(hDll,'Get_Link_Type_Associativity',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Choices_Guides_Manager'}
  @Initialize_Choice_Guides := Get_Dll_Function_Adress(hDll,'Initialize_Choice_Guides',AFilePath);
  @Load_Choice_Guides := Get_Dll_Function_Adress(hDll,'Load_Choice_Guides',AFilePath);
  @Get_Choice_Guide := Get_Dll_Function_Adress(hDll,'Get_Choice_Guide',AFilePath);
  @Get_Choice_Guide_Name := Get_Dll_Function_Adress(hDll,'Get_Choice_Guide_Name',AFilePath);
  @Get_Question := Get_Dll_Function_Adress(hDll,'Get_Question',AFilePath);
  @Get_Question_Name := Get_Dll_Function_Adress(hDll,'Get_Question_Name',AFilePath);
  @Get_Choice_Guide_Loaded := Get_Dll_Function_Adress(hDll,'Get_Choice_Guide_Loaded',AFilePath);
  @Get_OL_Choice_Guide := Get_Dll_Function_Adress(hDll,'Get_OL_Choice_Guide',AFilePath);
  {$ENDREGION}

  {$REGION 'U_Exportations_Manager'}
  @Get_OL_Exportation := Get_Dll_Function_Adress(hDll,'Get_OL_Exportation',AFilePath);
  @Get_Exportation := Get_Dll_Function_Adress(hDll,'Get_Exportation',AFilePath);
  @Get_Exportation_Name := Get_Dll_Function_Adress(hDll,'Get_Exportation_Name',AFilePath);
  {$ENDREGION}

  {$REGION 'U_RequirementsListHelper'}
  @_RequirementsList := Get_Dll_Function_Adress(hDll,'_RequirementsList',AFilePath);
  @GetRequirementsListName := Get_Dll_Function_Adress(hDll,'GetRequirementsListName',AFilePath);
  {$ENDREGION}

  {$REGION 'U_BusinessViewHelper'}
  @_BusinessView := Get_Dll_Function_Adress(hDll,'_BusinessView',AFilePath);
  @_BusinessObject := Get_Dll_Function_Adress(hDll,'_BusinessObject',AFilePath);
  {$ENDREGION}

  {$REGION 'U_ContextStringHelper'}
  @_ContextString := Get_Dll_Function_Adress(hDll,'_ContextString',AFilePath);
  {$ENDREGION}

  {$REGION 'U_ContextVariablesHelpers'}
  @_Constants := Get_Dll_Function_Adress(hDll,'_Constants',AFilePath);
  @_Variables := Get_Dll_Function_Adress(hDll,'_Variables',AFilePath);
  {$ENDREGION}

  {$REGION 'U_ObjectSettingsHelper'}
  @_ObjectSettings := Get_Dll_Function_Adress(hDll,'_ObjectSettings',AFilePath);
  {$ENDREGION}

  {$REGION 'U_ModelApplicationHelper'}
  @_ModelApplication := Get_Dll_Function_Adress(hDll,'_ModelApplication',AFilePath);
  @_Model := Get_Dll_Function_Adress(hDll,'_Model',AFilePath);
  @GetModelApplicationName := Get_Dll_Function_Adress(hDll,'GetModelApplicationName',AFilePath);
  @GetModelName := Get_Dll_Function_Adress(hDll,'GetModelName',AFilePath);
  {$ENDREGION}


end;

procedure Unload_TxAPI;
begin
  if hDll <> 0 then
  begin
    try
      FreeLibrary(hDll);
      hDll := 0;
    except
    end;
  end;
end;

function Get_Dll_TxAPI_Loaded: boolean;
begin
  result := (hDll>0)
end;

initialization
  hDll := 0;

finalization
  Unload_TxAPI;

end.