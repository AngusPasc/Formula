///<author>dev@bassetti.fr</author>
///<summary>Unit loading / unloading the dll named "LDAP". This file is generated by TXUtils. Do not modify.</summary>
unit U_Abstract_LDAP;
interface

uses
  SysUtils,Windows,U_Small_Lib;

type
  {$REGION 'U_Main_LDAP'}
  ///Base error class for all LDAP errors.
  ///The message may indicate the name of the function that returned a non successful result.
  ELDAP=class(ECoded_Error);

  ///Error occurring when the connection to the LDAP server cannot be done.
  ELDAP_Server_Not_Found=class(ELDAP);

  ///Error occuring when no DNS domain can be found.
  ELDAP_DNS_Domain_Not_Found=class(ELDAP);

  ///Error occuring when the password and login of a given user do not match.
  ELDAP_Bind_Failed=class(ELDAP);

  TSLDAP_Init=function(AActive_Directory: Boolean; APath: string; APort: Integer; ADNS_Domain: string; ALogin_App: string; APassword_App: string; AField_Login: string; var AMessage: string): Integer; stdcall;

  ///<summary>Function trying to bind a login and password.</summary>
  ///<param name="ALogin_User">The login of the user.</param>
  ///<param name="APassword_User">The password of the user.</param>
  ///<param name="AMessage">An error message in case the returned value is different from C_No_Error.</param>
  ///<returns>An error code equal to C_NO_ERROR in case of no error.</returns>
  TSLDAP_Bind=function(ALogin_User: string; APassword_User: string; var AMessage: string): Integer; stdcall;

  ///<summary>Function retrieving a field value in the LDAP.</summary>
  ///<param name="ALogin_User">The login of the user.</param>
  ///<param name="AField">The name of the field owning ALogin_User.</param>
  ///<param name="AValue">The value of the field returned as a string.</param>
  ///<param name="AMessage">An error message in case the returned value is different from C_No_Error.</param>
  ///<returns>An error code equal to C_NO_ERROR in case of no error.</returns>
  TSLDAP_Get_Infos=function(ALogin_User: string; AField: string; var AValue: string; var AMessage: string): Integer; stdcall;

  ///<summary>Function which test if user exists in directory.</summary>
  ///<param name="ALogin">The login of the user.</param>
  ///<returns>A boolean which indicate if the user exists or not</returns>
  TSLDAP_UserExist=function(const ALogin: string): Boolean; stdcall;
  {$ENDREGION}



var
  {$REGION 'U_Main_LDAP'}
  SLDAP_Init: TSLDAP_Init;
  SLDAP_Bind: TSLDAP_Bind;
  SLDAP_Get_Infos: TSLDAP_Get_Infos;
  SLDAP_UserExist: TSLDAP_UserExist;
  {$ENDREGION}


///<summary>Procedure loading the dll named "LDAP".
///<param name="APath_File_DLL">The absolute path to the dll.</param>
procedure Load_LDAP(APath_File_DLL: string);

///<summary>Procedure unloading the dll named "LDAP".</summary>
procedure Unload_LDAP;

///<summary>Function returning true if the dll "LDAP" was loaded.</summary>
function Get_Dll_LDAP_Loaded: boolean;

implementation

var
  hDll: THandle;

procedure Load_LDAP(APath_File_DLL: string);
resourcestring
  RS_Error_Invalide_File='Le fichier %s n''est pas valide.';
begin
  if hDll <> 0 then
    exit;

  Check_FileExists(APath_File_DLL);

  hDll := Load_Dll(APath_File_DLL);

  {$REGION 'U_Main_LDAP'}
  @SLDAP_Init := Get_Dll_Function_Adress(hDll,'SLDAP_Init',APath_File_DLL);
  @SLDAP_Bind := Get_Dll_Function_Adress(hDll,'SLDAP_Bind',APath_File_DLL);
  @SLDAP_Get_Infos := Get_Dll_Function_Adress(hDll,'SLDAP_Get_Infos',APath_File_DLL);
  @SLDAP_UserExist := Get_Dll_Function_Adress(hDll,'SLDAP_UserExist',APath_File_DLL);
  {$ENDREGION}


end;

procedure Unload_LDAP;
begin
  if hDll <> 0 then
  begin
    try
      FreeLibrary(hDll);
      hDll := 0;
    except
    end;
  end;
end;

function Get_Dll_LDAP_Loaded: boolean;
begin
  result := (hDll>0)
end;

initialization
  hDll := 0;

finalization
  Unload_LDAP;

end.